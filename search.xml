<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2020/02/10/%E6%95%B0%E6%8D%AE%E5%BA%93litepal%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>title: 数据库litepal使用记录</p>
<h2 id="date-2020-02-10-15-20-34"><a href="#date-2020-02-10-15-20-34" class="headerlink" title="date: 2020-02-10 15:20:34"></a>date: 2020-02-10 15:20:34</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>litepal是郭霖的一款开源的android数据库框架，采用关系映射(ORM)的模式，<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">这是github<br>地址</a>，最新版本已经更新到1.6，支持eclipse，gridle使用如下：</p>
<pre><code> compile &#39;org.litepal.android:core:1.6.0&#39;</code></pre><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>创建<code>assets</code>目录，新建<code>litepal.xml</code>文件：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;litepal&gt;
    &lt;!--数据库名字 --&gt;
    &lt;dbname value=&quot;demo&quot; /&gt;

    &lt;!--数据库版本 --&gt;
    &lt;version value=&quot;1&quot; /&gt;

    &lt;!--数据库实体类,用于映射--&gt;
    &lt;list&gt;
            &lt;mapping class=&quot;com.test.model.Reader&quot; /&gt;
            &lt;mapping class=&quot;com.test.model.Magazine&quot; /&gt;
    &lt;/list&gt;

&lt;/litepal&gt;</code></pre><a id="more"></a>

<p>litepal初始化有两种方式：</p>
<p>1.将你清单文件的<code>Application</code>换成<code>LitePalApplication</code></p>
<pre><code>&lt;manifest&gt;
    &lt;application
        android:name=&quot;org.litepal.LitePalApplication&quot;
        ...
    &gt;
        ...
    &lt;/application&gt;
&lt;/manifest&gt;</code></pre><p>2.将你的<code>Application</code>继承自<code>Application</code>,然后在onCreat()，进行<code>litepal</code>的初始化</p>
<pre><code>public class MyOwnApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        LitePal.initialize(this);
    }
    ...
}</code></pre><h3 id="使用litepal"><a href="#使用litepal" class="headerlink" title="使用litepal"></a>使用litepal</h3><p><img src="http://upload-images.jianshu.io/upload_images/7426378-007c1a5ff7749d52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><p><code>litepal</code>需要用于映射的实体类需要继承<code>DataSupport</code>，并生成get和set方法，关于这两个方法，推荐一个库:<br><code>lombok</code>，gridle使用添加:</p>
<blockquote>
<p>compile ‘org.projectlombok:lombok:1.16.18’</p>
</blockquote>
<p>添加之后你的get和set方法只用在类名上面添加注解@Data就可以了，如下</p>
<pre><code>@Data
public class Man{  

   @Column(unique = true, defaultValue = &quot;unknown&quot;)
    private int age;  

    private String name;  
}</code></pre><p>实体类支持注解约束：</p>
<pre><code>@Column(unique = true)                //是否唯一
@Column(defaultValue = &quot;unknown&quot;)    //指定字段默认值
@Column(nullable = false)            //是否可以为空
@Column(ignore = true)                //是否可以忽略</code></pre><h4 id="修改litepal-xml"><a href="#修改litepal-xml" class="headerlink" title="修改litepal.xml"></a>修改litepal.xml</h4><p>当你添加表或修改表结构，都要修改litepal.xml，首先版本号要+1，如果添加表，还要添加</p>
<pre><code> &lt;list&gt;  
        &lt;mapping class=&quot;com.example.alguojian.bean.Man&quot;&gt;&lt;/mapping&gt;  
 &lt;/list&gt;  </code></pre><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><pre><code>Album album = new Album();
album.setName(&quot;album&quot;);
album.setPrice(10.99f);
album.setCover(getCoverImageBytes());
album.save();
Song song1 = new Song();
song1.setName(&quot;song1&quot;);
song1.setDuration(320);
song1.setAlbum(album);
song1.save();
Song song2 = new Song();
song2.setName(&quot;song2&quot;);
song2.setDuration(356);
song2.setAlbum(album);
song2.save();</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>1.指定id:</p>
<pre><code>Album albumToUpdate = new Album();
albumToUpdate.setPrice(20.99f); // raise the price
albumToUpdate.update(2);</code></pre><p>2.条件更新：</p>
<pre><code>Album albumToUpdate = new Album();
albumToUpdate.setPrice(20.99f); // raise the price
albumToUpdate.updateAll(&quot;name = ?&quot;, &quot;小明&quot;);</code></pre><p>3.多个条件用and连接</p>
<pre><code>Album album= new Album();  
album.setTitle(&quot;第3次更新&quot;);  
album.updateAll(&quot;title = ? and age&gt; ?&quot;, &quot;第2次更新&quot;, &quot;12&quot;);
</code></pre><p>4.更新全部数据,将表所有数据名字修改：</p>
<pre><code>Man values = new Man();  
values.put(&quot;Name&quot;, &quot;小化工&quot;);  
DataSupport.updateAll(Man.class, values);</code></pre><p>5.异步更新数据</p>
<pre><code>Album album = new Album();
album.setName(&quot;album&quot;);
album.setPrice(10.99f);
album.setCover(getCoverImageBytes());
album.saveAsync().listen(new SaveCallback() {
    @Override
    public void onFinish(boolean success) {

    }
});</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>1.指定ID</p>
<pre><code>DataSupport.delete(Man.class, id);</code></pre><p>2.条件删除,多个条件用and连接</p>
<pre><code>DataSupport.deleteAll(Man.class, &quot;age &gt; ?&quot; , &quot;15&quot;);</code></pre><p>3.删除全表数据</p>
<pre><code>DataSupport.deleteAll(Man.class);</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>1.查询第一条以及最后一条</p>
<pre><code>News firstNews = DataSupport.findFirst(News.class);

News lastNews = DataSupport.findLast(News.class);</code></pre><p>2.指定id</p>
<pre><code>Song song = DataSupport.find(Song.class, id);

//指定多个id如下
//方式一：
List&lt;News&gt; newsList = DataSupport.findAll(News.class, 1, 3, 5, 7);

//方式二：
long[] ids = new long[] { 1, 3, 5, 7 };  
List&lt;News&gt; newsList = DataSupport.findAll(News.class, ids);
</code></pre><p>3.查询所有</p>
<pre><code>List&lt;Song&gt; allSongs = DataSupport.findAll(Song.class);</code></pre><p>4.条件查询</p>
<p>查询 Man表 中 年龄大于12 的 第5到20条 数据，以插入时间倒序 排序方式呈现，只取 “名字”和“性别”和“身高” 三列内容。</p>
<pre><code>List&lt;Man&gt; list = DataSupport.select(&quot;name&quot;, &quot;sex&quot;,&quot;height&quot;)//需要的条目
                                 .where(&quot;age&gt; ?&quot;, &quot;12&quot;)//条件
                                 .order(&quot;inputTime desc&quot;)//倒序字段
                                 .offset(5)//开始查询位置
                                 .limit(15)//数据长度
                                 .find(Man.class);//查询表
</code></pre><p>5.异步查询，用于代替findAll</p>
<pre><code>DataSupport.findAllAsync(Song.class).listen(new FindMultiCallback() {
    @Override
    public &lt;T&gt; void onFinish(List&lt;T&gt; t) {
        List&lt;Song&gt; allSongs = (List&lt;Song&gt;) t;
    }
});</code></pre><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p><code>LitePal.deleteDatabase(&quot;数据库名&quot;);</code></p>
<h3 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h3><p>关于litepal更多用法可以查看源码<br>github地址：<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/01/06/android%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>title: android本地存储目录</p>
<h2 id="date-2020-01-06-12-20-34"><a href="#date-2020-01-06-12-20-34" class="headerlink" title="date: 2020-01-06 12:20:34"></a>date: 2020-01-06 12:20:34</h2><h3 id="android本地存储目录"><a href="#android本地存储目录" class="headerlink" title="android本地存储目录"></a>android本地存储目录</h3><ul>
<li>内部存储</li>
<li>外部存储<ul>
<li>应用私有目录</li>
<li>外部目录</li>
</ul>
</li>
</ul>
<a id="more"></a>


<h2 id="获得内部存储目录"><a href="#获得内部存储目录" class="headerlink" title="获得内部存储目录"></a>获得内部存储目录</h2><pre><code>    /**
     * 获得私有目录文件，卸载之后会自动删除，7.0之后私有目录访问权限必须添加fileprovider访问
     */
    private void init() {

        //绝对路径,=/data/user/0/packname/files
        File filesDir = mContext.getFilesDir();
        filesDir.getAbsolutePath();

        //缓存路径，sp等,=/data/user/0/packname/cache
        File cacheDir = mContext.getCacheDir();
        cacheDir.getAbsolutePath();

        boolean b = mContext.deleteFile(&quot;&quot;);

        String[] strings = mContext.fileList();

        //获得私有目录内的自建目录，=/data/user/0/packname/app_myFile
        String myFile = mContext.getDir(&quot;myFile&quot;, MODE_PRIVATE).getAbsolutePath();

        //获得data目录=/data
        File dataDirectory = Environment.getDataDirectory();

    }</code></pre><h2 id="获得外部存储目录"><a href="#获得外部存储目录" class="headerlink" title="获得外部存储目录"></a>获得外部存储目录</h2><pre><code>    /**
     * 外部存储路径，sd等
     * &lt;p&gt;
     * /storage/emulated/0/Android/data/app package name
     */
    private void init2() {

        //在4.4以前系统中可能会获得null，因为4.4之前如果没有插sd卡，就代表没有外部存储，
        //获得某个应用在外部存储中的files路径，=/storage/emulated/0/Android/data/packname/files
        File externalFilesDir = mContext.getExternalFilesDir(&quot;&quot;);
        String absolutePath = externalFilesDir.getAbsolutePath();

        //获得某个应用在外部存储中的cache路径,=/storage/emulated/0/Android/data/packname/cache
        String absolutePath1 = mContext.getExternalCacheDir().getAbsolutePath();


        //通过Environment获得的时候需要申请权限,获得外部存储的根路径=/storage/emulated/0
        String absolutePath3 = Environment.getExternalStorageDirectory().getAbsolutePath();

        //,获得外部存储的根路径=/storage/emulated/0
        String absolutePath2 = Environment.getExternalStoragePublicDirectory(&quot;&quot;).getAbsolutePath();

    }
</code></pre><h1 id="获得外部存储目录-1"><a href="#获得外部存储目录-1" class="headerlink" title="获得外部存储目录"></a>获得外部存储目录</h1><pre><code> /**
     * 获得外部存储路径,包括机身外部存储以及sd卡存储
     */
    public void getExternalStoragePath() {

        File[] files;
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            files = mContext.getExternalFilesDirs(Environment.MEDIA_MOUNTED);
            for (File file : files) {
                Log.e(&quot;main&quot;, file.getPath());
            }
        }
    }</code></pre><h1 id="其他目录"><a href="#其他目录" class="headerlink" title="其他目录"></a>其他目录</h1><pre><code>     Environment.getDownloadCacheDirectory();//,=/cache
     Environment.getRootDirectory();//,=system</code></pre>]]></content>
  </entry>
  <entry>
    <title>再不学git我们就老了</title>
    <url>/2019/08/23/%E5%86%8D%E4%B8%8D%E5%AD%A6git%E6%88%91%E4%BB%AC%E5%B0%B1%E8%80%81%E4%BA%86/</url>
    <content><![CDATA[<h3 id="git-配置，可以重复设置，二者相对应"><a href="#git-配置，可以重复设置，二者相对应" class="headerlink" title="git 配置，可以重复设置，二者相对应"></a>git 配置，可以重复设置，二者相对应</h3><p><code>git config —global user.name &quot;ALguojian&quot;</code></p>
<p><code>git config —global user.email &quot;jzhszy@foxmail.com&quot;</code></p>
<h3 id="重置远程库的账号密码，针对https连接"><a href="#重置远程库的账号密码，针对https连接" class="headerlink" title="重置远程库的账号密码，针对https连接"></a>重置远程库的账号密码，针对https连接</h3><p><code>git config --global credential.helper store</code></p>
<a id="more"></a>

<h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><ul>
<li><p>git branch -m devel develop (重命名本地分支名字,命名之后，直接提交到远程，然后需要将本地和远程分支同步一次)</p>
</li>
<li><p>git branch –set-upstream-to=origin/develop （同步本地和远程连接）</p>
</li>
<li><p>git rm -r –cached . (删除在git管理中文件的缓存)</p>
</li>
<li><p>git rm -f aa.build  (强制删除在git管理中文件的缓存)</p>
</li>
<li><p><code>mkdir test</code> （创建文件夹test）</p>
</li>
<li><p><code>cd test</code> （切换到test目录）</p>
</li>
<li><p><code>touch a.md</code> （新建a.md文件）</p>
</li>
<li><p><code>git init</code> (初始化git仓库)默认在master分支</p>
</li>
<li><p><code>git status</code>（查看状态）</p>
</li>
<li><p><code>git add</code>   (缓存，待提交)</p>
</li>
<li><p><code>git add .</code> (添加所有文件)</p>
</li>
<li><p><code>git add -u</code>     (将文件的修改、文件的删除，添加到暂存区)</p>
</li>
<li><p><code>git add -A</code>    (将文件的修改，文件的删除，文件的新建，添加到暂存区)</p>
</li>
<li><p><code>git rm --cached</code> (删除缓存)</p>
</li>
<li><p><code>git fetch origin</code>  （自动获取更新远程分支）</p>
</li>
<li><p><code>git commit</code>    (提交)      git commit -m “第一次提交”</p>
</li>
<li><p><code>git commit -am &quot;提交信息&quot;</code>    (所有的改动都更新到缓存区并提交，相当于git add .和git commit -m 的合并)</p>
</li>
<li><p><code>git log</code> （commit记录）</p>
</li>
<li><p><code>git branch</code> 分支（查看本地分支）</p>
</li>
<li><p><code>git branch -r</code>   （查看远程分支列表）</p>
</li>
<li><p><code>git checkout develop origin/develop</code>    （远程的 develop 分支迁到本地）</p>
</li>
<li><p><code>git checkout -b develop origin/develop</code>    （把远程分支迁到本地顺便切换到该分支）</p>
</li>
<li><p><code>git branch a</code> （创建分支 a）</p>
</li>
<li><p><code>git checkout a</code> （切换到 a 分支）</p>
</li>
<li><p><code>git checkout -b a</code> (创建并切换到 a分支)</p>
</li>
<li><p><code>git merge a</code>（合并分支 a 到主分支）合并之前先切换到master分支（在master执行）</p>
</li>
<li><p><code>git rebase a</code>    （合并分支a）（在a分支处理）</p>
</li>
<li><p><code>git rebase -i  &lt;commitID&gt;</code>(删去那些无关紧要的提交,整理提交记录)</p>
</li>
<li><p><code>git rebase side another</code> 合并another分支到side分支上，并且提交记录在最前端</p>
</li>
<li><p><code>git commit --amend -m &quot;这是新的提交日志&quot;</code>修改上次提交日志</p>
</li>
</ul>
<blockquote>
<p> merge只是合并另外一个分支的内容，rebase也合并另外一个分支的内容，但是会把本分支的commits顶到最顶端。具体可以查看下面的说法<br><a href="https://www.zhihu.com/question/36509119/answer/67828312" target="_blank" rel="noopener">https://www.zhihu.com/question/36509119/answer/67828312</a><br><a href="http://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank" rel="noopener">http://www.cnblogs.com/kidsitcn/p/5339382.html</a><br><a href="http://blog.csdn.net/fybon/article/details/52460516" target="_blank" rel="noopener">http://blog.csdn.net/fybon/article/details/52460516</a></p>
<ul>
<li><code>git branch -d a</code> (删除分支 a )</li>
<li><code>git branch -D a</code> （强制删除分支a，针对于 a 有代码没有合并到master，git branch -d a 删除不了）</li>
<li><code>git push  --delete origin devloper</code> （删除远程分支）</li>
<li><code>git tag v1.0</code>（建立版本1.0，查看历史版本）</li>
<li><code>git checkout v1.0</code> （切换到1.0版本）</li>
<li><code>git stash</code>   （把当前分支所有没有commit的代码暂时保存起来（执行了add 也无所谓）） </li>
<li><code>git stash list</code>  （查看暂存区的记录）</li>
<li><code>git stash apply</code> （回到暂存之前）</li>
<li><code>git stash drop</code>  （回来之后建议删除stash记录）</li>
<li><code>git stash pop</code>   （回到暂存之前，并删除记录）</li>
<li><code>git stash clear</code><br>是清空所有暂存区的记录，drop 是只删除一条，当然后面可以跟 stash_id 参数来删除指<br>定的某条记录，不跟参数就是删除最近的，而 clear 是清空。</li>
<li><code>git rebase -i HEAD~4</code>    （改变之前4次提交的顺序）</li>
<li><code>git reset HEAD~a</code>     （回退到某一个版本）（reset只在本地使用，远程推送建议使用<code>revert</code>会再提交一个新的纪录，该记录引入更改–这些更改刚好就是用来撤销上次提交的，回到上次提交之前的状态）</li>
<li><code>git reset   HEAD^</code>     （回退到上一个版本）</li>
<li><code>git reset  HEAD^^</code>     （回退到上上个版本）</li>
<li><code>git reflog</code>  （回退错了，前进）</li>
<li><code>git revert HEAD</code>(撤销上次提交，用于远程推送)</li>
</ul>
</blockquote>
<h3 id="添加SSH"><a href="#添加SSH" class="headerlink" title="添加SSH"></a>添加SSH</h3><p>在git bash 输入 <code>ssh-keygen -t rsa</code> 生成文件，github创建新的SSH并填入，之后输入 <code>ssh -T git@github.com</code> 测试是否添加成功</p>
<h3 id="推送或者下拉（先pull再push）"><a href="#推送或者下拉（先pull再push）" class="headerlink" title="推送或者下拉（先pull再push）"></a>推送或者下拉（先pull再push）</h3><p><code>git push origin master</code>    推送</p>
<p><code>git pull origin master</code>    下拉</p>
<p><code>git pull origin master --allow-unrelated-histories</code><br> <code>git push -f origin master</code> 更新</p>
<p><code>git clone git@github.com:ALguojian/test.git</code>下载github上面的项目到本地</p>
<h3 id="关联giuhub仓库"><a href="#关联giuhub仓库" class="headerlink" title="关联giuhub仓库"></a>关联giuhub仓库</h3><p><code>git remote add origin https://github.com/ALguojian/git_study.git</code></p>
<p><code>origin</code>就是仓库名字，建议名字和远程仓库一样，较易管理</p>
<p><code>git remote -v</code>     查看该项目有哪些仓库</p>
<p><code>git push origin master</code>    提交代码可以到 <code>master</code> 分支，或者其他分支</p>
<p><code>git remote rm &quot;origin&quot;</code>    删除<code>origin</code>远程仓库</p>
<h3 id="alias-配置-简短参数"><a href="#alias-配置-简短参数" class="headerlink" title="alias 配置 简短参数"></a>alias 配置 简短参数</h3><p><code>git config --global alias.c checkout</code><br><code>git config --global alias.cm commit</code><br><code>git config --global alias.st status</code><br><code>git config --global alias.br branch</code></p>
<p><code>git config -l</code> 查看所有配置</p>
<h3 id="补充，移动到其他提交记录-即HEAD的指向"><a href="#补充，移动到其他提交记录-即HEAD的指向" class="headerlink" title="补充，移动到其他提交记录,即HEAD的指向"></a>补充，移动到其他提交记录,即<code>HEAD</code>的指向</h3><p><code>git  checkout a</code> 不仅用于切换分支还可用于切换提交记录，此时a代表提交记录的哈希值(很长)，不过只需要前几位即可</p>
<ul>
<li>使用 <code>^</code> 向上移动 1 个提交记录</li>
<li>使用<code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>
</ul>
<p><code>^</code>后面加数字标识回到父类其他分支用法：<br><code>git checkout HEAD~; git checkout HEAD^2; git checkout HEAD~2</code></p>
<p>并且还支持链式操作：<br><code>git checkout HEAD~^2~2</code></p>
<p>所以<code>master^</code>相当于“<code>master</code> 的父节点”。<code>master^^</code> 是 <code>master</code> 的第二个父节点，也可以将 <code>HEAD</code> 作为相对引用的参照,可以一直使用 <code>HEAD^</code>向上移动</p>
<p><code>git branch -f master HEAD~3</code> 将 master 分支强制指向 HEAD 的第 3 级父提交(强行改变分支所处位置)</p>
<p><code>git cherry-pick C2 C3 C4</code>(改变提交记录与主分支，C2是提交的记录的哈希值)</p>
<p><code>git fetch</code> 同步绑定的仓库（一般是其他分支）</p>
<p><code>git pull</code> 就是 <code>git fetch</code> 和 <code>git merge &lt;just-fetched-branch&gt;</code> 的缩写！</p>
<p><code>git fakeTeamwork foo 3</code>模拟远程提交，可以指定分支和次数</p>
]]></content>
  </entry>
  <entry>
    <title>android有关动画梳理</title>
    <url>/2019/06/28/android%E6%9C%89%E5%85%B3%E5%8A%A8%E7%94%BB%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h1><blockquote>
<p>只能作用在view上，只有四种动画，只是改变view的视觉效果，不会改变view真正的属性<br>效果有：平移(Translate)，缩放(scale)，旋转(rotate)，透明度(alpha)</p>
</blockquote>
<p><strong>补间动画使用方式，在anim创建xml文件，使用代码动态开启动画</strong></p>
<a id="more"></a>

<h2 id="平移动画-translate"><a href="#平移动画-translate" class="headerlink" title="平移动画 translate"></a>平移动画 translate</h2><h4 id="使用xml"><a href="#使用xml" class="headerlink" title="使用xml"></a>使用xml</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

    android:duration=&quot;3000&quot; // 动画持续时间（ms），必须设置，动画才有效果
    android:startOffset =&quot;1000&quot; // 动画延迟开始时间（ms）
    android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true
    android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false
    android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true
    android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|
    android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复
    android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲

    android:fromXDelta=&quot;0&quot; // 视图在水平方向x 移动的起始值
    android:toXDelta=&quot;500&quot; // 视图在水平方向x 移动的结束值
    android:fromYDelta=&quot;0&quot; // 视图在竖直方向y 移动的起始值
    android:toYDelta=&quot;500&quot; // 视图在竖直方向y 移动的结束值 /&gt;</code></pre><h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><pre><code>        Animation animation = AnimationUtils.loadAnimation(this, R.anim.translateanim);
        button.startAnimation(animation);

        TranslateAnimation translateAnimation = new TranslateAnimation(0, 500, 0, 500);
        translateAnimation.setDuration(2000);
        button.startAnimation(translateAnimation);</code></pre><h2 id="缩放动画-scale"><a href="#缩放动画-scale" class="headerlink" title="缩放动画 scale"></a>缩放动画 scale</h2><h4 id="使用xml-1"><a href="#使用xml-1" class="headerlink" title="使用xml"></a>使用xml</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;scale  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

    android:fromXScale=&quot;0.0&quot; 
    // 动画在水平方向X的起始缩放倍数
    // 0.0表示收缩到没有；1.0表示正常无伸缩
    // 值小于1.0表示收缩；值大于1.0表示放大

    android:toXScale=&quot;2&quot;  //动画在水平方向X的结束缩放倍数

    android:fromYScale=&quot;0.0&quot; //动画开始前在竖直方向Y的起始缩放倍数
    android:toYScale=&quot;2&quot; //动画在竖直方向Y的结束缩放倍数

    android:pivotX=&quot;50%&quot; // 缩放轴点的x坐标
    android:pivotY=&quot;50%&quot; // 缩放轴点的y坐标
    // 轴点 = 视图缩放的中心点

    // pivotX pivotY,可取值为数字，百分比，或者百分比p
    // 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。
    // 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。
    // 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT /&gt;</code></pre><h4 id="java-代码"><a href="#java-代码" class="headerlink" title="java 代码"></a>java 代码</h4><pre><code>        Button mButton = (Button) findViewById(R.id.Button);
        // 步骤1:创建 需要设置动画的 视图View
        Animation rotateAnimation = AnimationUtils.loadAnimation(this, R.anim.view_animation);
        // 步骤2:创建 动画对象 并传入设置的动画效果xml文件
        mButton.startAnimation(scaleAnimation);



        Button mButton = (Button) findViewById(R.id.Button);
        Animation rotateAnimation = new ScaleAnimation(0,2,0,2,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
        // 步骤2：创建缩放动画的对象 &amp; 设置动画效果：缩放动画对应的Animation子类为RotateAnimation
        // 参数说明:
        // 1. fromX ：动画在水平方向X的结束缩放倍数
        // 2. toX ：动画在水平方向X的结束缩放倍数
        // 3. fromY ：动画开始前在竖直方向Y的起始缩放倍数
        // 4. toY：动画在竖直方向Y的结束缩放倍数
        // 5. pivotXType:缩放轴点的x坐标的模式
        // 6. pivotXValue:缩放轴点x坐标的相对值
        // 7. pivotYType:缩放轴点的y坐标的模式
        // 8. pivotYValue:缩放轴点y坐标的相对值

        // pivotXType = Animation.ABSOLUTE:缩放轴点的x坐标 =  View左上角的原点 在x方向 加上 pivotXValue数值的点(y方向同理)
        // pivotXType = Animation.RELATIVE_TO_SELF:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 自身宽度乘上pivotXValue数值的值(y方向同理)
        // pivotXType = Animation.RELATIVE_TO_PARENT:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 父控件宽度乘上pivotXValue数值的值 (y方向同理)

        scaleAnimation.setDuration(3000);
        mButton.startAnimation(scaleAnimation);</code></pre><h2 id="旋转动画-rotate"><a href="#旋转动画-rotate" class="headerlink" title="旋转动画 rotate"></a>旋转动画 rotate</h2><h4 id="使用xml-2"><a href="#使用xml-2" class="headerlink" title="使用xml"></a>使用xml</h4><pre><code>      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
      &lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

        android:duration=&quot;1000&quot;
        android:fromDegrees=&quot;0&quot; // 动画开始时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针)
        android:toDegrees=&quot;270&quot; // 动画结束时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针)
        android:pivotX=&quot;50%&quot; // 旋转轴点的x坐标
        android:pivotY=&quot;0&quot; // 旋转轴点的y坐标 /&gt;</code></pre><h4 id="java-代码-1"><a href="#java-代码-1" class="headerlink" title="java 代码"></a>java 代码</h4><pre><code>        Animation rotateAnimation = new RotateAnimation(0, 270, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
        rotateAnimation.setDuration(2000);
        button.startAnimation(rotateAnimation);
</code></pre><h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><h4 id="使用-xml"><a href="#使用-xml" class="headerlink" title="使用 xml"></a>使用 xml</h4><pre><code>      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
      &lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
         // 以下参数是透明度动画特有的属性
        android:fromAlpha=&quot;1.0&quot; // 动画开始时视图的透明度(取值范围: -1 ~ 1)
        android:toAlpha=&quot;0.0&quot;// 动画结束时视图的透明度(取值范围: -1 ~ 1)/&gt;</code></pre><h4 id="java-代码-2"><a href="#java-代码-2" class="headerlink" title="java 代码"></a>java 代码</h4><pre><code>        Button mButton = (Button) findViewById(R.id.Button);
        // 步骤1:创建 需要设置动画的 视图View

        Animation alphaAnimation = new AlphaAnimation(1,0);
        // 步骤2：创建透明度动画的对象 &amp; 设置动画效果：透明度动画对应的Animation子类为AlphaAnimation
        // 参数说明:
        // 1. fromAlpha:动画开始时视图的透明度(取值范围: -1 ~ 1)
        // 2. toAlpha:动画结束时视图的透明度(取值范围: -1 ~ 1)

        alphaAnimation.setDuration(3000);
        // 固定属性的设置都是在其属性前加“set”，如setDuration（）

        mButton.startAnimation(alphaAnimation);</code></pre><h2 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h2><h4 id="使用-xml-1"><a href="#使用-xml-1" class="headerlink" title="使用 xml"></a>使用 xml</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
// 采用&lt; Set/&gt;标签
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

// 组合动画独特的属性
    android:shareinterpolator = “true”
    // 表示组合动画中的动画是否和集合共享同一个差值器
    // 如果集合不指定插值器，那么子动画需要单独设置

// 组合动画播放时是全部动画同时开始
// 如果想不同动画不同时间开始就要使用android:startOffset属性来延迟单个动画播放时间


    &lt;rotate
        android:duration=&quot;1000&quot;
        android:fromDegrees=&quot;0&quot;
        android:toDegrees=&quot;360&quot;
        android:pivotX=&quot;50%&quot;
        android:pivotY=&quot;50%&quot;
        android:repeatMode=&quot;restart&quot;
        android:repeatCount=&quot;infinite&quot;/&gt;

    &lt;translate
        android:duration=&quot;10000&quot;
        android:startOffset = “1000”
        android:fromXDelta=&quot;-50%p&quot;
        android:fromYDelta=&quot;0&quot;
        android:toXDelta=&quot;50%p&quot;
        android:toYDelta=&quot;0&quot; /&gt;

    &lt;alpha
        android:startOffset=&quot;7000&quot;
        android:duration=&quot;3000&quot;
        android:fromAlpha=&quot;1.0&quot;
        android:toAlpha=&quot;0.0&quot; /&gt;

    &lt;scale
        android:startOffset=&quot;4000&quot;
        android:duration=&quot;1000&quot;
        android:fromXScale=&quot;1.0&quot;
        android:fromYScale=&quot;1.0&quot;
        android:pivotX=&quot;50%&quot;
        android:pivotY=&quot;50%&quot;
        android:toXScale=&quot;0.5&quot;
        android:toYScale=&quot;0.5&quot;/&gt;

    1. 在组合动画里scale缩放动画设置的repeatCount（重复播放）和fillBefore（播放完后，视图是否会停留在动画开始的状态）是无效的。
    2. 所以如果需要重复播放或者回到原位的话需要在set标签里设置
    3. 但是由于此处rotate旋转动画里已设置repeatCount为infinite，所以动画不会结束，也就看不到重播和回复原位
&lt;/set&gt;</code></pre><h4 id="使用-java代码"><a href="#使用-java代码" class="headerlink" title="使用 java代码"></a>使用 java代码</h4><pre><code>        Button mButton = (Button) findViewById(R.id.Button);
        // 创建 需要设置动画的 视图View

        // 组合动画设置
        AnimationSet setAnimation = new AnimationSet(true);
        // 步骤1:创建组合动画对象(设置为true)


        // 步骤2:设置组合动画的属性
        // 特别说明以下情况
        // 因为在下面的旋转动画设置了无限循环(RepeatCount = INFINITE)
        // 所以动画不会结束，而是无限循环
        // 所以组合动画的下面两行设置是无效的
        setAnimation.setRepeatMode(Animation.RESTART);
        setAnimation.setRepeatCount(1);// 设置了循环一次,但无效

        // 子动画1:旋转动画
        Animation rotate = new RotateAnimation(0,360,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
        rotate.setDuration(1000);
        rotate.setRepeatMode(Animation.RESTART);
        rotate.setRepeatCount(Animation.INFINITE);

        // 子动画2:平移动画
        Animation translate = new TranslateAnimation(TranslateAnimation.RELATIVE_TO_PARENT,-0.5f,
                TranslateAnimation.RELATIVE_TO_PARENT,0.5f,
                TranslateAnimation.RELATIVE_TO_SELF,0
                ,TranslateAnimation.RELATIVE_TO_SELF,0);
        translate.setDuration(10000);

        // 子动画3:透明度动画
        Animation alpha = new AlphaAnimation(1,0);
        alpha.setDuration(3000);
        alpha.setStartOffset(7000);

        // 子动画4:缩放动画
        Animation scale1 = new ScaleAnimation(1,0.5f,1,0.5f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
        scale1.setDuration(1000);
        scale1.setStartOffset(4000);

        // 步骤4:将创建的子动画添加到组合动画里
        setAnimation.addAnimation(alpha);
        setAnimation.addAnimation(rotate);
        setAnimation.addAnimation(translate);
        setAnimation.addAnimation(scale1);

        mButton.startAnimation(setAnimation);</code></pre><h1 id="帧动画，将动画切割为多张图片"><a href="#帧动画，将动画切割为多张图片" class="headerlink" title="帧动画，将动画切割为多张图片"></a>帧动画，将动画切割为多张图片</h1><h4 id="使用xml创建"><a href="#使用xml创建" class="headerlink" title="使用xml创建"></a>使用xml创建</h4><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
  &lt;animation-list
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;true&quot; 
    // 设置是否只播放一次，默认为false&gt;

    //item = 动画图片资源；duration = 设置一帧持续时间(ms)
    &lt;item android:drawable=&quot;@drawable/a0&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a1&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a2&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a3&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a4&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a5&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a6&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/a7&quot; android:duration=&quot;100&quot;/&gt;
&lt;/animation-list&gt;</code></pre><h4 id="使用java代码"><a href="#使用java代码" class="headerlink" title="使用java代码"></a>使用java代码</h4><pre><code>        ImageView imageView = new ImageView(this);
        imageView.setImageResource(R.drawable.ic_launcher_background);
        AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();
        animationDrawable.start();
        animationDrawable.stop();


        //动态创建帧动画
        AnimationDrawable animationDrawable1 = new AnimationDrawable();
        for (int i = 0; i &lt; 10; i++) {
            int drawable = getResources().getIdentifier(&quot;aaa&quot; + i, &quot;drawable&quot;, getPackageName());
            Drawable drawable1 = getResources().getDrawable(drawable);
            animationDrawable1.addFrame(drawable1,100);
        }
        animationDrawable1.setOneShot(true);
        ImageView imageView1 = new ImageView(this);
        imageView.setImageResource(R.drawable.ic_launcher_background);
        //开启动画之前先停止动画，不然第一次动画之后会停留在最后一帧，这样动画就只会触发一次
        animationDrawable1.stop();
        animationDrawable1.start();
</code></pre><h2 id="监听动画过程"><a href="#监听动画过程" class="headerlink" title="监听动画过程"></a>监听动画过程</h2><pre><code>    alphaAnimation.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {

            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }
        });</code></pre><h4 id="属性动画可以采用以下监听"><a href="#属性动画可以采用以下监听" class="headerlink" title="属性动画可以采用以下监听"></a>属性动画可以采用以下监听</h4><pre><code> ValueAnimator valueAnimator = ValueAnimator.ofFloat(0.0f, 120f);
        valueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                super.onAnimationStart(animation);
            }
        });</code></pre><h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><blockquote>
<p>3.0之后出现。顾名思义，为了改变view的某一个属性的动画</p>
</blockquote>
<p>使用步骤如下：</p>
<ol>
<li><p>设置动画运行时长，动画效果以及对应属性的初始值和结束值</p>
</li>
<li><p>设置从开始到结束的变化逻辑</p>
<ul>
<li>设置值变化的模式趋势使用插值器，自定义插值器需要实现interpolator接口</li>
<li>设置值变化的具体数值使用估值器，自定义估值器实现TypeEvaluator接口</li>
</ul>
</li>
<li><p>根据变化不断改变值得效果</p>
</li>
<li><p>值每改变一次，就赋值给view的属性一次，</p>
<ul>
<li>手动赋值使用-valueAnimator</li>
<li>自动赋值使用-ObjectAnimator</li>
</ul>
</li>
<li><p>每次调用invalidate();不断刷新视图直到初始值变为结束值</p>
</li>
</ol>
<h3 id="ValueAnimator-手动赋值给对象的属性，实现动画效果"><a href="#ValueAnimator-手动赋值给对象的属性，实现动画效果" class="headerlink" title="ValueAnimator 手动赋值给对象的属性，实现动画效果"></a>ValueAnimator 手动赋值给对象的属性，实现动画效果</h3><p>自带估值器有：</p>
<ul>
<li>ValueAnimator ofInt(int… values)，整型估值器</li>
<li>ValueAnimator ofFloat(float… values) ，浮点型估值器</li>
<li>ValueAnimator ofObject(TypeEvaluator evaluator, Object… values)操作对象实现动画效果</li>
</ul>
<h4 id="整型或者浮点型估值器"><a href="#整型或者浮点型估值器" class="headerlink" title="整型或者浮点型估值器"></a>整型或者浮点型估值器</h4><pre><code>        //设置动画属性的初始值以及结束值，ofInt创建动画实例,讲传入的多个Int型参数进行平滑过渡，内置整型估值器，直接使用默认
        final ValueAnimator valueAnimator = ValueAnimator.ofInt(100, 180, 500, 700, 600);

        mButton = findViewById(R.id.button2);

        valueAnimator.setDuration(2000);//播放时间
        valueAnimator.setStartDelay(100);//延迟播放时间
        valueAnimator.setRepeatCount(0);//设置播放次数,-1就是无限循环
        valueAnimator.setRepeatMode(ValueAnimator.REVERSE);//设置重复播放模式ValueAnimator.RESTART(默认):正序重放，ValueAnimator.REVERSE:倒序回放

        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                int animatedValue = (Integer) valueAnimator.getAnimatedValue();

                mButton.setText(&quot;---&quot; + animatedValue);

                mButton.setTranslationX(animatedValue);
                mButton.getLayoutParams().width = animatedValue;
                mButton.getLayoutParams().height = animatedValue;
                mButton.setRotation(animatedValue);
                mButton.setAlpha(animatedValue);

                mButton.requestLayout();//刷新view的位置
            }
        });
        valueAnimator.start();</code></pre><h4 id="ValueAnimator-ofObject（）将初始值-以对象的形式-过渡到结束值"><a href="#ValueAnimator-ofObject（）将初始值-以对象的形式-过渡到结束值" class="headerlink" title="ValueAnimator.ofObject（）将初始值 以对象的形式 过渡到结束值"></a>ValueAnimator.ofObject（）将初始值 以对象的形式 过渡到结束值</h4><pre><code>public class ObjectEvaluatorView extends View {

    private Paint mPaint;
    private Point mPoint;

    private static final int ROUND = 81;

    public ObjectEvaluatorView(Context context) {
        this(context, null);
    }

    public ObjectEvaluatorView(Context context, @Nullable AttributeSet attrs) {

        this(context, attrs, 0);
    }

    public ObjectEvaluatorView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.YELLOW);
        mPaint.setTextSize(120);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (mPoint == null) {
            mPoint = new Point(ROUND,ROUND);

            canvas.drawCircle(ROUND,ROUND,ROUND,mPaint);

            Point point = new Point(600, 800);
            Point point3 = new Point(80, 1200);
            Point point4 = new Point(80, 80);

            ValueAnimator valueAnimator = ValueAnimator.ofObject(new ObjectEvaluator(), mPoint, point,point3,point4);
            valueAnimator.setDuration(3000);
            valueAnimator.setRepeatCount(-1);

            valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    mPoint = (Point) animation.getAnimatedValue();

                    invalidate();
                }
            });

            valueAnimator.start();

        }else {
            canvas.drawText(&quot;😄&quot;,mPoint.getX(),mPoint.getY(),mPaint);
        }
    }
}</code></pre><h3 id="ObjectAnimator自动赋值实现动画效果，直接操作对象的属性"><a href="#ObjectAnimator自动赋值实现动画效果，直接操作对象的属性" class="headerlink" title="ObjectAnimator自动赋值实现动画效果，直接操作对象的属性"></a>ObjectAnimator自动赋值实现动画效果，直接操作对象的属性</h3><h4 id="基本的四种属性："><a href="#基本的四种属性：" class="headerlink" title="基本的四种属性："></a>基本的四种属性：</h4><pre><code>        ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton3, &quot;alpha&quot;, 1f, 0f, 100f);
        alpha.setDuration(3000);
        alpha.setRepeatCount(-1);
        alpha.start();

        ObjectAnimator rotation = ObjectAnimator.ofFloat(mButton3, &quot;rotation&quot;, 1f, 360f, 100f);
        rotation.setDuration(3000);
        rotation.setRepeatCount(-1);
        rotation.start();

        ObjectAnimator translationX = ObjectAnimator.ofFloat(mButton3, &quot;translationY&quot;, 1f, 360f, 100f);
        translationX.setDuration(3000);
        translationX.setRepeatCount(-1);
        translationX.start();

        ObjectAnimator scaleY = ObjectAnimator.ofFloat(mButton3, &quot;scaleY&quot;, 1f, 4f, 1f);
        scaleY.setDuration(3000);
        scaleY.setRepeatCount(-1);
        scaleY.start();</code></pre><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Alpha</td>
<td>控制view的透明度</td>
</tr>
<tr>
<td>TranslationX</td>
<td>控制x轴方向位移</td>
</tr>
<tr>
<td>TranslationY</td>
<td>K通知y轴方向位移</td>
</tr>
<tr>
<td>ScaleX</td>
<td>控制x轴方向缩放倍数</td>
</tr>
<tr>
<td>ScaleY</td>
<td>控制y轴方向缩放倍数</td>
</tr>
<tr>
<td>Rotation</td>
<td>控制以屏幕方向为轴的旋转度数</td>
</tr>
<tr>
<td>RotationX</td>
<td>控制以x轴为轴的旋转度数</td>
</tr>
<tr>
<td>RotationY</td>
<td>控制以y轴为轴的旋转度数</td>
</tr>
</tbody></table>
<h4 id="扩展自定义属性"><a href="#扩展自定义属性" class="headerlink" title="扩展自定义属性"></a>扩展自定义属性</h4><p>两种方式：</p>
<ol>
<li>通过集成原始类，添加get（）和set（）方法 </li>
</ol>
<pre><code>public class MyView2 extends View {
    // 设置需要用到的变量
    public static final float RADIUS = 100f;// 圆的半径 = 100
    private Paint mPaint;// 绘图画笔

    private String color;
    // 设置背景颜色属性

    // 设置背景颜色的get() &amp; set()方法
    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
        mPaint.setColor(Color.parseColor(color));
        // 将画笔的颜色设置成方法参数传入的颜色
        invalidate();
        // 调用了invalidate()方法,即画笔颜色每次改变都会刷新视图，然后调用onDraw()方法重新绘制圆
        // 而因为每次调用onDraw()方法时画笔的颜色都会改变,所以圆的颜色也会改变
    }


    // 构造方法(初始化画笔)
    public MyView2(Context context, AttributeSet attrs) {
        super(context, attrs);
        // 初始化画笔
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.BLUE);
    }

    // 复写onDraw()从而实现绘制逻辑
    // 绘制逻辑:先在初始点画圆,通过监听当前坐标值(currentPoint)的变化,每次变化都调用onDraw()重新绘制圆,从而实现圆的平移动画效果
    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawCircle(500, 500, RADIUS, mPaint);
    }
}</code></pre><ol start="2">
<li>添加包装类，传递对象进入，封装get（）和set（）方法</li>
</ol>
<pre><code>
        ObjectAnimator alpha = ObjectAnimator.ofObject(new Test(mButton3), &quot;text&quot;, new Bbb(), &quot;asdasd&quot;, &quot;qweqweqweqw&quot;, &quot;zxczxczxczc&quot;);
        alpha.setDuration(3000);
        alpha.setRepeatCount(-1);
        alpha.start();


    //自定义包装类
     private class Test{
        private Button mView;

        public Test(Button view) {
            mView = view;
        }
        public String getText(){
            return mView.getText().toString();
        }
        public void setText(String s){
            mView.setText(s);
        }
    }


    //自定义估值器
    private class Bbb implements TypeEvaluator {

        @Override
        public Object evaluate(float fraction, Object startValue, Object endValue) {
            return startValue;
        }
    }
</code></pre><h3 id="组合动画-1"><a href="#组合动画-1" class="headerlink" title="组合动画"></a>组合动画</h3><pre><code>AnimatorSet.play(Animator anim)   ：播放动画
AnimatorSet.after(long delay)   ：动画延迟x毫秒后执行
AnimatorSet.with(Animator anim)   ：现有动画和传入的动画同时执行
AnimatorSet.after(Animator anim)   ：现有动画插入到传入的动画之后执行
AnimatorSet.before(Animator anim) ：  现有动画插入到传入的动画之前执行
</code></pre><h4 id="使用方式如下："><a href="#使用方式如下：" class="headerlink" title="使用方式如下："></a>使用方式如下：</h4><pre><code>// 步骤1：设置需要组合的动画效果
ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, &quot;translationX&quot;, curTranslationX, 300,curTranslationX);  

ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, &quot;rotation&quot;, 0f, 360f);  

ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, &quot;alpha&quot;, 1f, 0f, 1f);  

AnimatorSet animSet = new AnimatorSet();  

animSet.play(translation).with(rotate).before(alpha);  
animSet.setDuration(5000);  
animSet.start();</code></pre><h3 id="属性动画简写方式："><a href="#属性动画简写方式：" class="headerlink" title="属性动画简写方式："></a>属性动画简写方式：</h3><pre><code>        mButton = (Button) findViewById(R.id.Button);
        mButton.animate().alpha(0f);
        mButton.animate().alpha(0f).setDuration(5000).setInterpolator(new BounceInterpolator());
        mButton.animate().alpha(0f).x(500).y(500);</code></pre><h1 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h1><ul>
<li>设置值变化的模式趋势使用插值器，自定义插值器需要实现interpolator接口</li>
<li>设置值变化的具体数值使用估值器，自定义估值器实现TypeEvaluator接口</li>
</ul>
<p>系统默认自带插值器有：<br>|java类|作用|<br>|–|–|<br>|AccelerateInterpolator|加速，开始时慢中间加速，系统默认|<br>|DecelerateInterpolator|减速，开始时快然后减速|<br>|AccelerateDecelerateInterolator|先加速后减速，开始结束时慢，中间加速|<br>|AnticipateInterpolator|反向，先向相反方向改变一段再加速播放|<br>|AnticipateOvershootInterpolator|反向加超越，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值|<br>|BounceInterpolator|跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100|<br>|CycleIinterpolator|循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2* mCycles* Math.PI* input)|<br>|LinearInterpolator|线性，线性均匀改变|<br>|OvershootInterpolator|超越，最后超出目的值然后缓慢改变到目的值|</p>
<h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><blockquote>
<p><strong>补间动画 实现 Interpolator接口；属性动画实现TimeInterpolator接口</strong></p>
</blockquote>
<pre><code>     private class Ccc implements TimeInterpolator {
        /**
         * @param input 范围变化1-0，
         * @return
         */
        @Override
        public float getInterpolation(float input) {
            float aa;
            if (input &lt;= 0.5) {
                aa = (float) ((Math.sin(Math.PI * input)) / 2);
            } else {
                aa = (float) (2 - Math.sin(Math.PI * input) / 2);
            }
            return aa;
        }
    }</code></pre><h3 id="自定义估值器"><a href="#自定义估值器" class="headerlink" title="自定义估值器"></a>自定义估值器</h3><pre><code>    private class Bbb implements TypeEvaluator {

        @Override
        public Object evaluate(float fraction, Object startValue, Object endValue) {

            return startValue;
        }
    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>自定义viewGroup位置摆放onLayout以及设置margin梳理</title>
    <url>/2019/06/26/%E8%87%AA%E5%AE%9A%E4%B9%89viewGroup%E4%BD%8D%E7%BD%AE%E6%91%86%E6%94%BEonLayout%E4%BB%A5%E5%8F%8A%E8%AE%BE%E7%BD%AEmargin%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>自定义viewGroup必须要实现的一个方法，实现所有子控件布局的函数，自顶向下通过计算好的尺寸放置每一个子View</p>
</blockquote>
<p><strong>首先有关getWidth()和getMeasuredWidth()的区别为：onlayout()方法内会用到</strong></p>
<ul>
<li>getMeasuredWidth()是在measure过程后就可以获取到的，getWidth()是在layout()过程结束后才能获得到的</li>
<li>getMeasuredWidth()中的值是子view在侧来最后使用setMeasuredDimension(width, height)来设置的，getWidth()的值是在onlayout()方法之后父view动态设置的</li>
<li>setMeasuredDimension(width, height)只是先确定了给父view的一个建议宽高，子view最终的宽高还是通过childAt.layout(0,top,measuredWidth,measuredHeight+top)来设置的</li>
<li>getMeasureWidth()只有在measure()过程中才可以获得，getWidth()只有在layout()之后才可以获得</li>
</ul>
<a id="more"></a>

<h3 id="如下所示："><a href="#如下所示：" class="headerlink" title="如下所示："></a>如下所示：</h3><pre><code>@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {

        int lineWidth = 0;
        int lineHeight = 0;
        int top = 0;
        int left = 0;

        int count = getChildCount();

        for (int i = 0; i &lt; count; i++) {

            View childAt = getChildAt(i);

            MarginLayoutParams layoutParams = (MarginLayoutParams) childAt.getLayoutParams();

            //得到子view的测量建议高度
            int measuredHeight = childAt.getMeasuredHeight() + layoutParams.bottomMargin + layoutParams.topMargin;
            int measuredWidth = childAt.getMeasuredWidth() + layoutParams.leftMargin + layoutParams.rightMargin;

            //换行
            if (measuredWidth + lineWidth &gt; getMeasuredWidth()) {

                top += lineHeight;
                left = 0;
                lineHeight = measuredHeight;
                lineWidth = measuredWidth;
            } else {

                lineHeight = Math.max(measuredHeight, lineHeight);
                lineWidth += measuredWidth;
            }

            //的到字view的当前位置
            int ll = left + layoutParams.leftMargin;
            int tt = top + layoutParams.topMargin;
            int rr = ll + childAt.getMeasuredWidth();
            int bb = tt + childAt.getMeasuredHeight();

            //设置子view的确定位置
            childAt.layout(ll, tt, rr, bb);

            left += measuredWidth;
        }</code></pre><h3 id="设置margin时需要重载的方法有："><a href="#设置margin时需要重载的方法有：" class="headerlink" title="设置margin时需要重载的方法有："></a>设置margin时需要重载的方法有：</h3><pre><code> @Override
    protected LayoutParams generateLayoutParams(LayoutParams p) {
        return new MarginLayoutParams(p);
    }

    @Override
    public LayoutParams generateLayoutParams(AttributeSet attrs) {
        return new MarginLayoutParams(getContext(),attrs);
    }

    @Override
    protected LayoutParams generateDefaultLayoutParams() {
        return new MarginLayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT);
    }</code></pre><h3 id="设置子view的点击事件"><a href="#设置子view的点击事件" class="headerlink" title="设置子view的点击事件"></a>设置子view的点击事件</h3><pre><code>    /**
     * 设置点击事件
     *
     * @param listener
     */
    public void setOnItemClickListener(final OnItemClickListener listener) {
        for (int i = 0; i &lt; getChildCount(); i++) {
            final int index = i;
            View childAt = getChildAt(i);
            childAt.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    listener.onItemClick(index);
                }
            });
        }
    }

    public interface OnItemClickListener {
        void onItemClick(int position);
    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>View的相关刷新重绘方法</title>
    <url>/2019/06/25/View%E7%9A%84%E7%9B%B8%E5%85%B3%E5%88%B7%E6%96%B0%E9%87%8D%E7%BB%98%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-mButton-invalidate"><a href="#1-mButton-invalidate" class="headerlink" title="1. mButton.invalidate();"></a>1. mButton.invalidate();</h3><p>View本身调用迫使view重画，可以在主线程调用，不能再子线程调用，如果需要，要配合handler使用</p>
<h3 id="2-mButton-postInvalidate"><a href="#2-mButton-postInvalidate" class="headerlink" title="2. mButton.postInvalidate();"></a>2. mButton.postInvalidate();</h3><p>可以在子线程中直接调用,底层也是通过handler来处理的</p>
<h3 id="3-postInvalidateDelayed-long-aaa"><a href="#3-postInvalidateDelayed-long-aaa" class="headerlink" title="3. postInvalidateDelayed(long aaa)"></a>3. postInvalidateDelayed(long aaa)</h3><p>设置延迟时间刷新</p>
<h3 id="4-mButton-requestLayout"><a href="#4-mButton-requestLayout" class="headerlink" title="4. mButton.requestLayout();"></a>4. mButton.requestLayout();</h3><p>当view确定自身已经不再适合现有的区域时，该view本身调用这个方法要求parent view重新调用他的onMeasure onLayout来对重新设置自己位置。只调用measure（）和layout（），不调用onDraw（）</p>
<h3 id="5-mButton-requestFocus"><a href="#5-mButton-requestFocus" class="headerlink" title="5. mButton.requestFocus();"></a>5. mButton.requestFocus();</h3><p>局部刷新，获取焦点的部分</p>
]]></content>
  </entry>
  <entry>
    <title>关于LayoutParams的使用</title>
    <url>/2019/06/24/%E5%85%B3%E4%BA%8ELayoutParams%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="主要用来动态控制子view的摆放位置"><a href="#主要用来动态控制子view的摆放位置" class="headerlink" title="主要用来动态控制子view的摆放位置"></a>主要用来动态控制子view的摆放位置</h3><pre><code>        TextView textView = new TextView(context);
        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 200);
        layoutParams.width=100;
        layoutParams.height=200;
        textView.setLayoutParams(layoutParams);</code></pre><a id="more"></a>


<p>构造函数可是设置三种参数</p>
<ul>
<li>固定数值，单位px</li>
<li>ViewGroup.LayoutParams.MATCH_PARENT ，意思为宽度和父view相同</li>
<li>ViewGroup.LayoutParams.WRAP_CONTENT，意思为自适应</li>
</ul>
<p>注意每个view所能获得的layoutparams都是他所对应的父view</p>
<h4 id="比如textview外层包裹着的是一个linearlayout，那么"><a href="#比如textview外层包裹着的是一个linearlayout，那么" class="headerlink" title="比如textview外层包裹着的是一个linearlayout，那么"></a>比如textview外层包裹着的是一个linearlayout，那么</h4><pre><code>        LinearLayout.LayoutParams layoutParams1 = (LinearLayout.LayoutParams) textView.getLayoutParams();

        //设置权重比例
        layoutParams1.weight=1;

        //设置上部间距
        layoutParams1.topMargin=5;

        //设置右边间距
        layoutParams1.setMarginEnd(20);

        //设置四周间距
        layoutParams1.setMargins(3,3,3,3);</code></pre><h4 id="如果是RelativeLayout："><a href="#如果是RelativeLayout：" class="headerlink" title="如果是RelativeLayout："></a>如果是RelativeLayout：</h4><pre><code>        RelativeLayout.LayoutParams layoutParams1 = (RelativeLayout.LayoutParams) textView.getLayoutParams();

        //设置位置居中
        layoutParams1.addRule(RelativeLayout.CENTER_IN_PARENT);

        //设置在某一个id所对应的view的右边
        layoutParams1.addRule(RelativeLayout.RIGHT_OF, R.id.all);

        layoutParams1.topMargin=5;
        layoutParams1.setMarginEnd(20);
        layoutParams1.setMargins(3,3,3,3);

        layoutParams1.removeRule(RelativeLayout.CENTER_IN_PARENT);
</code></pre><h4 id="如果是FrameLayout"><a href="#如果是FrameLayout" class="headerlink" title="如果是FrameLayout:"></a>如果是FrameLayout:</h4><pre><code>        FrameLayout.LayoutParams layoutParams1 = (FrameLayout.LayoutParams) textView.getLayoutParams();

        //设置位置居中
        layoutParams1.gravity = Gravity.CENTER;

        layoutParams1.topMargin = 5;
        layoutParams1.setMarginEnd(20);
        layoutParams1.setMargins(3, 3, 3, 3);</code></pre>]]></content>
  </entry>
  <entry>
    <title>创建bitmap的几种方法</title>
    <url>/2019/06/23/%E5%88%9B%E5%BB%BAbitmap%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>创建一个位图的方法,切记通过工厂得到的位图不能通过矩阵进行一系列转换，必须重新创建一个</li>
<li>通过流获得bitmap是会更省内存  </li>
</ul>
<a id="more"></a>

<pre><code> private Bitmap bitmap1;

    /**
     * 创建一个位图的方法,切记通过工厂得到的位图不能通过矩阵进行一系列转换，必须重新创建一个
     * Bitmap.Config枚举类，
     * Bitmap.Config getConfig
     * setConfig(Bitmap.Config config)
     * &lt;p&gt;
     * ALPHA_8
     * &lt;p&gt;
     * RGB_565
     * &lt;p&gt;
     * ARGB_8888
     * &lt;p&gt;
     * RGBA_F16
     * &lt;p&gt;
     * HARDWARE
     *
     * @param context
     */
    public void createBitmap(Context context) {

        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inPreferredConfig = Bitmap.Config.ARGB_8888;
        options.inBitmap = bitmap1;
        bitmap1 = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher, options);

        Bitmap.Config config = bitmap1.getConfig();
        bitmap1.setConfig(Bitmap.Config.ARGB_8888);


        //直接创建一个位图
        Bitmap bitmap2 = Bitmap.createBitmap(bitmap1);

        //创建一个空位图，位图信息可以通过buffer流，或者canvas复制得到
        Bitmap bitmap = Bitmap.createBitmap(100, 200, Bitmap.Config.ARGB_8888);

        //在原图的基础上进行裁剪，起点，以及新的位图的宽高
        Bitmap bitmap3 = Bitmap.createBitmap(bitmap1, 20, 30, 50, 50);

        //先将原图通过矩阵进行变换，之后在进行裁剪,filter只有在matrix包含信息的时候才会用到
        Matrix matrix = new Matrix();
        matrix.setScale(2, 2);
        matrix.postRotate(180);
        Bitmap.createBitmap(bitmap1, 0, 0, 30, 30, matrix, true);


        //将位图缩放到这个尺寸，源码通过矩阵实现
        Bitmap.createScaledBitmap(bitmap1, 102, 300, true);

        //改变原位图的宽高以及色彩，生成新位图，不会产生新位图
        bitmap1.reconfigure(100, 200, Bitmap.Config.RGB_565);


        //将网络图转化为bitmap
        URL conurl = null;
        try {
            conurl = new URL(&quot;&quot;);
            HttpURLConnection con = (HttpURLConnection) conurl.openConnection();
            bitmap1 = BitmapFactory.decodeStream(con.getInputStream());
        } catch (Exception e) {
            e.printStackTrace();
        }


        //通过流获得图片以文件流的方式
        try {
            FileInputStream fis = new FileInputStream(&quot;/sdcard/test.png&quot;);
            Bitmap bitmap4 = BitmapFactory.decodeStream(fis);
        } catch (Exception e) {
        }


        BitmapDrawable bitmapDrawable = (BitmapDrawable) ContextCompat.getDrawable(context, R.mipmap.ic_launcher);
        Bitmap bitmap6 = bitmapDrawable.getBitmap();

        //以ResourceStream的方式，不用R文件
        Bitmap bitmap7 = BitmapFactory.decodeStream(getClass().getResourceAsStream(&quot;/res/drawable/test.png&quot;));

        //以文件流+R文件的方式
        @SuppressLint(&quot;ResourceType&quot;) InputStream in = context.getResources().openRawResource(R.mipmap.ic_launcher);
        Bitmap bitmap8 = BitmapFactory.decodeStream(in);

        try {
            InputStream issn = context.getResources().getAssets().open(&quot;ic&quot;);
            Bitmap imageBitmap4 = BitmapFactory.decodeStream(in);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }


    public void bitmapOtherApi() {

        //得到存储该位图所占用内存的大小
        int allocationByteCount = bitmap1.getAllocationByteCount();

        //返回存储该位图的像素字节数
        int byteCount = bitmap1.getByteCount();

        //判断是否回收
        boolean recycled = bitmap1.isRecycled();
        bitmap1.recycle();

        //比较两个位图是否相同
        boolean b = bitmap1.sameAs(bitmap1);

    }

    /**
     * 复制图片的方法
     */
    private void copyBitmap() {

        //复制图片，isMutable代表是否可以修改新位图像素
        Bitmap copy = bitmap1.copy(Bitmap.Config.RGB_565, false);


        //通过buffer流复制
        //设置缓冲大小，一般设置位图的大小
        Buffer buffer = ByteBuffer.allocate(bitmap1.getByteCount());
        //将图片信息复制到缓冲流中
        bitmap1.copyPixelsToBuffer(buffer);
        buffer.position(0);
        Bitmap bitmap = Bitmap.createBitmap(bitmap1.getWidth(), bitmap1.getHeight(), Bitmap.Config.ARGB_8888);
        //通过刘得到图片信息
        bitmap.copyPixelsFromBuffer(buffer);


        //创建新的位图，允许新的位图宽高大于之前的位图
        Canvas canvas = new Canvas(bitmap);
        canvas.drawBitmap(bitmap1, null, new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()), null);

    }

    /**
     * 设置压缩图片，CompressFormat设置为Bitmap.CompressFormat.PNG,无效
     */
    public void compressBitmap() {

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        bitmap1.compress(Bitmap.CompressFormat.JPEG, 100, byteArrayOutputStream);

    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>JS笔记-007-JS Window-cookie</title>
    <url>/2019/06/23/JS%E7%AC%94%E8%AE%B0-007-JS%20Window-cookie/</url>
    <content><![CDATA[<p>Window 对象</p>
<ul>
<li>所有浏览器都支持 window 对象。它表示浏览器窗口。</li>
<li>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</li>
<li>全局变量是 window 对象的属性。</li>
<li>全局函数是 window 对象的方法。</li>
<li>甚至 HTML DOM 的 document 也是 window 对象的属性之一<pre><code>window.document.getElementById(&quot;header&quot;);</code></pre>等同于<pre><code>document.getElementById(&quot;header&quot;);</code></pre><a id="more"></a>


</li>
</ul>
<h3 id="JS-cookie"><a href="#JS-cookie" class="headerlink" title="JS_cookie"></a>JS_cookie</h3><ul>
<li>cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。</li>
</ul>
<h5 id="有关cookie的例子："><a href="#有关cookie的例子：" class="headerlink" title="有关cookie的例子："></a>有关cookie的例子：</h5><h6 id="名字-cookie"><a href="#名字-cookie" class="headerlink" title="名字 cookie"></a>名字 cookie</h6><p>当访问者首次访问页面时，他或她也许会填写他/她们的名字。名字会存储于 cookie 中。当访问者再次访问网站时，他们会收到类似 “Welcome John Doe!” 的欢迎词。而名字则是从 cookie 中取回的。</p>
<h6 id="密码-cookie"><a href="#密码-cookie" class="headerlink" title="密码 cookie"></a>密码 cookie</h6><p>当访问者首次访问页面时，他或她也许会填写他/她们的密码。密码也可被存储于 cookie 中。当他们再次访问网站时，密码就会从 cookie 中取回。</p>
<h6 id="日期-cookie"><a href="#日期-cookie" class="headerlink" title="日期 cookie"></a>日期 cookie</h6><p>当访问者首次访问你的网站时，当前的日期可存储于 cookie 中。当他们再次访问网站时，他们会收到类似这样的一条消息：”Your last visit was on Tuesday August 11, 2005!”。日期也是从 cookie 中取回的。</p>
<h5 id="创建和存储-cookie"><a href="#创建和存储-cookie" class="headerlink" title="创建和存储 cookie"></a>创建和存储 cookie</h5><p>在这个例子中我们要创建一个存储访问者名字的 cookie。当访问者首次访问网站时，他们会被要求填写姓名。名字会存储于 cookie 中。当访问者再次访问网站时，他们就会收到欢迎词。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function getCookie(c_name)
{
if (document.cookie.length&gt;0)
{ 
c_start=document.cookie.indexOf(c_name + &quot;=&quot;)
if (c_start!=-1)
{ 
c_start=c_start + c_name.length+1 
c_end=document.cookie.indexOf(&quot;;&quot;,c_start)
if (c_end==-1) c_end=document.cookie.length
return unescape(document.cookie.substring(c_start,c_end))
} 
}
return &quot;&quot;
}

function setCookie(c_name,value,expiredays)
{
var exdate=new Date()
exdate.setDate(exdate.getDate()+expiredays)
document.cookie=c_name+ &quot;=&quot; +escape(value)+
((expiredays==null) ? &quot;&quot; : &quot;; expires=&quot;+exdate.toGMTString())
}

function checkCookie()
{
username=getCookie(&#39;username&#39;)
if (username!=null &amp;&amp; username!=&quot;&quot;)
  {alert(&#39;Welcome again &#39;+username+&#39;!&#39;)}
else 
  {
  username=prompt(&#39;Please enter your name:&#39;,&quot;&quot;)
  if (username!=null &amp;&amp; username!=&quot;&quot;)
    {
    setCookie(&#39;username&#39;,username,365)
    }
  }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onLoad=&quot;checkCookie()&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
  </entry>
  <entry>
    <title>MVVM--之Lifecycle的使用</title>
    <url>/2019/06/23/MVVM--%E4%B9%8BLifecycle%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>通过lifecycle来控制生命周期相对来说会少写很多无用代码，例如可以在viewModel中控制一些需要在生命周期中使用的注册的方法等，因为按照传统方法，如果想要在viewModel中实现声明周期方法等，必须在avtivity或者fragment中进行viewModel相对应的方法进行回调等</p>
<h3 id="使用Lifecycle的三种方式"><a href="#使用Lifecycle的三种方式" class="headerlink" title="使用Lifecycle的三种方式"></a>使用Lifecycle的三种方式</h3><h4 id="1-直接实现LifecycleObserver接口，然后手动进行对应周期的方法注册（通过注解）"><a href="#1-直接实现LifecycleObserver接口，然后手动进行对应周期的方法注册（通过注解）" class="headerlink" title="1. 直接实现LifecycleObserver接口，然后手动进行对应周期的方法注册（通过注解）"></a>1. 直接实现LifecycleObserver接口，然后手动进行对应周期的方法注册（通过注解）</h4><pre><code>/**
 * lifeCycle的使用，之后可以让ViewModel使用该发方法，以便使用生命周期的方法
 *
 * lifecycle可以将lifecycleOwner对应的生命周期时间传递给内部的Lifecycle对象去处理，
 * 于是生命周期的改变就可以被lifecycle所注册的观察者LifecycleObserver观察到并触发其对应的事件
 *
 * @author alguojian
 * @date 2019/1/29
 */
class MyLifecycleObserver : LifecycleObserver {

    /**
     * 通过lifecycle的注解注入，将activity的生命周期同步与该方法
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    fun onCreate() {
        println(&quot;lifecycle的onCreate方法&quot;)
    }


    /**
     * 可以接受参数，第一个参数必须是LifecycleOwner
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    fun onPause(owner: LifecycleOwner) {
        println(&quot;lifecycle的ON_PAUSE方法&quot;)
    }


    /**
     * 使用any可以接受两个参数，第一个参数必须是LifecycleOwner，第二个是Lifecycle.Event)
     */
    @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
    fun onAny(owner: LifecycleOwner, event: Lifecycle.Event) {
        println(&quot;lifecycle的ON_ANY方法&quot;)
    }
}</code></pre><a id="more"></a>

<h4 id="2-实现GenericLifecycleObserver接口，实现回调方法onStateChanged"><a href="#2-实现GenericLifecycleObserver接口，实现回调方法onStateChanged" class="headerlink" title="2.实现GenericLifecycleObserver接口，实现回调方法onStateChanged"></a>2.实现GenericLifecycleObserver接口，实现回调方法onStateChanged</h4><pre><code>/**
 * 使用lifecycle的第二种方法为 直接继承GenericLifecycleObserver
 *
 * @author alguojian
 * @date 2019/1/29
 */
class MyLifecycleObserverTwo : GenericLifecycleObserver {
    override fun onStateChanged(source: LifecycleOwner?, event: Lifecycle.Event?) {
        when (event) {
            Lifecycle.Event.ON_CREATE -&gt; {
                println(&quot;使用lifecycle的第二种方法为 直接继承GenericLifecycleObserver&quot;)
            }
            Lifecycle.Event.ON_START -&gt; {
            }
            Lifecycle.Event.ON_DESTROY -&gt; {
            }
            else -&gt; {
            }
        }
    }
}</code></pre><h4 id="3-实现接口DefaultLifecycleObserver，直接重写对应的声明周期的方法（推荐使用）"><a href="#3-实现接口DefaultLifecycleObserver，直接重写对应的声明周期的方法（推荐使用）" class="headerlink" title="3.实现接口DefaultLifecycleObserver，直接重写对应的声明周期的方法（推荐使用）"></a>3.实现接口DefaultLifecycleObserver，直接重写对应的声明周期的方法（推荐使用）</h4><blockquote>
<p>注意：该方法使用java8，并且需要添加依赖   <code>implementation &#39;android.arch.lifecycle:common-java8:1.1.1&#39;</code></p>
</blockquote>
<pre><code>/**
 * 使用lifecycle的第三种方法为 直接实现DefaultLifecycleObserver
 *
 * 使用该方法需要添加依赖：implementation &#39;android.arch.lifecycle:common-java8:1.1.1&#39;
 *
 * 使用java8，该方法作为优先选择，因为不需要再写其他注解等，，，，ø
 *
 * @author alguojian
 * @date 2019/1/29
 */
class MyLifecycleObserverThree : DefaultLifecycleObserver {

    override fun onCreate(@NonNull owner: LifecycleOwner) {
        println(&quot;使用lifecycle的第三种方法为 直接实现DefaultLifecycleObserver&quot;)
    }
}</code></pre><h3 id="在activity或者fragment中使用："><a href="#在activity或者fragment中使用：" class="headerlink" title="在activity或者fragment中使用："></a>在activity或者fragment中使用：</h3><pre><code>  //activity
  lifecycle.addObserver(MyLifecycleObserver())


    /**
     * fragment中使用需要在构造方法中进行注册
     */
    init {
        lifecycle.addObserver(MyLifecycleObserverThree())
    }</code></pre><p>activity和fragment持有LifecycleOwner的对象，通过getLifecycle()获得Lifecycle对象，实际获得的是Lifecycle的一个实现类LifecycleRegistry，通过addObserver()方法添加我们的观察者，LifecycleObserver</p>
]]></content>
  </entry>
  <entry>
    <title>自定义view的Canvas梳理</title>
    <url>/2019/06/23/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84Canvas%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h3 id="创建Canvas的方式"><a href="#创建Canvas的方式" class="headerlink" title="创建Canvas的方式"></a>创建Canvas的方式</h3><pre><code>        Bitmap bitmap = Bitmap.createBitmap(500, 500,   Bitmap.Config.ARGB_8888);
        Canvas canvas1 = new Canvas();
        Canvas canvas2 = new Canvas(bitmap);


        //使用于绘制高质量图形，刷新频率高，但是系统花销比较大
        SurfaceView surfaceView = new SurfaceView(context);
        SurfaceHolder holder = surfaceView.getHolder();
        Canvas canvas = holder.lockCanvas();
        holder.unlockCanvasAndPost(canvas);</code></pre><a id="more"></a>


<h3 id="基本绘制方法"><a href="#基本绘制方法" class="headerlink" title="基本绘制方法"></a>基本绘制方法</h3><pre><code>
        //绘制图片
        drawable.draw(Canvas canvas)

        //绘制颜色
        canvas.drawColor(Color.BLUE);
        canvas.drawColor(Color.BLUE, PorterDuff.Mode.SRC_IN);


        //绘制点
        canvas.drawPoint(300, 300, paint);
        //绘制多个点
        canvas.drawPoints(new float[]{299, 399, 123, 234, 123, 567}, paint);

        //绘制直线
        canvas.drawLine(100, 200, 400, 500, paint);
        //绘制多条直线
        canvas.drawLines(new float[]{100, 200, 400, 500, 400, 200, 800, 20}, paint);

        //绘制矩形
        Rect rect = new Rect(100, 100, 500, 500);
        canvas.drawRect(rect, paint);

        //与rect的区别,Rect = int , RectF = float
        RectF rectF = new RectF(100, 100, 600, 800);
        canvas.drawRect(rectF, paint);

        //绘制圆角矩形，50代表着圆角对应的椭圆半径
        canvas.drawRoundRect(rectF, 50, 50, paint);

        //绘制椭圆，椭圆半径就是矩形的宽高一半
        canvas.drawOval(rectF, paint);

        //绘制圆形
        canvas.drawCircle(500, 500, 300, paint);

        //绘制圆弧，开始角度，扫过得角度，是否使用中心点，使用的话绘制的就是弧线以及中心点连接形成的图案，不适用就是弧线起点以及终点连接的图案
        canvas.drawArc(rectF, 15, 180, true, paint);

        //绘制文字,起始点默认为文本的左下角

        String string = &quot;请问饿哦草我啊是多空我看&quot;;
        canvas.drawText(string, 200, 300, paint);

        //指定绘制文本字体开始以及结束索引
        canvas.drawText(string, 2, 6, 300, 400, paint);

        //指定开始索引，以及绘制的长度
        char[] chars = string.toCharArray();
        canvas.drawText(chars, 1, 5, 300, 300, paint);

        //指定每一个字的坐标点，切记是每一个字，文本过长可能造成卡顿，不用包含表情
        canvas.drawPosText(string, new float[]{10, 20, 100, 200, 200, 200}, paint);

        //在path路径上绘制文字，与路径起始点的水平偏移距离，与路径中心的垂直偏移距离
        canvas.drawTextOnPath(string, new Path(), 50, 0, paint);

        //绘制位图，图片左上角为绘制原点

        //获得图片资源从drawable等
        Bitmap bitmap = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.ic_launcher_foreground);

        //从assets获得图片
        try {
            InputStream open = mContext.getAssets().open(&quot;aaa.png&quot;);

            Bitmap bitmap1 = BitmapFactory.decodeStream(open);
            open.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        //从内存卡获得图片
        Bitmap bitmap1 = BitmapFactory.decodeFile(&quot;/sdcard/aaa.png&quot;);

        //matrix用于绘制是对图片进行一下改变
        canvas.drawBitmap(bitmap, new Matrix(), paint);

        //指定绘制原点
        canvas.drawBitmap(bitmap, 300, 400, paint);


        //指定绘制区域
        Rect rect1 = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight());
        //指定图片要显示在那块区域
        Rect rect2 = new Rect(100, 200, 400, 500);
        canvas.drawBitmap(bitmap, rect1, rect2, paint);

        //向有一栋300px，向下移动400px
        canvas.translate(300,400);

        //设置缩放，以及缩放中心点，默认是原点
        canvas.scale(1.2f,0.8f,100,0);

        //已点（30，50）旋转90度，即与x轴角度增大90度，切记：屏幕坐标系与数学坐标系成镜像显示
        canvas.rotate(90,30,50);

        //向x轴正方向倾斜45度
        canvas.skew(1f,0);


        //画布裁剪，其他区域不在编辑
        canvas.clipPath(new Path());

        //指定裁剪叠加裁剪时的效果,有关Region.OP全部参数看下面
        canvas.clipPath(new Path(), Region.Op.XOR);

        //裁剪矩形
        canvas.clipRect(rect);

        //保存全部状态
        canvas.save();

        //获得保存次数
        canvas.getSaveCount();

        //回退上一次
        canvas.restore();

        //指定回退的版本
        canvas.restoreToCount(2);</code></pre><h3 id="Region-OP参数，和path的布尔值操作类似"><a href="#Region-OP参数，和path的布尔值操作类似" class="headerlink" title="Region.OP参数，和path的布尔值操作类似"></a>Region.OP参数，和path的布尔值操作类似</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DIFFERENCE</td>
<td>第一次不同于第二次区域</td>
</tr>
<tr>
<td>INTERSECT</td>
<td>二次交集</td>
</tr>
<tr>
<td>UNION</td>
<td>两次的合集</td>
</tr>
<tr>
<td>XOR</td>
<td>二者合集减去二者交集</td>
</tr>
<tr>
<td>REVERSE_DIFFERENCE</td>
<td>第二次不同于第一次区域</td>
</tr>
<tr>
<td>REPLACE</td>
<td>第二次全部区域</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>自定义view的画笔Paint的梳理</title>
    <url>/2019/05/23/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E7%94%BB%E7%AC%94Paint%E7%9A%84%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h3 id="画笔：确定绘制内容的具体效果"><a href="#画笔：确定绘制内容的具体效果" class="headerlink" title="画笔：确定绘制内容的具体效果"></a>画笔：确定绘制内容的具体效果</h3><p>4.0以上建议关闭硬件加速</p>
<pre><code>android:hardwareAccelerated=&quot;false&quot;</code></pre><a id="more"></a>


<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><pre><code> Paint mPaint = new Paint();

 mPaint.reset();//重置paint

 mPaint.setColor(Color.BLUE);

 mPaint.setStyle(Paint.Style.FILL);//只填充，不描边
 mPaint.setStyle(Paint.Style.STROKE);//只描边，不填充
 mPaint.setStyle(Paint.Style.FILL_AND_STROKE);//描边和填充

 mPaint.setStrokeWidth(1.2f);//设置画笔的粗细

 mPaint.setStrokeWidth(10f);//设置画笔宽度为10px

 mPaint.getColor();//获得画笔颜色

 mPaint.setShader(new Shader());//设置着色器，绘制多彩图案

 mPaint.setARGB(100, 100, 100, 100);//设置画笔颜色

 mPaint.setAlpha(30);//设置透明度
 mPaint.getAlpha();//获得画笔透明度

 mPaint.setTextSize(10);//设置字体大小10px

 mPaint.setTextAlign(Paint.Align.LEFT);//设置左对齐
 mPaint.setTextAlign(Paint.Align.CENTER);//设置中间对齐
 mPaint.setTextAlign(Paint.Align.RIGHT);//设置右对齐

 mPaint.setUnderlineText(true);//设置文本下划线

 mPaint.setStrikeThruText(true);//设置删除线

 mPaint.setFakeBoldText(true);//设置文本粗体

 mPaint.setTextSkewX(-0.5f);//设置斜体

 mPaint.setShadowLayer(5, 5, 5, Color.YELLOW);//设置文字阴影

 mPaint.setAntiAlias(true);//设置抗锯齿

 mPaint.setStrokeCap(Paint.Cap.ROUND);//这只末端仙帽为圆形，即在绘制的图形两端添加半圆形
 mPaint.setStrokeCap(Paint.Cap.BUTT);//默认无线帽
 mPaint.setStrokeCap(Paint.Cap.SQUARE);//这只末端仙帽为方形，即在绘制的图形两端添加半圆形

 mPaint.setStrokeJoin(Paint.Join.BEVEL);//设置线段连接处样式为直线
 mPaint.setStrokeJoin(Paint.Join.MITER);//设置线段连接处样式为锐角
 mPaint.setStrokeJoin(Paint.Join.ROUND);//圆角

 mPaint.setStrokeMiter(30f);//设置画笔的倾斜度，实际并没什么卵用

 mPaint.setPathEffect(new CornerPathEffect(100));//设置连接点为半径100px的圆形接入


 mPaint.setTextSkewX(-0.3f);//这是字体倾斜度，默认右方向倾斜为-0.25

 mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD));//设置多图案叠加方式
// case  0: return Mode.CLEAR;
// case  1: return Mode.SRC;
// case  2: return Mode.DST;
// case  3: return Mode.SRC_OVER;
// case  4: return Mode.DST_OVER;
// case  5: return Mode.SRC_IN;
// case  6: return Mode.DST_IN;
// case  7: return Mode.SRC_OUT;
// case  8: return Mode.DST_OUT;
// case  9: return Mode.SRC_ATOP;
// case 10: return Mode.DST_ATOP;
// case 11: return Mode.XOR;
// case 16: return Mode.DARKEN;
// case 17: return Mode.LIGHTEN;
// case 13: return Mode.MULTIPLY;
// case 14: return Mode.SCREEN;
// case 12: return Mode.ADD;
// case 15: return Mode.OVERLAY;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7426378-ab6f0a0c1e2b52bc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><pre><code>        String s = &quot;1231111111&quot;;

        float v = mPaint.measureText(s);//测量文本长度

        mPaint.measureText(s, 2, 5);//测量文本长度，开始以及结束的索引


        //通过外边距矩形获得内置文本宽高
        Rect rect = new Rect();
        mPaint.getTextBounds(s, 2, 6, rect);
        int width = rect.width();
        int height = rect.height();


        //获得精确字体宽度
        int arr = 0;
        int len = s.length();
        float[] floats = new float[len];
        mPaint.getTextWidths(s, floats);

        for (int i = 0; i &lt; len; i++) {
            arr += (int) Math.ceil(floats[i]);
        }
        int widthText = arr;</code></pre>]]></content>
  </entry>
  <entry>
    <title>自定义view的path常用api梳理</title>
    <url>/2019/04/23/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84path%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ul>
<li><p>reset()   清除掉path里面所有线条以及曲线，但不会改变他的fill-type，不保留原有数据结构</p>
</li>
<li><p>rewind()  清除path里面线条和曲线，保留内部数据结构以便复用,删除fill-type（一般选择reset()）</p>
</li>
<li><p>set(Path mPath) 用新path替换旧path</p>
</li>
<li><p>moveTo(float x,float y)  设置当前点位置，后面的绘制从该点开始，设置绘制起点</p>
</li>
<li><p>setLastPoint(300, 300) 设置上个点移动到该点处，以后从该点开始绘制</p>
</li>
<li><p>lineTo(float x,float y) 上次结束点连接改点，如果上次没有操作，则设置改点为绘制起点</p>
</li>
<li><p>close() 设置闭合路径，即连接最后一个点和第一个点，如果无法连接，则什么都不做</p>
</li>
</ul>
<a id="more"></a>


<h2 id="FILL-TYPE属性"><a href="#FILL-TYPE属性" class="headerlink" title="FILL_TYPE属性"></a>FILL_TYPE属性</h2><ul>
<li>WINDING 默认</li>
<li>EVEN_ODD 叠加的地方切割，颜色为默认白色</li>
<li>INVERSE_WINDING 全部为默认白色</li>
<li>INVERSE_EVEN_ODD 叠加的地方为绘制颜色，其他地方为默认白色</li>
</ul>
<p><strong>toggleInverseFillType()切换相反的填充模式</strong></p>
<h2 id="添加基本图形"><a href="#添加基本图形" class="headerlink" title="添加基本图形"></a>添加基本图形</h2><h4 id="添加圆弧"><a href="#添加圆弧" class="headerlink" title="添加圆弧,"></a>添加圆弧,</h4><pre><code>startAngle,确定角度起始位置
sweepAngle，确定扫过的角度
public void addArc(Rectf ovel ,float startAngle,float sweepAngle)</code></pre><h4 id="添加圆弧，与上面方法唯一不同的是：如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点"><a href="#添加圆弧，与上面方法唯一不同的是：如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点" class="headerlink" title="添加圆弧，与上面方法唯一不同的是：如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点"></a>添加圆弧，与上面方法唯一不同的是：如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点</h4><pre><code>public void arcTo (RectF oval, float startAngle, float sweepAngle)</code></pre><h4 id="添加圆弧，是否将之前路径的结束点设置为圆弧起点"><a href="#添加圆弧，是否将之前路径的结束点设置为圆弧起点" class="headerlink" title="添加圆弧，是否将之前路径的结束点设置为圆弧起点"></a>添加圆弧，是否将之前路径的结束点设置为圆弧起点</h4><p>true,在新的起点画圆弧，不连接最后一个点与圆弧起点，即与之前路径没有交集（同addArc()）<br>false,在新的起点画圆弧，连接之前路径的结束点与圆弧起点，即与之前路径有交集，（同arcTo(三参数)）</p>
<pre><code>public void arcTi(RectF oval, float startAngle, float sweepAngle,boolean forcemoveTo)</code></pre><h4 id="添加圆形，添加之后下次路径起点变为圆在X轴正方向最大的点"><a href="#添加圆形，添加之后下次路径起点变为圆在X轴正方向最大的点" class="headerlink" title="添加圆形，添加之后下次路径起点变为圆在X轴正方向最大的点"></a>添加圆形，添加之后下次路径起点变为圆在X轴正方向最大的点</h4><p>起点 x轴正方向的0度<br>坐标点<br>半径<br>dir，指定绘制时是顺时针还是逆时针，CW为顺时针，CCW为逆时针</p>
<pre><code>addCircle(float x ,float y, float radius ,Path.Direction dir)</code></pre><h4 id="添加椭圆形路径"><a href="#添加椭圆形路径" class="headerlink" title="添加椭圆形路径"></a>添加椭圆形路径</h4><p>oval,椭圆的外切矩形区域</p>
<pre><code>addOval(Rectf oval,Path.Direction dir)</code></pre><h4 id="加入矩形路径"><a href="#加入矩形路径" class="headerlink" title="加入矩形路径"></a>加入矩形路径</h4><p>路径起点变为矩形的左上角起点</p>
<pre><code>addRect(Rectf oval,Path.Direction dir)</code></pre><h4 id="加入圆角矩形路径"><a href="#加入圆角矩形路径" class="headerlink" title="加入圆角矩形路径"></a>加入圆角矩形路径</h4><p>添加圆形路径后会改变路径的起点</p>
<pre><code>addRoundRect(Rectf oval,float x,float y,Path.Direction dir)</code></pre><h4 id="添加新的path"><a href="#添加新的path" class="headerlink" title="添加新的path"></a>添加新的path</h4><p>将圆形路径移动到（dx,dy），再添加到新的path内部</p>
<pre><code> public void addPath(Path src, float dx, float dy)</code></pre><p>将mPath进行Matrix变换再添加到当前path</p>
<pre><code>public void addPath (Path mPath, Matrix matrix)</code></pre><h4 id="平移路径-与canvas的translate-类似"><a href="#平移路径-与canvas的translate-类似" class="headerlink" title="平移路径,与canvas的translate()类似"></a>平移路径,与canvas的translate()类似</h4><pre><code>path.offset(float x , float y);</code></pre><h4 id="设置新的path路径"><a href="#设置新的path路径" class="headerlink" title="设置新的path路径"></a>设置新的path路径</h4><pre><code>set(Path src)</code></pre><h2 id="有关布尔值操作"><a href="#有关布尔值操作" class="headerlink" title="有关布尔值操作"></a>有关布尔值操作</h2><ul>
<li>进行不同的path之间的运算</li>
<li>把简单的图形通过一定规则合成复杂的图形</li>
</ul>
<pre><code>对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定
运算结果存入到path1中。

boolean op (Path path, Path.Op op)
path1.op(path2, Path.Op.DIFFERENCE);


对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定
运算结果存入到path3中。

boolean op (Path path1, Path path2, Path.Op op)
path3.op(path1, path2, Path.Op.DIFFERENCE)</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DIFFERENCE</td>
<td>path1不同于path2的区域</td>
</tr>
<tr>
<td>REVERSE_DIFFERENCE</td>
<td>path2不同于path1的区域</td>
</tr>
<tr>
<td>INTERSECT</td>
<td>path1和path2的交集</td>
</tr>
<tr>
<td>UNION</td>
<td>path1和path2的并集</td>
</tr>
<tr>
<td>XOR</td>
<td>减去二者交集所剩下的</td>
</tr>
</tbody></table>
<h2 id="贝塞尔曲线，通过一个数据点以及多个控制点描述"><a href="#贝塞尔曲线，通过一个数据点以及多个控制点描述" class="headerlink" title="贝塞尔曲线，通过一个数据点以及多个控制点描述"></a>贝塞尔曲线，通过一个数据点以及多个控制点描述</h2><ul>
<li>数据点：值路径的起始点和终止点</li>
<li>控制点：决定路径的弯曲估计</li>
<li>n+1阶贝塞尔曲线=有n个控制点</li>
<li>1阶=一条直线</li>
</ul>
<h3 id="path方法如下："><a href="#path方法如下：" class="headerlink" title="path方法如下："></a>path方法如下：</h3><ul>
<li><p>绘制二阶贝塞尔曲线（x1,y1）为控制点，(x2,y2)为终点<br>quadTo(float x1,floaty1,float x2,float y2)</p>
</li>
<li><p>(x1,y1)为控制点距离起点的偏移量，(x2,y2)为终点距离起点的偏移量<br>rQuadTo(float x1, float y1, float x2, float y2)</p>
</li>
<li><p>绘制三阶贝塞尔曲线,(x1,y1),(x2,y2)为控制点，(x3,y3)为终点<br>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</p>
</li>
<li><p>(x1,y1)，(x2,y2)为控制点距离起点的偏移量，(x3,y3)为终点距离起点的偏移量<br>rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>自定义view测量onMeasure梳理</title>
    <url>/2019/03/29/%E8%87%AA%E5%AE%9A%E4%B9%89view%E6%B5%8B%E9%87%8FonMeasure%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h2 id="自定义view流程的第一步，测量"><a href="#自定义view流程的第一步，测量" class="headerlink" title="自定义view流程的第一步，测量"></a>自定义view流程的第一步，测量</h2><blockquote>
<p><strong>onMeasure(),测量自己的大小，为正式布局提供建议（只是建议，用不用还要看onlayout()</strong></p>
</blockquote>
<p>测量过程通过measure方法实现，是View树的自顶向下的一次遍历，每个View在循环过程中将自己的尺寸向下传递，测量完成后所有的view都清楚自己的尺寸，</p>
<p>通过<code>setMeasuredDimension(width, height);</code>设置给系统</p>
<a id="more"></a>


<p>获取当前view的位置有</p>
<pre><code>
// 获取Top位置
public final int getTop() {  
    return mTop;  
}  

// 其余如下：
  getLeft();      //获取子View左上角距父View左侧的距离
  getBottom();    //获取子View右下角距父View顶部的距离
  getRight();     //获取子View右下角距父View左侧的距离
</code></pre><p>与MotionEvent中 get()和getRaw()的区别</p>
<pre><code>view自身中心点为坐标原点
//get() ：触摸点相对于其所在组件坐标系的坐标
 event.getX();       
 event.getY();

//getRaw() ：触摸点相对于屏幕默认坐标系的坐标
 event.getRawX();    
 event.getRawY();</code></pre><p> 有关measure过程</p>
<p> 测量规格（MeasureSpec） = 测量模式（mode） + 测量大小（size）</p>
<p> 测量模式有三种：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>具体秒速</th>
<th>应用场景</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>UNSPECIFIED</td>
<td>父视图不约束子视图，即view可取任意尺寸</td>
<td>系统内部recyclerview等</td>
<td></td>
</tr>
<tr>
<td>EXACTLY</td>
<td>- 父视图为子视图制定一个确切尺寸</td>
<td>match_parent或者100dp</td>
<td>利用父View的剩余空间</td>
</tr>
<tr>
<td>AT_MOST</td>
<td>父视图为子视图制定一个最大尺寸，子视图必须确保自身可适应在其内部</td>
<td>wrap_content</td>
<td>将大小设置为包裹view的内容</td>
</tr>
</tbody></table>
<p>使用如下：</p>
<pre><code>    // 1. 获取测量模式（Mode）
    int specMode = MeasureSpec.getMode(measureSpec)

    // 2. 获取测量大小（Size）
    int specSize = MeasureSpec.getSize(measureSpec)

    // 3. 通过Mode 和 Size 生成新的SpecMode
    int measureSpec=MeasureSpec.makeMeasureSpec(size, mode);

    //设置测量的宽高值
    setMeasuredDimension(width, height);</code></pre><p>下面是一个viewGroup中的测量：</p>
<pre><code>    /**
     * 测量子view
     *
     * @param widthMeasureSpec
     * @param heightMeasureSpec
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        //每一行的高度
        int lineWidth = 0;

        //每一行的高度
        int lineHeight = 0;

        //整个viewGroup的宽度
        int allWidth = 0;

        //整个viewGroup的高度
        int allHeight = 0;

        //获得系统的建议宽高
        int width = MeasureSpec.getSize(widthMeasureSpec);
        int height = MeasureSpec.getSize(heightMeasureSpec);

        //获得控件的宽高模式
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);


        //获得子view的数量
        int count = getChildCount();

        //遍历测量子view
        for (int i = 0; i &lt; count; i++) {

            //获得子view对象
            View childAt = getChildAt(i);

            //测量子view，通过自view对象以及父view的测量参数
            measureChild(childAt, widthMeasureSpec, heightMeasureSpec);

            //获得子view的margin的layoutParams来获得子view的四周间距，兼容自定义viewGroup设置了margin
            MarginLayoutParams layoutParams = (MarginLayoutParams) childAt.getLayoutParams();

            //获得子view测量的宽度
            int childWidth = childAt.getMeasuredWidth() + layoutParams.leftMargin + layoutParams.rightMargin;

            //获得子view测量的高度
            int childHeight = childAt.getMeasuredHeight() + layoutParams.topMargin + layoutParams.bottomMargin;


            //如果现在的宽度加上一个字view的宽度大于整个viewGroup的宽度，那么就需要换行显示
            if (lineWidth + childWidth &gt; width) {

                //换行后，刷新viewGroup的宽度，记录一个最大值
                allWidth = Math.max(lineWidth, childWidth);

                //记录viewGroup的高度
                allHeight += lineHeight;

                lineWidth = childWidth;
                lineHeight = childHeight;

            } else {
                lineHeight = Math.max(lineHeight, childHeight);
                lineWidth += childWidth;
            }


            //当时最后一行的时候，就不会换行，所以需要手动加上最后一行的高度
            if (i == count - 1) {

                allHeight += lineHeight;

                //获得最大的宽度，比较值钱宽度的最大值，以及当前行的宽度值
                allWidth = Math.max(lineWidth, allWidth);
            }

        }
        setMeasuredDimension(widthMode == MeasureSpec.EXACTLY ? width : allWidth, heightMode == MeasureSpec.EXACTLY ? height : allHeight);

    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>自定义behavior</title>
    <url>/2019/03/28/%E8%87%AA%E5%AE%9A%E4%B9%89behavior/</url>
    <content><![CDATA[<p>Behavior是CoordinatorLayout的一个抽象内部类</p>
<pre><code>public abstract static class Behavior&lt;V extends View&gt; {
      public Behavior() {
      }

      public Behavior(Context context, AttributeSet attrs) {
      }
      ...
}</code></pre><a id="more"></a>


<p>泛型对应的就是监听的view</p>
<p>自定义behavior有两种情况</p>
<blockquote>
<p>1.某个view监听另一个view的状态变化，例如大小、位置、显示状态等</p>
<blockquote>
<ul>
<li>layoutDependsOn  方法</li>
<li>onDependentViewChanged  方法</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>2.某个view监听CoordinatorLayout里的滑动状态</p>
<blockquote>
<ul>
<li>onStartNestedScroll    方法</li>
<li>onNestedPreScroll 方法</li>
</ul>
</blockquote>
</blockquote>
<p>下面定义一个behavior ，实现一个view监控另一个view实现滑动</p>
<pre><code>public class MyBehavior extends CoordinatorLayout.Behavior&lt;View&gt; {

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) {
        return super.layoutDependsOn(parent, child, dependency);
    }

    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) {
        ViewCompat.offsetLeftAndRight();
        return super.onDependentViewChanged(parent, child, dependency);
    }
}</code></pre><p>带有两个参数的这个构造必须重载，因为在CoordinatorLayout里利用反射去获取这个Behavior的时候就是拿的这个构造。重两个方法layoutDependsOn和onDependentViewChanged，这两个方法的参数都是一样的，第二个参数是我们设置这个Behavior的View，第三个是我们关心的那个View。如何知道关心的哪个呢？layoutDependsOn的返回值决定了一切！</p>
<p>比如一个TextView</p>
<pre><code>@Override
public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) {
    return dependency instanceof TextView;
}</code></pre><p>设置了关心谁，就是在该view状态发生变化时我们的view要做出一些变化</p>
<pre><code>@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) {
    child.setX(dependency.getX()+200);
    child.setY(dependency.getY()+200);
    child.setText(dependency.getX()+&quot;,&quot;+dependency.getY());
    return true;
}</code></pre><p>获取两个View的距离顶部值的差，然后让child的位置进行移动</p>
<p>那么xml我么可以这样写</p>
<pre><code>&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;Button
        android:onclick=&quot;click&quot;
        android:id=&quot;@+id/button&quot;
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;#57caa1&quot;
        android:gravity=&quot;center&quot;
        android:textColor=&quot;#fff&quot;
        android:layout_gravity=&quot;top|left&quot;
        android:text=&quot;啊哈&quot;/&gt;

    &lt;TextView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;#F26D7E&quot;
        android:gravity=&quot;center&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:layout_gravity=&quot;top|right&quot;
        app:layout_behavior=&quot;com.emplme.MytBehavior&quot;
        android:text=&quot;555666&quot;/&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><p>第二个textView就是我们的view设置了我们自定义的behavior</p>
<p>然后</p>
<pre><code>@Override protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    findViewById(R.id.button).setOnTouchListener(new View.OnTouchListener() {
      @Override public boolean onTouch(View v, MotionEvent event) {
        switch (event.getAction()){

          case MotionEvent.ACTION_MOVE:
            v.setX(event.getRawX()-v.getWidth()/2);
            v.setY(event.getRawY()-v.getHeight()/2);
            break;
        }
        return false;
      }
    });

  }
</code></pre><p>接下来第二种情况</p>
<pre><code>public class ScrollBehavior extends CoordinatorLayout.Behavior&lt;View&gt; {

    public ScrollBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) {
        return super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);
    }

    @Override
    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) {
        super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);
    }

    @Override
    public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY) {
        return super.onNestedPreFling(coordinatorLayout, child, target, velocityX, velocityY);
    }
}</code></pre><p>onStartNestedScroll返回值表示要不要关心CoordinatorLayout滑动，那个方向的</p>
<pre><code>@Override
public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) {
    return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;
}
当然我们这是Y轴方向的</code></pre><p>onNestedPreScroll关于滑动的处理</p>
<pre><code>@Override
public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) {
    super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);
    int leftScrolled = target.getScrollY();
    child.setScrollY(leftScrolled);
}</code></pre><p>列子如下：</p>
<pre><code>public class ScrollAwareFABBehavior extends CoordinatorLayout.Behavior&lt;View&gt; {

    private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator();
    private boolean mIsAnimatingOut = false;

    public ScrollAwareFABBehavior(Context context, AttributeSet attrs) {
        super();
    }


    @Override
    public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type) {
        return axes == ViewCompat.SCROLL_AXIS_VERTICAL;

    }

    @Override
    public void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) {
        super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type);

        if (dy&gt;0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) {
            animateOut(child);
        } else if (dy &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) {
            animateIn(child);
        }
    }

    private void animateOut(final View button) {

        ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer()
                .setListener(new ViewPropertyAnimatorListener() {
                    @Override
                    public void onAnimationStart(View view) {
                        ScrollAwareFABBehavior.this.mIsAnimatingOut = true;
                    }

                    @Override
                    public void onAnimationEnd(View view) {
                        ScrollAwareFABBehavior.this.mIsAnimatingOut = false;
                        view.setVisibility(View.INVISIBLE);
                    }

                    @Override
                    public void onAnimationCancel(View view) {
                        ScrollAwareFABBehavior.this.mIsAnimatingOut = false;
                    }
                }).start();
    }

    private void animateIn(View button) {
        button.setVisibility(View.VISIBLE);
        ViewCompat.animate(button).translationY(0)
                .setInterpolator(INTERPOLATOR).withLayer().setListener(null)
                .start();
    }

    private int getMarginBottom(View v) {
        int marginBottom = 0;
        final ViewGroup.LayoutParams layoutParams = v.getLayoutParams();
        if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
            marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin;
        }
        return marginBottom;
    }

}

</code></pre><p>结尾在放上一些自定义behavior的炫酷效果</p>
<blockquote>
<p> <a href="http://androidwing.net/index.php/70" target="_blank" rel="noopener">CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你撸三款</a><br> <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0717/3196.html" target="_blank" rel="noopener">CoordinatorLayout与滚动的处理–基础</a><br> <a href="http://blog.csdn.net/tiankong1206/article/details/48394393" target="_blank" rel="noopener">自定义CoordinatorLayout的Behavior实现知乎和简书快速返回效果</a><br> <a href="http://blog.csdn.net/qibin0506/article/details/50290421" target="_blank" rel="noopener"> CoordinatorLayout高级用法-自定义Behavior</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>android使用jenkins进行自动化打包并且上传到fir或者蒲公英</title>
    <url>/2019/03/24/android%E4%BD%BF%E7%94%A8jenkins%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E5%B9%B6%E4%B8%94%E4%B8%8A%E4%BC%A0%E5%88%B0fir%E6%88%96%E8%80%85%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
    <content><![CDATA[<h3 id="android使用jenkins进行自动化打包"><a href="#android使用jenkins进行自动化打包" class="headerlink" title="android使用jenkins进行自动化打包"></a>android使用jenkins进行自动化打包</h3><p>首先需要配置jdk，gradle，以及android sdk环境变量，默认这些都是可以的，下载jenkins的war包，mac可以直接使用homebrew安装</p>
<p>windows下打开jenkins</p>
<pre><code>open /Applications/Jenkins/jenkins.war</code></pre><a id="more"></a>


<p>mac下<br>安装homebrew</p>
<pre><code>$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>安装jenkins</p>
<pre><code>$ brew install jenkins    </code></pre><p>启动jenkins</p>
<pre><code>$ jenkins</code></pre><p>启动之后可以直接访问jenkins网址，默认端口8080/因为世界就是本地的tomcat服务器</p>
<pre><code> http://localhost:8080/</code></pre><p>如果端口冲突，修改如下：xxxx就是端口号</p>
<pre><code>defaults write /Library/Preferences/org.jenkins-ci httpPort xxxx</code></pre><p>打开之后建议选择自定义安装插件,例如：</p>
<blockquote>
<p>git plugin 、github plugin、gitlab plugin、fir.im、svn plugin等</p>
</blockquote>
<p>然后在系统管理-全局工具配置里面，配置一些环境变量<br><img src="http://upload-images.jianshu.io/upload_images/7426378-5357e6799d0c8d21.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jdk以及git环境变量"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-7fb423c1f314c609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle环境变量"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-01ba2a822286aae3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android_sdk环境变量"></p>
<p>接下来创建一个jenkins任务，风格随意选择，然后进入任务选择配置</p>
<p>首先配置工程目录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-95fb00890d178491.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>在配置源码管理，点击add添加一个github的连接</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-fcf9cb0b3802a517.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-535d6f6d52212dbd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>构建环境选择 invoke gradle script</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-4d80f8b57157921d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>构建之后，上传到fir.im上用于测试</p>
<p>首先需要添加fir.im插件具体可以查看这里<a href="http://blog.fir.im/jenkins/" target="_blank" rel="noopener">fir.im Jenkins 插件使用方法</a>，添加之后在配置里面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-ed500b5945d08db8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>到此就全部配置完成，点击立即构建，开始进行自动化打包测试吧！</p>
]]></content>
  </entry>
  <entry>
    <title>webview全屏播放视频之后加载弹框失败</title>
    <url>/2019/03/23/webview%E5%85%A8%E5%B1%8F%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E4%B9%8B%E5%90%8E%E5%8A%A0%E8%BD%BD%E5%BC%B9%E6%A1%86%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>webview播放视频之后，js弹框弹出失败，实际屏幕是暗色的，说明弹框已经弹出，怀疑是x5内核自己实现的全屏出现冲突，所以改为自己实现全屏播放处理</p>
<p>播放视频建议使用腾讯x5内核</p>
<pre><code> /**
     * 视频全屏参数
     */
    protected static final FrameLayout.LayoutParams COVER_SCREEN_PARAMS = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
    private Context mContext;
    private WebView mWebView;
    private LoadingDialog mLoadingDialog;
    private boolean mShowLoading = true;
    private IWebView.OnErrorListener mOnErrorListener;
    private OnPageListener mOnPageListener;
    private View customView;
    private FrameLayout fullscreenContainer;
    private IX5WebChromeClient.CustomViewCallback mCustomViewCallback;
    private FrameLayout mRoot;</code></pre><a id="more"></a>


<pre><code>添加监听
 wv.setWebChromeClient(new WebChromeClient() {

             //消失全屏时自己处理
            @Override
            public void onHideCustomView() {

                KLog.d(Constant.TTAG, &quot;处理全屏&quot;);
                if (customView == null) {
                    return;
                }
                KLog.d(Constant.TTAG, &quot;处理全屏&quot;);
                FrameLayout decor = (FrameLayout) ((Activity) mContext).getWindow().getDecorView();

                if (fullscreenContainer != null) {
                    fullscreenContainer.removeAllViews();
                    decor.removeView(fullscreenContainer);
                }
                fullscreenContainer = null;
                customView = null;
                mCustomViewCallback.onCustomViewHidden();
                wv.setVisibility(View.VISIBLE);
            }

            //点击全屏时自己处理
            @Override
            public void onShowCustomView(View view, IX5WebChromeClient.CustomViewCallback customViewCallback) {

                KLog.d(Constant.TTAG, &quot;处理全屏&quot;);

                if (customView != null) {
                    customViewCallback.onCustomViewHidden();
                    return;
                }

                FrameLayout decor = (FrameLayout) ((Activity) mContext).getWindow().getDecorView();
                fullscreenContainer = new FullscreenHolder(mContext);
                fullscreenContainer.addView(view, COVER_SCREEN_PARAMS);
                decor.addView(fullscreenContainer, COVER_SCREEN_PARAMS);
                customView = view;
                mCustomViewCallback = customViewCallback;
            }
        });</code></pre>]]></content>
  </entry>
  <entry>
    <title>JS笔记-006-JS对象-数字-字符串-日期-数组-逻辑</title>
    <url>/2019/03/21/JS%E7%AC%94%E8%AE%B0-006-JS%E5%AF%B9%E8%B1%A1-%E6%95%B0%E5%AD%97-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%97%A5%E6%9C%9F-%E6%95%B0%E7%BB%84-%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h3 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h3><h5 id="创建-JavaScript-对象"><a href="#创建-JavaScript-对象" class="headerlink" title="创建 JavaScript 对象"></a>创建 JavaScript 对象</h5><p>通过 JavaScript，您能够定义并创建自己的对象。</p>
<p>创建新对象有两种不同的方法：</p>
<ul>
<li><p>定义并创建对象的实例(直接创建对象)</p>
<pre><code>person=new Object();
person.firstname=&quot;Bill&quot;;
person.lastname=&quot;Gates&quot;;
person.age=56;
person.eyecolor=&quot;blue&quot;;</code></pre><a id="more"></a>
</li>
<li><p>使用函数来定义对象，然后创建新的对象实例，类似于构造方法</p>
<pre><code>person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,age:50,eyecolor:&quot;blue&quot;};</code></pre></li>
<li><p>使用构造器创建对象，和java类似了，直接创建对象，赋值调用封装方法</p>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;script&gt;
function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}

myFather=new person(&quot;Bill&quot;,&quot;Gates&quot;,56,&quot;blue&quot;);

document.write(myFather.firstname + &quot; is &quot; + myFather.age + &quot; years old.&quot;);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="把属性添加到-JavaScript-对象"><a href="#把属性添加到-JavaScript-对象" class="headerlink" title="把属性添加到 JavaScript 对象"></a>把属性添加到 JavaScript 对象</h5><p>您可以通过为对象赋值，向已有对象添加新属性：假设 personObj 已存在 - 您可以为其添加这些新属性：firstname、lastname、age 以及 eyecolor：</p>
<pre><code>person.firstname=&quot;Bill&quot;;
person.lastname=&quot;Gates&quot;;
person.age=56;
person.eyecolor=&quot;blue&quot;;

x=person.firstname;</code></pre><h5 id="把方法添加到-JavaScript-对象"><a href="#把方法添加到-JavaScript-对象" class="headerlink" title="把方法添加到 JavaScript 对象"></a>把方法添加到 JavaScript 对象</h5><p>方法只不过是附加在对象上的函数。<br>在构造器函数内部定义对象的方法：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;

this.changeName=changeName;
function changeName(name)
{
this.lastname=name;
}
}
myMother=new person(&quot;Steve&quot;,&quot;Jobs&quot;,56,&quot;green&quot;);
myMother.changeName(&quot;Ballmer&quot;);
document.write(myMother.lastname);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="JS数字"><a href="#JS数字" class="headerlink" title="JS数字"></a>JS数字</h3><h4 id="JavaScript-Number-对象"><a href="#JavaScript-Number-对象" class="headerlink" title="JavaScript Number 对象"></a>JavaScript Number 对象</h4><p>JavaScript 只有一种数字类型。可以使用也可以不使用小数点来书写数字。<br>极大或极小的数字可通过科学（指数）计数法来写：</p>
<pre><code>var y=123e5;    // 12300000
var z=123e-5;   // 0.00123</code></pre><p><strong>所有 JavaScript 数字均为 64 位</strong></p>
<p>JavaScript 不是类型语言。与许多其他编程语言不同，JavaScript 不定义不同类型的数字，比如整数、短、长、浮点等等。<br>JavaScript 中的所有数字都存储为根为 10 的 64 位（8 比特），浮点数。</p>
<h3 id="JS字符串属性"><a href="#JS字符串属性" class="headerlink" title="JS字符串属性"></a>JS字符串属性</h3><p>转大写<br><code>txt.toUpperCase()</code></p>
<p>更改样式</p>
<pre><code>&lt;html&gt;
&lt;body&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

var txt=&quot;Hello World!&quot;

document.write(&quot;&lt;p&gt;Big: &quot; + txt.big() + &quot;&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Small: &quot; + txt.small() + &quot;&lt;/p&gt;&quot;)

document.write(&quot;&lt;p&gt;Bold: &quot; + txt.bold() + &quot;&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Italic: &quot; + txt.italics() + &quot;&lt;/p&gt;&quot;)

document.write(&quot;&lt;p&gt;Blink: &quot; + txt.blink() + &quot; (does not work in IE)&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Fixed: &quot; + txt.fixed() + &quot;&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Strike: &quot; + txt.strike() + &quot;&lt;/p&gt;&quot;)

document.write(&quot;&lt;p&gt;Fontcolor: &quot; + txt.fontcolor(&quot;Red&quot;) + &quot;&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Fontsize: &quot; + txt.fontsize(16) + &quot;&lt;/p&gt;&quot;)

document.write(&quot;&lt;p&gt;Lowercase: &quot; + txt.toLowerCase() + &quot;&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Uppercase: &quot; + txt.toUpperCase() + &quot;&lt;/p&gt;&quot;)

document.write(&quot;&lt;p&gt;Subscript: &quot; + txt.sub() + &quot;&lt;/p&gt;&quot;)
document.write(&quot;&lt;p&gt;Superscript: &quot; + txt.sup() + &quot;&lt;/p&gt;&quot;)

document.write(&quot;&lt;p&gt;Link: &quot; + txt.link(&quot;http://www.w3school.com.cn&quot;) + &quot;&lt;/p&gt;&quot;)
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="JS日期"><a href="#JS日期" class="headerlink" title="JS日期"></a>JS日期</h3><ul>
<li>返回当前日期<pre><code>&lt;html&gt;
&lt;body&gt;
</code></pre></li>
</ul>
<script type="text/javascript">

document.write(Date())

</script>




<pre><code>- getTime()，返回从 1970 年 1 月 1 日至今的毫秒数。</code></pre><html>
<body>

<script type="text/javascript">
var d=new Date();
document.write("从 1970/01/01 至今已过去 " + d.getTime() + " 毫秒");
</script>

</body>
</html>

<pre><code>- setFullYear()，如何使用 setFullYear() 设置具体的日期。</code></pre><html>
<body>

<script type="text/javascript">

var d = new Date()
d.setFullYear(1992,10,3)
document.write(d)

</script>

</body>
</html>

<pre><code>-  toUTCString()，使用 toUTCString() 将当日的日期（根据 UTC）转换为字符串。</code></pre><html>
<body>

<script type="text/javascript">

var d = new Date()
document.write (d.toUTCString())

</script>

</body>
</html>

<pre><code>- getDay()，使用 getDay() 和数组来显示星期，而不仅仅是数字</code></pre><html>
<body>

<script type="text/javascript">

var d=new Date()
var weekday=new Array(7)
weekday[0]="星期日"
weekday[1]="星期一"
weekday[2]="星期二"
weekday[3]="星期三"
weekday[4]="星期四"
weekday[5]="星期五"
weekday[6]="星期六"

document.write("今天是" + weekday[d.getDay()])

</script>

</body>
</html>

<pre><code>- 显示一个钟表</code></pre><html>
<head><meta name="generator" content="Hexo 3.9.0">
<script type="text/javascript">
function startTime()
{
var today=new Date()
var h=today.getHours()
var m=today.getMinutes()
var s=today.getSeconds()
// add a zero in front of numbers<10
m=checkTime(m)
s=checkTime(s)
document.getElementById('txt').innerHTML=h+":"+m+":"+s
t=setTimeout('startTime()',500)
}

<p>function checkTime(i)<br>{<br>if (i&lt;10)<br>  {i=”0” + i}<br>  return i<br>}<br></script><p></p>
</head>

<body onload="startTime()">
<div id="txt"></div>
</body>
</html>

<pre><code>##### 定义日期</code></pre><p>var myDate=new Date() </p>
<pre><code>
### JS数组

##### 创建数组</code></pre><html>
<body>

<script type="text/javascript">
var mycars = new Array()
mycars[0] = "Saab"
mycars[1] = "Volvo"
mycars[2] = "BMW"

for (i=0;i<mycars.length;i++)
{
document.write(mycars[i] + "<br />")
}
</script>

</body>
</html>

<pre><code>
##### For...In循环数组</code></pre><html>
<body>
<script type="text/javascript">
var x
var mycars = new Array()
mycars[0] = "Saab"
mycars[1] = "Volvo"
mycars[2] = "BMW"

<p>for (x in mycars)<br>{<br>document.write(mycars[x] + “<br />“)<br>}<br></script><p></p>
</body>
</html>
```
##### 合并数组，arr.concat(arr2)
```
<html>
<body>

<script type="text/javascript">

var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"

var arr2 = new Array(3)
arr2[0] = "James"
arr2[1] = "Adrew"
arr2[2] = "Martin"

document.write(arr.concat(arr2))

</script>

</body>
</html>

<pre><code>##### 将数组元素组成一个字符串，join</code></pre><html>
<body>

<script type="text/javascript">

var arr = new Array(3);
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"

document.write(arr.join());

document.write("<br />");

document.write(arr.join("."));

</script>

</body>
</html>

<pre><code>
#####  sort() 方法从字面上对数组进行排序，自然排序（数字可以针对大小排序）
</code></pre><html>
<body>

<script type="text/javascript">

var arr = new Array(6)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"
arr[3] = "James"
arr[4] = "Adrew"
arr[5] = "Martin"

document.write(arr + "<br />")
document.write(arr.sort())

</script>

</body>
</html>

<pre><code>
### JS逻辑（Boolean对象）
您可以将 Boolean 对象理解为一个产生逻辑值的对象包装器。
Boolean（逻辑）对象用于将非逻辑值转换为逻辑值（true 或者 false）。

创建Boolean对象</code></pre><p>var myBoolean=new Boolean()</p>
<pre><code>如果逻辑对象无初始值或者其值为 0、-0、null、&quot;&quot;、false、undefined 或者 NaN，那么对象的值为 false。否则，其值为 true（即使当自变量为字符串 &quot;false&quot; 时）！</code></pre><p>var myBoolean=new Boolean();<br>var myBoolean=new Boolean(0);<br>var myBoolean=new Boolean(null);<br>var myBoolean=new Boolean(“”);<br>var myBoolean=new Boolean(false);<br>var myBoolean=new Boolean(NaN);</p>
<pre><code>初始值全部为true</code></pre><p>var myBoolean=new Boolean(1);<br>var myBoolean=new Boolean(true);<br>var myBoolean=new Boolean(“true”);<br>var myBoolean=new Boolean(“false”);<br>var myBoolean=new Boolean(“Bill Gates”);</p>
<pre><code>
### JS算数
- Math 对象的 round 方法对一个数进行四舍五入。</code></pre><p>document.write(Math.round(4.7))</p>
<pre><code>- Math 对象的 random() 方法来返回一个介于 0 和 1 之间的随机数</code></pre><p>document.write(Math.random())</p>
<pre><code>- 使用了 Math 对象的 floor() 方法和 random() 来返回一个介于 0 和 10 之间的随机数</code></pre><p>document.write(Math.floor(Math.random()*11)) </p>
<pre><code>













</code></pre>]]></content>
  </entry>
  <entry>
    <title>JS笔记-005-DOM(文档对象模型)</title>
    <url>/2019/03/19/JS%E7%AC%94%E8%AE%B0-005-DOM(%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B)/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/7426378-b9868f154ccce243..gif?imageMogr2/auto-orient/strip" alt="HTML DOM 树"></p>
<p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。HTML DOM 模型被构造为对象的树。</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件做出反应</li>
</ul>
<a id="more"></a>


<h5 id="查找HTML元素"><a href="#查找HTML元素" class="headerlink" title="查找HTML元素"></a>查找HTML元素</h5><ul>
<li>通过ID<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
</code></pre></li>
</ul>
<p id="intro">Hello World!</p>
<p>本例演示 <b>getElementById</b> 方法！</p>

<script>
x=document.getElementById("intro");
document.write('<p>id="intro" 的段落中的文本是：' + x.innerHTML + '</p>');
</script>




<pre><code>- 通过标签名，也是先通过ID拿到控件，再通过控件以及标签名字拿到控件（感觉多此一举）</code></pre><!DOCTYPE html>
<html>
<body>

<p>Hello World!</p>

<div id="main">
<p>The DOM is very useful.</p>
<p>本例演示 <b>getElementsByTagName</b> 方法。</p>
</div>

<script>
var x=document.getElementById("main");
var y=x.getElementsByTagName("p");
document.write('id 为 "main" 的 div 中的第一段文本是：' + y[0].innerHTML);
</script>

</body>
</html>

<pre><code>
- 通过类名（通过类名查找 HTML 元素在 IE 5,6,7,8 中无效。）


##### 改变页面中的元素内容
- 直接使用innerHTML</code></pre><p>var element=document.getElementById(“header”);<br>element.innerHTML=”New Header”;</p>
<pre><code>##### 改变 HTML 属性，attribute指的是对应的属性字段
- 使用`document.getElementById(id).attribute=new value`</code></pre><!DOCTYPE html>
<html>
<body>

<img id="image" src="/i/eg_tulip.jpg">

<script>
document.getElementById("image").src="/i/shanghai_lupu_bridge.jpg";
</script>

<p>原始图片是郁金香（eg_tulip.jpg），但是已被修改为卢浦大桥（shanghai_lupu_bridge.jpg）。</p>

</body>
</html>

<pre><code>
##### 改变HTML样式
- 使用`document.getElementById(id).style.property=new style`</code></pre><!DOCTYPE html>
<html>
<body>

<p id="p1">Hello World!</p>
<p id="p2">Hello World!</p>

<script>
document.getElementById("p2").style.color="blue";
document.getElementById("p2").style.fontFamily="Arial";
document.getElementById("p2").style.fontSize="larger";
</script>

<p>上面的段落已被一段脚本修改。</p>

</body>
</html>

<pre><code>例子2，动态显示以及隐藏文字</code></pre><!DOCTYPE html>
<html>
<body>

<p id="p1">这是一段文本。</p>

<input type="button" value="隐藏文本" onclick="document.getElementById('p1').style.visibility='hidden'">
<input type="button" value="显示文本" onclick="document.getElementById('p1').style.visibility='visible'">

</body>
</html>

<pre><code>
##### DOM事件的响应

我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时。如需在用户点击某个元素时执行代码，请向一个 HTML 事件属性添加 JavaScript 代码：

**HTML 事件的例子：**
- 当用户点击鼠标时
- 当网页已加载时
- 当图像已加载时
- 当鼠标移动到元素上时
- 当输入字段被改变时
- 当提交 HTML 表单时
- 当用户触发按键时
</code></pre><!DOCTYPE html>
<html>
<body>

<h1 onclick="this.innerHTML='谢谢!'">请点击该文本</h1>

</body>
</html>

<pre><code>调用封装方法，ID直接传this即可</code></pre><!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
<script>
function changetext(id)
{
id.innerHTML="谢谢!";
}
</script>
</head>
<body>

<h1 onclick="changetext(this)">请点击该文本</h1>

</body>
</html>

<pre><code>##### 事件属性作出相应,button
类似于xml写好onclick，java直接写事件</code></pre><!DOCTYPE html>
<html>
<body>

<p>点击按钮就可以执行 <em>displayDate()</em> 函数。</p>

<p><button onclick="displayDate()">点击这里</button></p>
<script>
function displayDate()
{
document.getElementById("demo").innerHTML=Date();
}
</script>

<p id="demo"></p>

</body>
</html>
```
##### 使用 HTML DOM 来分配事件，类似于使用button主动调用onclick事件
```
<!DOCTYPE html>
<html>
<body>

<p>点击按钮就可以执行 <em>displayDate()</em> 函数。</p>

<p><button id="myBtn">点击这里</button></p>
<script>
document.getElementById("myBtn").onclick=function(){displayDate()};
function displayDate()
{
document.getElementById("demo").innerHTML=Date();
}
</script>

<p id="demo"></p>

</body>
</html> 
```
##### onload以及onunload事件
onload 和 onunload 事件会在用户进入或离开页面时被触发(类似于获得焦点失去焦点两种生命周期)。

<p>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</p>
<p>onload 和 onunload 事件可用于处理 cookie。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body onload=&quot;checkCookies()&quot;&gt;

&lt;script&gt;
function checkCookies()
{
if (navigator.cookieEnabled==true)
    {
    alert(&quot;已启用 cookie&quot;)
    }
else
    {
    alert(&quot;未启用 cookie&quot;)
    }
}
&lt;/script&gt;

&lt;p&gt;提示框会告诉你，浏览器是否已启用 cookie。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="onchange事件-离开输入框会触发"><a href="#onchange事件-离开输入框会触发" class="headerlink" title="onchange事件,离开输入框会触发"></a>onchange事件,离开输入框会触发</h5><p>onchange 事件常结合对输入字段的验证来使用。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function myFunction()
{
var x=document.getElementById(&quot;fname&quot;);
x.value=x.value.toUpperCase();
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

请输入英文字符：&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;myFunction()&quot;&gt;
&lt;p&gt;当您离开输入字段时，会触发将输入文本转换为大写的函数。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="onmouseover-和-onmouseout-事件"><a href="#onmouseover-和-onmouseout-事件" class="headerlink" title="onmouseover 和 onmouseout 事件"></a>onmouseover 和 onmouseout 事件</h5><p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:green;width:120px;height:20px;padding:40px;color:#ffffff;&quot;&gt;把鼠标移到上面&lt;/div&gt;

&lt;script&gt;
function mOver(obj)
{
obj.innerHTML=&quot;谢谢&quot;
}

function mOut(obj)
{
obj.innerHTML=&quot;把鼠标移到上面&quot;
}
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 onmouseover=&quot;style.color=&#39;red&#39;&quot; onmouseout=&quot;style.color=&#39;blue&#39;&quot;&gt;
请把鼠标移到这段文本上
&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="onmousedown、onmouseup-以及-onclick-事件"><a href="#onmousedown、onmouseup-以及-onclick-事件" class="headerlink" title="onmousedown、onmouseup 以及 onclick 事件"></a>onmousedown、onmouseup 以及 onclick 事件</h5><p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;div onmousedown=&quot;mDown(this)&quot; onmouseup=&quot;mUp(this)&quot; onclick = alert(6) style=&quot;background-color:green;color:#ffffff;width:90px;height:20px;padding:40px;font-size:12px;&quot;&gt;请点击这里&lt;/div&gt;

&lt;script&gt;
function mDown(obj)
{
obj.style.backgroundColor=&quot;#1ec5e5&quot;;
obj.innerHTML=&quot;请释放鼠标按钮&quot;
}

function mUp(obj)
{
obj.style.backgroundColor=&quot;green&quot;;
obj.innerHTML=&quot;请按下鼠标按钮&quot;
}
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="添加新的HTML元素"><a href="#添加新的HTML元素" class="headerlink" title="添加新的HTML元素"></a>添加新的HTML元素</h5><p>如需向 HTML DOM 添加新元素，您必须首先创建该元素（元素节点），然后向一个已存在的元素追加该元素。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot;&gt;
&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;
&lt;p id=&quot;p2&quot;&gt;这是另一个段落。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;div2&quot;&gt;
&lt;p id=&quot;p3&quot;&gt;这是asdasdwqeqwasd段落。&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
//创建新的标签
var para=document.createElement(&quot;p&quot;);
//创建一个新的文本节点
var node=document.createTextNode(&quot;这是新段落。&quot;);
//想标签追加该节点
para.appendChild(node);

//找到一个新的元素
var element=document.getElementById(&quot;div1&quot;);
///追加新的标签
element.appendChild(para);
document.getElementById(&quot;div2&quot;).appendChild(para);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="删除已有的HTML元素"><a href="#删除已有的HTML元素" class="headerlink" title="删除已有的HTML元素"></a>删除已有的HTML元素</h5><p>如需删除 HTML 元素，您必须首先获得该元素的父元素：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot;&gt;
&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;
&lt;p id=&quot;p2&quot;&gt;这是另一个段落。&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
//先获得父节点的对象
var parent=document.getElementById(&quot;div1&quot;);
//获得要删除的那个控件对象
var child=document.getElementById(&quot;p1&quot;);
//通过父元素删除字元素
parent.removeChild(child);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>或者直接获得子元素，通过parentNode获得父元素来删除</p>
<pre><code>var child=document.getElementById(&quot;p1&quot;);
child.parentNode.removeChild(child);</code></pre>]]></content>
  </entry>
  <entry>
    <title>JS笔记-004-常用运算符</title>
    <url>/2019/03/16/JS%E7%AC%94%E8%AE%B0-004-%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<ul>
<li><p>switch 可以省略default的break</p>
<pre><code>var day=new Date().getDay();
switch (day)
{
case 6:
x=&quot;Today it&#39;s Saturday&quot;;
break;
case 0:
x=&quot;Today it&#39;s Sunday&quot;;
break;
default:
x=&quot;Looking forward to the Weekend&quot;;
}</code></pre><a id="more"></a>
</li>
<li><p>循环分为以下几种<br>for</p>
<pre><code>for (var i=0; i&lt;5; i++)
{
x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;
}</code></pre></li>
</ul>
<p>可以省略初赋值</p>
<pre><code>var i=2,len=cars.length;
for (; i&lt;len; i++)
{
document.write(cars[i] + &quot;&lt;br&gt;&quot;);
}</code></pre><p>遍历对象</p>
<pre><code>var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25};

for (x in person)
  {
  txt=txt + person[x];
  }</code></pre><ul>
<li><p>break 搭配标签引用可以跳出任何JS代码块</p>
<pre><code>cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];
list:
{
document.write(cars[0] + &quot;&lt;br&gt;&quot;);
document.write(cars[1] + &quot;&lt;br&gt;&quot;);
document.write(cars[2] + &quot;&lt;br&gt;&quot;);
break list;
document.write(cars[3] + &quot;&lt;br&gt;&quot;);
document.write(cars[4] + &quot;&lt;br&gt;&quot;);
document.write(cars[5] + &quot;&lt;br&gt;&quot;);
}</code></pre></li>
<li><p>try-catch-throw</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
</code></pre></li>
</ul>
<script>
function myFunction()
{
try
{ 
var x=document.getElementById("demo").value;
if(x=="")    throw "值为空";
if(isNaN(x)) throw "不是数字";
if(x>10)     throw "太大";
if(x<5)      throw "太小";
alert(x);
}
catch(err)
{
var y=document.getElementById("mess");
y.innerHTML="错误：" + err + "。";
}
}
</script>

<h1>我的第一个 JavaScript 程序</h1>
<p>请输入 5 到 10 之间的数字：</p>
<input id="demo" type="text">
<button type="button" onclick="myFunction()">测试输入值</button>
<p id="mess"></p>



```
]]></content>
  </entry>
  <entry>
    <title>JS笔记-003-变量-数据类型-对象-函数</title>
    <url>/2019/03/15/JS%E7%AC%94%E8%AE%B0-003-%E5%8F%98%E9%87%8F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>声明变量：不管是局部还是全局变量都是用var声明就可以</p>
<pre><code>var x =2;
var y =3;
var z = x+y;
var pi=3.14;
var name=&quot;Bill Gates&quot;;//使用引号包括就是字符串了
var answer=&#39;Yes I am!&#39;;//可以使用单引号包括</code></pre><a id="more"></a>

<p>字符串要使用引号包括，里面可以嵌套，可以整型拼接字符串写入,写入也可以直接使用整型</p>
<pre><code>var answer=&quot;Nice to meet you!&quot;;
var answer=&quot;He is called &#39;Bill&#39;&quot;;
var answer=&#39;He is called &quot;Bill&quot;&#39;;</code></pre><p>创建一个数组的两种方式</p>
<pre><code>var cars=new Array();
cars[0]=&quot;Audi&quot;;
cars[1]=&quot;BMW&quot;;
cars[2]=&quot;Volvo&quot;;</code></pre><pre><code>var cars=new Array(&quot;Audi&quot;,&quot;BMW&quot;,&quot;Volvo&quot;);</code></pre><p>创建一个对象</p>
<pre><code>var person={firstname:&quot;Bill&quot;, lastname:&quot;Gates&quot;, id:5566};</code></pre><p>从对象里面取值有，get方法</p>
<pre><code>name=person.lastname;
name=person[&quot;lastname&quot;];</code></pre><p>使用var创建对象，可以规定数据类型</p>
<pre><code>var carname=new String;
var x=      new Number;
var y=      new Boolean;
var cars=   new Array;
var person= new Object;</code></pre><h4 id="js函数，就是封装方法。function-必须是小写"><a href="#js函数，就是封装方法。function-必须是小写" class="headerlink" title="js函数，就是封装方法。function 必须是小写"></a>js函数，就是封装方法。function 必须是小写</h4><pre><code>function functionname()
{
这里是要执行的代码
}</code></pre><p>返回值使用reture返回，使用注意，因为没有规定返回的数据类型，所以方法会比较容易重复</p>
<pre><code>function myFunction()
{
var x=5;
return x;
}</code></pre><p>返回值可以省略return（以后证明）</p>
<pre><code>function myFunction(a,b)
{
if (a&gt;b)
  {
  return;
  }
x=a+b
}</code></pre><p>如果一个变量没有提前使用var去声明，而是直接赋值的话，就直接作为全局变量</p>
<pre><code>carname=&quot;Volvo&quot;;</code></pre>]]></content>
  </entry>
  <entry>
    <title>JS 笔记-002-基本语句</title>
    <url>/2019/03/13/JS%20%E7%AC%94%E8%AE%B0-002-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<ul>
<li>如需在 HTML 页面中插入 JavaScript，请使用 <script> 标签。</li>
<li><script> 和 </script> 会告诉 JavaScript 在何处开始和结束。</li>
<li><script> 和 </script> 之间的代码行包含了 JavaScript：</li>
<li>可以再HTML文档中放入不限数量的脚本，该脚本可位于html的<strong><body></body></strong>或<strong><head><meta name="generator" content="Hexo 3.9.0"></head></strong>部分中，或者同时存在于两个部分中</li>
<li>通常是把函数放入<head><meta name="generator" content="Hexo 3.9.0">部分中，或者放在页面底部，这样就可以把它们放置到同一处位置，不会干扰到页面的内容</head></li>
</ul>
<a id="more"></a>

<h5 id="把JS放在head中"><a href="#把JS放在head中" class="headerlink" title="把JS放在head中"></a>把JS放在head中</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
&lt;script&gt;
function myFunction()
{
document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript Function&quot;;
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;h1&gt;My Web Page&lt;/h1&gt;

&lt;p id=&quot;demo&quot;&gt;A Paragraph&lt;/p&gt;

&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="把JS放在body中"><a href="#把JS放在body中" class="headerlink" title="把JS放在body中"></a>把JS放在body中</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;My Web Page&lt;/h1&gt;

&lt;p id=&quot;demo&quot;&gt;A Paragraph&lt;/p&gt;

&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Try it&lt;/button&gt;

&lt;script&gt;
function myFunction()
{
document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript Function&quot;;
}
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="设置JS调用外部包的js文件（head和body都可以调用，外部脚本不能包含-标签），设置type如type-quot-text-javascript-quot-，以及src"><a href="#设置JS调用外部包的js文件（head和body都可以调用，外部脚本不能包含-标签），设置type如type-quot-text-javascript-quot-，以及src" class="headerlink" title="设置JS调用外部包的js文件（head和body都可以调用，外部脚本不能包含  标签），设置type如type=&quot;text/javascript&quot;，以及src"></a>设置JS调用外部包的js文件<em>（head和body都可以调用，外部脚本不能包含 <script> 标签）</em>，设置type如<code>type=&quot;text/javascript&quot;</code>，以及src</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;My Web Page&lt;/h1&gt;

&lt;p id=&quot;demo&quot;&gt;A Paragraph.&lt;/p&gt;

&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;

&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;myFunction 保存在名为 &quot;myScript.js&quot; 的外部文件中。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/js/myScript.js&quot;&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id="操作HTML元素"><a href="#操作HTML元素" class="headerlink" title="操作HTML元素"></a>操作HTML元素</h5><ul>
<li>如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。请使用 "id" 属性来标识 HTML 元素：</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;我的第一张网页&lt;/h1&gt;

&lt;p id=&quot;demo&quot;&gt;我的第一个段落&lt;/p&gt;

&lt;script&gt;
//个换新的内容，使用id直接innerHTML即可
document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一段 JavaScript&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre><p><strong>写到body输出使用write:请使用 document.write() 仅仅向文档输出写内容。<br>如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖：</strong></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;我的第一张网页&lt;/h1&gt;

&lt;script&gt;
document.write(&quot;&lt;p&gt;我的第一段 JavaScript&lt;/p&gt;&quot;);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre></script></em></h5>]]></content>
  </entry>
  <entry>
    <title>JS笔记-001-基本实现</title>
    <url>/2019/03/12/JS%E7%AC%94%E8%AE%B0-001-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="HTML-中的脚本必须位于-与-标签之间。"><a href="#HTML-中的脚本必须位于-与-标签之间。" class="headerlink" title="HTML 中的脚本必须位于  与  标签之间。"></a>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。</h3><p>###脚本可被放置在 HTML 页面的 <body> 和 <head><meta name="generator" content="Hexo 3.9.0"> 部分中。</head></body></p>
<h5 id="JavaScript-能够直接写在Html输出流中，"><a href="#JavaScript-能够直接写在Html输出流中，" class="headerlink" title="JavaScript 能够直接写在Html输出流中，"></a>JavaScript 能够直接写在Html输出流中，</h5><pre><code>&lt;script&gt;
document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);
document.write(&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;);
&lt;/script&gt;</code></pre><p>您只能在 HTML 输出流中使用 document.write。 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。</p>
<a id="more"></a>


<h5 id="点击事件，都需要分号括起来"><a href="#点击事件，都需要分号括起来" class="headerlink" title="点击事件，都需要分号括起来"></a>点击事件，都需要分号括起来</h5><p>先添加type声明是一个button，onclick点击事件弹窗（alert弹窗dialog），弹窗内容使用括号加起来，标签中间声明button的内容</p>
<pre><code>&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Welcome!&#39;)&quot;&gt;点击这里&lt;/button&gt;</code></pre><h5 id="改变html的内容"><a href="#改变html的内容" class="headerlink" title="改变html的内容"></a>改变html的内容</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;我的第一段 JavaScript&lt;/h1&gt;

&lt;p id = &quot;demo&quot;&gt;
JavaScript 能改变 HTML 元素的内容。
&lt;/p&gt;

&lt;script&gt;
     funcation myFuncation()//类似于封装一个方法
{
    x= document.getElementById(&quot;demo&quot;);//找到具体元素,类似于android中ID
    x.innerHTML=&quot;Hello World !&quot;
}     
&lt;/script&gt;

&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="js改变图片地址"><a href="#js改变图片地址" class="headerlink" title="js改变图片地址"></a>js改变图片地址</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
function changeImage()
{
element=document.getElementById(&#39;myimage&#39;)//获得图片控件对象
if (element.src.match(&quot;bulbon&quot;))//判断src是否包含&quot;bulbon&quot;, 类似于indexOf()
  {
  element.src=&quot;/i/eg_bulboff.gif&quot;;
  }
else
  {
  element.src=&quot;/i/eg_bulbon.gif&quot;;
  }
}
&lt;/script&gt;

&lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/i/eg_bulboff.gif&quot;&gt;

&lt;p&gt;点击灯泡来点亮或熄灭这盏灯&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="JavaScript：改变-HTML-样式"><a href="#JavaScript：改变-HTML-样式" class="headerlink" title="JavaScript：改变 HTML 样式"></a>JavaScript：改变 HTML 样式</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;我的第一段 JavaScript&lt;/h1&gt;

&lt;p id=&quot;demo&quot;&gt;
JavaScript 能改变 HTML 元素的样式。
&lt;/p&gt;

&lt;script&gt;
function myFunction()
{
x=document.getElementById(&quot;demo&quot;) // 找到元素
x.style.color=&quot;#57caa1&quot;;          // 改变样式
}
&lt;/script&gt;

&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id="JavaScript：验证输入"><a href="#JavaScript：验证输入" class="headerlink" title="JavaScript：验证输入"></a>JavaScript：验证输入</h5><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt;我的第一段 JavaScript&lt;/h1&gt;

&lt;p&gt;请输入数字。如果输入值不是数字，浏览器会弹出提示框。&lt;/p&gt;

&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;

&lt;script&gt;
function myFunction()
{
var x=document.getElementById(&quot;demo&quot;).value;//通过id得到值，去做判断
if(x==&quot;&quot;||isNaN(x))//isNan（）用于判断是否为数字，类似于number类
    {
    alert(&quot;请输入合法内容&quot;);
    }
}
&lt;/script&gt;

&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
  </entry>
  <entry>
    <title>android日常开发的一些规范</title>
    <url>/2019/03/11/android%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<ol>
<li><p>Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable<br>的方式，可以考虑 EventBus 等替代方案，以免造成 TransactionTooLargeException</p>
</li>
<li><p>activity隐式跳转，在发出 Intent 之前必须通过 resolveActivity检查，避免找不到合适的调用组件，造成 ActivityNotFoundException 的异常</p>
</li>
</ol>
<a id="more"></a>


<pre><code>public void viewUrl(String url, String mimeType) {
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setDataAndType(Uri.parse(url), mimeType);
if (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_
ONLY) != null) {
try {
startActivity(intent);
} catch (ActivityNotFoundException e) {
if (Config.LOGD) {
Log.d(LOGTAG, &quot;activity not found for &quot; + mimeType + &quot; over &quot; +
Uri.parse(url). getScheme(), e);
</code></pre><ol start="3">
<li><p>避免在 Service#onStartCommand()/onBind()方法中执行耗时操作，如果确实有需求，应改用 IntentService 或采用其他异步机制完成</p>
</li>
<li><p>避免在 BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService 完成，而不应该在 BroadcastReceiver 内创建子线程去做。<br>说明：<br>由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅。可以使用IntentService 、 创 建 HandlerThread 或 者 调 用 Context#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)方法等方式，在其他 Wroker 线程执行 onReceive 方法。 BroadcastReceiver#onReceive()方法耗时超过 10 秒钟，可能会被系统杀死</p>
</li>
</ol>
<pre><code>IntentFilter filter = new IntentFilter();
filter.addAction(LOGIN_SUCCESS);
this.registerReceiver(mBroadcastReceiver, filter);
mBroadcastReceiver = new BroadcastReceiver() {
@Override
public void onReceive(Context context, Intent intent) {
Intent userHomeIntent = new Intent();
userHomeIntent.setClass(this, UseHomeActivity.class);
this.startActivity(userHomeIntent);
}
};</code></pre><ol start="5">
<li>添 加 Fragment 时 ， 确 保 FragmentTransaction#commit() 在<br>Activity#onPostResume()或FragmentActivity#onResumeFragments()内调用。<br>不要随意使用FragmentTransaction#commitAllowingStateLoss()来代替，任何<br>commitAllowingStateLoss()的使用必须经过 code review，确保无负面影响。</li>
</ol>
<p>说明如下：</p>
<p>Activity 可 能 因 为 各 种 原 因 被 销 毁 ， Android 支 持 页 面 被 销 毁 前 通 过<br>Activity#onSaveInstanceState() 保 存 自 己 的 状 态 。 但 如 果<br>FragmentTransaction.commit()发生在 Activity 状态保存之后，就会导致 Activity 重<br>建、恢复状态时无法还原页面状态，从而可能出错。为了避免给用户造成不好的体<br>验，系统会抛出 IllegalStateExceptionStateLoss 异常。推荐的做法是在 Activity 的<br>onPostResume() 或 onResumeFragments() （ 对 FragmentActivity ） 里 执 行<br>FragmentTransaction.commit()，如有必要也可在 onCreate()里执行。不要随意改用<br>FragmentTransaction.commitAllowingStateLoss() 或 者 直 接 使 用 try-catch 避 免<br>crash，这不是问题的根本解决之道，当且仅当你确认 Activity 重建、恢复状态时，<br>本次 commit 丢失不会造成影响时才可这么做</p>
<ol start="6">
<li><p>对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册<br>和发送，LocalBroadcastManager 安全性更好，同时拥有更高的运行效率。<br>说明：<br>对于使用 Context#sendBroadcast()等方法发送全局广播的代码进行提示。如果该广<br>播仅用于应用内，则可以使用 LocalBroadcastManager 来避免广播泄漏以及广播被<br>拦截等安全问题，同时相对全局广播本地广播的更高效</p>
</li>
<li><p>使用 Toast 时，建议定义一个全局的 Toast 对象，这样可以避免连续显示<br>Toast 时不能取消上一次 Toast 消息的情况(如果你有连续弹出 Toast 的情况，避免<br>使用 Toast.makeText)</p>
</li>
<li><p>布局中不得不使用 ViewGroup 多重嵌套时，不要使用 LinearLayout 嵌套，<br>改用 RelativeLayout，可以有效降低嵌套数。<br>说明：<br>Android 应用页面上任何一个 View 都需要经过 measure、 layout、 draw 三个步骤<br>才能被正确的渲染。从 xml layout 的顶部节点开始进行 measure，每个子节点都需<br>要向自己的父节点提供自己的尺寸来决定展示的位置，在此过程中可能还会重新<br>measure（由此可能导致 measure 的时间消耗为原来的 2-3 倍）。节点所处位置越<br>深，套嵌带来的 measure 越多，计算就会越费时。这就是为什么扁平的 View 结构<br>会性能更好。<br>同时，页面拥上的 View 越多，measure、 layout、 draw 所花费的时间就越久。要缩<br>短这个时间，关键是保持 View 的树形结构尽量扁平，而且要移除所有不需要渲染的<br>View。理想情况下，总共的 measure，layout，draw 时间应该被很好的控制在 16ms<br>以内，以保证滑动屏幕时 UI 的流畅。<br>要找到那些多余的 View（增加渲染延迟的 view），可以用 Android Studio Monitor<br>里的 Hierarachy Viewer 工具，可视化的查看所有的 view。</p>
</li>
<li><p>在 Application 的业务初始化代码加入进程判断，确保只在自己需要的进程<br>初始化。特别是后台进程减少不必要的业务初始化。</p>
</li>
<li><p>不要通过 Intent 在 Android 基础组件之间传递大数据（binder transaction<br>缓存为 1MB），可能导致 OOM。</p>
</li>
<li><p>新建线程时，必须通过线程池提供（AsyncTask 或者 ThreadPoolExecutor<br>或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。<br>说明：<br>使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解<br>决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致<br>消耗完内存或者“过度切换”的问题。 另外创建匿名线程不便于后续的资源使用分析，<br>对性能分析等会造成困扰。</p>
<pre><code>int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();
int KEEP_ALIVE_TIME = 1;
TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;
BlockingQueue&lt;Runnable&gt; taskQueue = new LinkedBlockingQueue&lt;Runnable&gt;();
ExecutorService executorService = new ThreadPoolExecutor(NUMBER_OF_CORES,
NUMBER_OF_CORES*2, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT, taskQueue,
new BackgroundThreadFactory(), new DefaultRejectedExecutionHandler());
//执行任务
executorService.execute(new Runnnable() {
...
});</code></pre></li>
<li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方<br>式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险Executors 返回的线程池对象的弊端如下：<br>1) FixedThreadPool 和 SingleThreadPool ： 允 许 的 请 求 队 列 长 度 为<br>Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM；<br>2) CachedThreadPool 和 ScheduledThreadPool ： 允 许 的 创 建 线 程 数 量 为<br>Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。<br>正例：</p>
</li>
</ol>
<pre><code>int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();
int KEEP_ALIVE_TIME = 1;
TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;
BlockingQueue&lt;Runnable&gt; taskQueue = new LinkedBlockingQueue&lt;Runnable&gt;();
ExecutorService executorService = new ThreadPoolExecutor(NUMBER_OF_CORES,
NUMBER_OF_CORES*2, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT,
taskQueue, new BackgroundThreadFactory(), new DefaultRejectedExecutionHandler());</code></pre><ol start="13">
<li><p>禁 止 在 多 进 程 之 间 用 SharedPreferences 共 享 数 据 ， 虽 然 可 以<br>(MODE_MULTI_PROCESS)，但官方已不推荐</p>
</li>
<li><p>ThreadPoolExecutor 设置线程存活时间(setKeepAliveTime)，确保空闲时<br>线程能被释放</p>
</li>
<li><p>谨慎使用 Android 的多进程，多进程虽然能够降低主进程的内存压力，但会<br>遇到如下问题：<br>1) 不能实现完全退出所有 Activity 的功能；<br>2) 首次进入新启动进程的页面时会有延时的现象（有可能黑屏、白屏几秒，是白<br>屏还是黑屏和新 Activity 的主题有关）；<br>3) 应用内多进程时，Application 实例化多次，需要考虑各个模块是否都需要在所<br>有进程中初始化；<br>4) 多进程间通过 SharedPreferences 共享数据时不稳定</p>
</li>
</ol>
<p>16.应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用<br>FileProvider。</p>
<ol start="17">
<li><p>SharedPreference 提 交 数 据 时 ， 尽 量 使 用 Editor#apply() ， 而 非<br>Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使<br>用 Editor#commit()。<br>说明：<br>SharedPreference 相关修改使用 apply 方法进行提交会先写入内存，然后异步写入<br>磁盘，commit 方法是直接写入磁盘。如果频繁操作的话 apply 的性能会优于 commit，apply 会将最后修改内容写入磁盘。但是如果希望立刻获取存储操作的结果，并据此<br>做相应的其他操作，应当使用 commit。</p>
</li>
<li><p>多线程操作写入数据库时，需要使用事务，以免出现同步问题。<br>说明：<br>Android 的通过 SQLiteOpenHelper 获取数据库 SQLiteDatabase 实例，Helper 中会<br>自动缓存已经打开的 SQLiteDatabase 实例，单个 App 中应使用 SQLiteOpenHelper<br>的单例模式确保数据库连接唯一。由于 SQLite 自身是数据库级锁，单个数据库操作<br>是保证线程安全的（不能同时写入），transaction 时一次原子操作，因此处于事务中<br>的操作是线程安全的。<br>若同时打开多个数据库连接，并通过多线程写入数据库，会导致数据库异常，提示<br>数据库已被锁住</p>
</li>
</ol>
<pre><code>public void insertUserPhoto(SQLiteDatabase db, String userId, String content) {
ContentValues cv = new ContentValues();
cv.put(&quot;userId&quot;, userId);
cv.put(&quot;content&quot;, content);
db.beginTransaction();
try {
db.insert(TUserPhoto, null, cv);
// 其他操作
db.setTransactionSuccessful();
} catch (Exception e) {
// TODO
} finally {
db.endTransaction();
}
}</code></pre><ol start="19">
<li><p>大数据写入数据库时，请使用事务或其他能够提高 I/O 效率的机制，保证执行速度。</p>
</li>
<li><p>加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加载，涉及到 IO 操作，以及 CPU 密集操作，很可能引起卡顿</p>
</li>
<li><p>png 图片使用 tinypng 或者类似工具压缩处理，减少包体积。</p>
</li>
<li><p>在 Activity.onPause()或 Activity.onStop()回调中，关闭当前 activity 正在执<br>行的的动画。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Rxjava2.0笔记-005-判断性操作符</title>
    <url>/2019/03/10/Rxjava2.0%E7%AC%94%E8%AE%B0-005-%E5%88%A4%E6%96%AD%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><pre><code> /**
     * 判断发送的每项数据是否都满足 设置的函数条件
     */
    private void useAll() {

        Observable.just(1, 2, 3, 4, 5)
                .all(new Predicate&lt;Integer&gt;() {
                    @Override
                    public boolean test(Integer integer) throws Exception {
                        return integer &lt;= 10;
                    }
                }).subscribe(new Consumer&lt;Boolean&gt;() {
            @Override
            public void accept(Boolean aBoolean) throws Exception {

                KLog.d(TTAG, &quot;结果是&quot; + aBoolean);
            }
        });
    }</code></pre><a id="more"></a>

<h3 id="TakeWhile"><a href="#TakeWhile" class="headerlink" title="TakeWhile"></a>TakeWhile</h3><pre><code> // 1. 每1s发送1个数据 = 从0开始，递增1，即0、1、2、3
        Observable.interval(1, TimeUnit.SECONDS)
                // 2. 通过takeWhile传入一个判断条件
                .takeWhile(new Predicate&lt;Long&gt;() {
                    @Override
                    public boolean test(Long integer) throws Exception {
                        return (integer &lt; 3);
                        // 当发送的数据满足&lt;3时，才发送Observable的数据
                    }
                }).subscribe(new Observer&lt;Long&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
            }

            @Override
            public void onNext(Long value) {
                KLog.d(TTAG, &quot;发送了事件 &quot; + value);
            }

            @Override
            public void onError(Throwable e) {
            }

            @Override
            public void onComplete() {
            }
        });
</code></pre><h3 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile"></a>skipWhile</h3><pre><code>// 1. 每隔1s发送1个数据 = 从0开始，每次递增1
        Observable.interval(1, TimeUnit.SECONDS)
                // 2. 通过skipWhile（）设置判断条件
                .skipWhile(new Predicate&lt;Long&gt;() {
                    @Override
                    public boolean test(Long aLong) throws Exception {
                        return (aLong &lt; 5);
                        // 直到判断条件不成立 = false = 发射的数据≥5，才开始发送数据
                    }
                }).subscribe(new Observer&lt;Long&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
            }

            @Override
            public void onNext(Long value) {
                KLog.d(TTAG, &quot;发送了事件 &quot; + value);
            }

            @Override
            public void onError(Throwable e) {
            }

            @Override
            public void onComplete() {
            }
        });</code></pre><h3 id="sequenceEqual"><a href="#sequenceEqual" class="headerlink" title="sequenceEqual"></a>sequenceEqual</h3><pre><code> Observable.sequenceEqual(
                Observable.just(4, 5, 6),
                Observable.just(4, 5, 6)
        )
                .subscribe(aBoolean -&gt; {
                    KLog.d(TTAG, &quot;2个Observable是否相同：&quot; + aBoolean);
                    // 输出返回结果
                });</code></pre><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><pre><code> /**
     * 判断发送的数据中是否包含指定数据
     * &lt;p&gt;
     * 若包含，返回 true；否则，返回 false
     * 内部实现 = exists（）
     */
    private void contains() {
        Observable.just(1, 2, 3, 4, 5, 6)
                .contains(4)
                .subscribe(aBoolean -&gt; {
                    KLog.d(TTAG, &quot;result is &quot; + aBoolean);
                    // 输出返回结果
                });
    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>自定义view的一般步骤</title>
    <url>/2019/03/08/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="自定义EditText封装常用功能"><a href="#自定义EditText封装常用功能" class="headerlink" title="自定义EditText封装常用功能"></a>自定义EditText封装常用功能</h2><blockquote>
<p>该代码参考以下完成:<a href="https://github.com/Carson-Ho/SuperEditText" target="_blank" rel="noopener">SuperEditText</a></p>
</blockquote>
<h4 id="自定义步骤如下："><a href="#自定义步骤如下：" class="headerlink" title="自定义步骤如下："></a>自定义步骤如下：</h4><ol>
<li>添加自定义属性attrs.xml文件：</li>
</ol>
<blockquote>
<p>关于自定义属性参考:  <a href="https://www.jianshu.com/p/42396bbadf33" target="_blank" rel="noopener">Android自定义属性</a></p>
</blockquote>
<a id="more"></a>

<p>2.初始化资源ID，以及对应尺寸大小</p>
<pre><code>  // 获取控件资源
        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.JustEditText);

        //1.点击状态时左侧图标
        ic_left_clickResID = typedArray.getResourceId(R.styleable.JustEditText_ic_left_click, R.drawable.ic_left_click);
        ic_left_click = ContextCompat.getDrawable(context, ic_left_clickResID);
</code></pre><p>3.进行dp转化px单位</p>
<pre><code>  /**
     * 根据手机的分辨率从 dp 的单位 转成为 px(像素)
     */
    public int dpTopx(float dpValue) {
        final float scale = mContext.getResources().getDisplayMetrics().density;
        return (int) (dpValue * scale + 0.5f);
    }

    /**
     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp
     */
    public int pxTodp(float pxValue) {
        final float scale = mContext.getResources().getDisplayMetrics().density;
        return (int) (pxValue / scale + 0.5f);
    }</code></pre><p>4.初始化画笔，绘制</p>
<pre><code> @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        mPaint.setColor(color);
        setTextColor(color);
        // 绘制分割线
        // 需要考虑：当输入长度超过输入框时，所画的线需要跟随着延伸
        // 解决方案：线的长度 = 控件长度 + 延伸后的长度
        int x=this.getScrollX(); // 获取延伸后的长度
        int w=this.getMeasuredWidth(); // 获取控件长度

        // 传入参数时，线的长度 = 控件长度 + 延伸后的长度
                canvas.drawLine(0, this.getMeasuredHeight()- linePosition, w+x,
                        this.getMeasuredHeight() - linePosition, mPaint);

    }
</code></pre><p>5.添加点击事件<code>onTouchEvent</code><br>···<br> @Override<br>    public boolean onTouchEvent(MotionEvent event) {</p>
<pre><code>    switch (event.getAction()) {
        case MotionEvent.ACTION_UP:

            Drawable drawable = ic_delete;
            if (null != drawable &amp;&amp;
                    event.getX() &lt;= (getWidth() - getPaddingRight()) &amp;&amp;
                    event.getX() &gt;= (getWidth() - getPaddingRight() - drawable.getBounds().width())) {

                // 判断条件说明
                // event.getX() ：抬起时的位置坐标
                // getWidth()：控件的宽度
                // getPaddingRight():删除图标图标右边缘至EditText控件右边缘的距离
                // 即：getWidth() - getPaddingRight() = 删除图标的右边缘坐标 = X1
                // getWidth() - getPaddingRight() - drawable.getBounds().width() = 删除图标左边缘的坐标 = X2
                // 所以X1与X2之间的区域 = 删除图标的区域
                // 当手指抬起的位置在删除图标的区域（X2=&lt;event.getX() &lt;=X1），即视为点击了删除图标 = 清空搜索框内容

                setText(&quot;&quot;);
            }
            break;
        default:
            break;
    }
    return super.onTouchEvent(event);
}</code></pre><p>···</p>
<p>6.自定义属性如下：自定义EditText：属性如下：暂不支持代码动态设置</p>
<p>已上传到<code>jitpack</code>添加如下依赖即可使用：</p>
<pre><code>dependencies {
      compile &#39;com.github.ALguojian:justedittext:1.0&#39;
}</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7426378-3b6bab896f6a2891.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="095196333906964CCD876CAFFFCDA3C8.jpg"></p>
<pre><code> android:hint=&quot;请输入账号&quot;
        android:textSize=&quot;14dp&quot;
        //标识符
        app:cursor=&quot;@drawable/cursor&quot;
        //删除按钮高度
        app:delete_height=&quot;10dp&quot;
        //删除按钮宽度
        app:delete_width=&quot;10dp&quot;
        //删除按钮距离左边位置
        app:delete_x=&quot;0dp&quot;
        //删除按钮距离上边位置
        app:delete_y=&quot;0dp&quot;
        //删除按钮图片资源
        app:ic_delete=&quot;@drawable/delete&quot;
        //左边图片获得焦点资源ID
        app:ic_left_click=&quot;@drawable/mine_guide2&quot;
        //左边图片未获得焦点资源ID
        app:ic_left_unclick=&quot;@drawable/mine_guide&quot;
        //左边图片高度
        app:left_height=&quot;10dp&quot;
        //左边图片宽度
        app:left_width=&quot;10dp&quot;
        app:left_x=&quot;0dp&quot;
        app:left_y=&quot;0dp&quot;

        //输入框内获得焦点时候字体颜色
        app:lineColor_click=&quot;@color/lineColor_click&quot;
        app:lineColor_unclick=&quot;@color/lineColor_unclick&quot;</code></pre>]]></content>
  </entry>
  <entry>
    <title>Android自定义属性</title>
    <url>/2019/03/07/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="1-自定义属性需要用xml文件添加："><a href="#1-自定义属性需要用xml文件添加：" class="headerlink" title="1.自定义属性需要用xml文件添加："></a>1.自定义属性需要用xml文件添加：</h3><p>  在<code>res/values</code>下面添加attrs.xml文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;JustEditText&quot;&gt;

        &lt;attr name=&quot;ic_delete&quot; format=&quot;reference&quot; /&gt;
        &lt;attr name=&quot;delete_x&quot; format=&quot;integer&quot;  /&gt;
        &lt;attr name=&quot;delete_y&quot; format=&quot;integer&quot;  /&gt;
        &lt;attr name=&quot;delete_width&quot; format=&quot;integer&quot;  /&gt;
        &lt;attr name=&quot;delete_height&quot; format=&quot;integer&quot;  /&gt;

        &lt;attr name=&quot;ic_left_click&quot; format=&quot;reference&quot; /&gt;
        &lt;attr name=&quot;ic_left_unclick&quot; format=&quot;reference&quot; /&gt;
        &lt;attr name=&quot;left_x&quot; format=&quot;integer&quot;  /&gt;
        &lt;attr name=&quot;left_y&quot; format=&quot;integer&quot;  /&gt;
        &lt;attr name=&quot;left_width&quot; format=&quot;integer&quot;  /&gt;
        &lt;attr name=&quot;left_height&quot; format=&quot;integer&quot;  /&gt;

        &lt;attr name=&quot;lineColor_click&quot; format=&quot;color&quot;  /&gt;
        &lt;attr name=&quot;lineColor_unclick&quot; format=&quot;color&quot;  /&gt;
        &lt;attr name=&quot;linePosition&quot; format=&quot;integer&quot;  /&gt;

        &lt;attr name=&quot;cursor&quot; format=&quot;reference&quot; /&gt;

    &lt;/declare-styleable&gt;
&lt;/resources&gt;</code></pre><a id="more"></a>


<h3 id="2-代码里面引用资源文件"><a href="#2-代码里面引用资源文件" class="headerlink" title="2.代码里面引用资源文件"></a>2.代码里面引用资源文件</h3><pre><code> TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.JustEditText);

 float textSize = typedArray.getDimension(R.styleable.JustEditText_delete_height,30);

 int textColor = typedArray.getColor(R.styleable.JustEditText_lineColor_click, ContextCompat.getColor(context,R.color.colorAccent1));

//用完之后回收
typedArray.recycle();
</code></pre><h3 id="3-自定义属性格式详解："><a href="#3-自定义属性格式详解：" class="headerlink" title="3.自定义属性格式详解："></a>3.自定义属性格式详解：</h3><ol>
<li><p>reference:参考某一资源ID，可以获得资源ID对象</p>
<ul>
<li>属性定义：<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
    &lt;attr name = &quot;background&quot; format = &quot;reference&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li>使用如下：<pre><code>&lt;ImageView
  android:layout_width = &quot;3dp&quot;
  android:layout_height = &quot;3dp&quot;
  android:background = &quot;@drawable/图片ID&quot;
/&gt;</code></pre></li>
</ul>
</li>
</ol>
<p>2.color:颜色值</p>
<ul>
<li>属性定义：<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
     &lt;attr name = &quot;textColor&quot; format = &quot;color&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li>属性使用：<pre><code>&lt;TextView
     android:layout_width = &quot;4dp&quot;
     android:layout_height = &quot;4dp&quot;
     android:textColor = &quot;#57caa1&quot;
/&gt;</code></pre></li>
</ul>
<p>3.boolean:布尔值</p>
<ul>
<li>定义：<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
       &lt;attr name = &quot;focusable&quot; format = &quot;boolean&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li>使用：<pre><code>&lt;Button
     android:layout_width = &quot;42dp&quot;
     android:layout_height = &quot;42dp&quot;
     android:focusable = &quot;true&quot;
/&gt;</code></pre></li>
</ul>
<p>4.dimension：尺寸值，获得属性值之后，将dp转化为px</p>
<ul>
<li><p>定义：</p>
<pre><code>&lt;declare-styleable name = &quot;名称&quot;&gt;
    &lt;attr name = &quot;layout_width&quot; format = &quot;dimension&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li><p>使用：</p>
<pre><code>&lt;Button
    android:layout_width = &quot;42dp&quot;
    android:layout_height = &quot;42dp&quot;
/&gt;</code></pre></li>
</ul>
<p>5.float：浮点值,很少用一般都是integer</p>
<ul>
<li><p>定义：</p>
<pre><code>&lt;declare-styleable name = &quot;AlphaAnimation&quot;&gt;

   &lt;attr name = &quot;fromAlpha&quot; format = &quot;float&quot; /&gt;
   &lt;attr name = &quot;toAlpha&quot; format = &quot;float&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li><p>使用：</p>
<pre><code>&lt;alpha
  android:fromAlpha = &quot;1.0&quot;
  android:toAlpha = &quot;0.7&quot;
/&gt;</code></pre></li>
</ul>
<p>6.integer:整型值</p>
<ul>
<li><p>定义：</p>
<pre><code>&lt;declare-styleable name = &quot;AnimatedRotateDrawable&quot;&gt;
    &lt;attr name = &quot;visible&quot; /&gt;
    &lt;attr name = &quot;frameDuration&quot; format=&quot;integer&quot; /&gt;
    &lt;attr name = &quot;framesCount&quot; format=&quot;integer&quot; /&gt;
    &lt;attr name = &quot;pivotX&quot; /&gt;
    &lt;attr name = &quot;pivotY&quot; /&gt;
    &lt;attr name = &quot;drawable&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li><p>使用：</p>
<pre><code>&lt;animated-rotate
     xmlns:android = &quot;[http://schemas.android.com/apk/res/android]  
      android:drawable = &quot;@drawable/图片ID&quot; 
      android:pivotX = &quot;50%&quot; 
      android:pivotY = &quot;50%&quot; 
      android:framesCount = &quot;12&quot; 
      android:frameDuration = &quot;100&quot;
/&gt;
</code></pre></li>
</ul>
<pre><code>
7. string：字符串

- 定义：</code></pre><declare-styleable name="MapView">
    <attr name="apiKey" format="string">
</attr></declare-styleable>
```

<ul>
<li>使用：<pre><code>&lt;MapView
  android:layout_width = &quot;fill_parent&quot;
 android:layout_height = &quot;fill_parent&quot;
 android:apiKey = &quot;0jOkQ80oD1JL9C6HAja99uGXCRiS2CGjKO_bc_g&quot;
/&gt;</code></pre></li>
</ul>
<p>8.fraction：百分数</p>
<ul>
<li><p>定义：</p>
<pre><code>&lt;declare-styleable name=&quot;RotateDrawable&quot;&gt;
      &lt;attr name = &quot;visible&quot; /&gt;
      &lt;attr name = &quot;fromDegrees&quot; format = &quot;float&quot; /&gt;
      &lt;attr name = &quot;toDegrees&quot; format = &quot;float&quot; /&gt;
      &lt;attr name = &quot;pivotX&quot; format = &quot;fraction&quot; /&gt;
      &lt;attr name = &quot;pivotY&quot; format = &quot;fraction&quot; /&gt;
      &lt;attr name = &quot;drawable&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre></li>
<li><p>使用：</p>
</li>
</ul>
<pre><code> &lt;rotate  
      android:interpolator = &quot;@anim/动画ID&quot;
      android:fromDegrees = &quot;0&quot;
      android:toDegrees = &quot;360&quot;
      android:pivotX = &quot;200%&quot;
      android:pivotY = &quot;300%&quot;
      android:duration = &quot;5000&quot;
      android:repeatMode = &quot;restart&quot;
      android:repeatCount = &quot;infinite&quot;
 /&gt;</code></pre><p>9.enum：枚举值</p>
<ul>
<li><p>定义：</p>
<pre><code>&lt;declare-styleable name=&quot;名称&quot;&gt;
    &lt;attr name=&quot;orientation&quot;&gt;
    &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot; /&gt;
    &lt;enum name=&quot;vertical&quot; value=&quot;1&quot; /&gt;
    &lt;/attr&gt;           
&lt;/declare-styleable&gt;</code></pre></li>
<li><p>使用：</p>
<pre><code>&lt;LinearLayout
   xmlns:android = &quot;[http://schemas.android.com/apk/res/android](http://schemas.android.com/apk/res/android)&quot;
   android:orientation = &quot;vertical&quot;
   android:layout_width = &quot;fill_parent&quot;
   android:layout_height = &quot;fill_parent&quot;&gt;
&lt;/LinearLayout&gt;</code></pre></li>
</ul>
<p>10.flag:位或运算</p>
<ul>
<li><p>定义：</p>
<pre><code>&lt;declare-styleable name=&quot;名称&quot;&gt;
       &lt;attr name=&quot;windowSoftInputMode&quot;&gt;
       &lt;flag name = &quot;stateUnspecified&quot; value = &quot;0&quot; /&gt;
       &lt;flag name = &quot;stateUnchanged&quot; value = &quot;1&quot; /&gt;
       &lt;flag name = &quot;stateHidden&quot; value = &quot;2&quot; /&gt;
       &lt;flag name = &quot;stateAlwaysHidden&quot; value = &quot;3&quot; /&gt;
       &lt;flag name = &quot;stateVisible&quot; value = &quot;4&quot; /&gt;
       &lt;flag name = &quot;stateAlwaysVisible&quot; value = &quot;5&quot; /&gt;
       &lt;flag name = &quot;adjustUnspecified&quot; value = &quot;0x00&quot; /&gt;
       &lt;flag name = &quot;adjustResize&quot; value = &quot;0x10&quot; /&gt;
       &lt;flag name = &quot;adjustPan&quot; value = &quot;0x20&quot; /&gt;
       &lt;flag name = &quot;adjustNothing&quot; value = &quot;0x30&quot; /&gt;
       &lt;/attr&gt;        
&lt;/declare-styleable&gt;</code></pre></li>
<li><p>用法：</p>
<pre><code>&lt;activity
   android:name = &quot;.StyleAndThemeActivity&quot;
   android:label = &quot;@string/app_name&quot;
   android:windowSoftInputMode = &quot;stateUnspecified | stateUnchanged　|　stateHidden&quot;&gt;
      &lt;intent-filter&gt;
          &lt;action android:name = &quot;android.intent.action.MAIN&quot; /&gt;
          &lt;category android:name = &quot;android.intent.category.LAUNCHER&quot; /&gt;
      &lt;/intent-filter&gt;
&lt;/activity&gt;</code></pre></li>
</ul>
<p>属性定义时可以制定多种类型：</p>
<pre><code> &lt;declare-styleable name = &quot;名称&quot;&gt;
         &lt;attr name = &quot;background&quot; format = &quot;reference|color&quot; /&gt;
&lt;/declare-styleable&gt;</code></pre><p>使用：</p>
<pre><code>&lt;ImageView
    android:layout_width = &quot;42dip&quot;
    android:layout_height = &quot;42dip&quot;
    android:background = &quot;@drawable/图片ID|#00FF00&quot;
/&gt;</code></pre>]]></content>
  </entry>
  <entry>
    <title>Rxjava2.0笔记-004-合并,过滤操作符实际应用</title>
    <url>/2019/03/05/Rxjava2.0%E7%AC%94%E8%AE%B0-004-%E5%90%88%E5%B9%B6,%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>关于合并数据源：之前使用了flatMap()以及concatMap（）进行嵌套调用，，注册之后登陆</p>
<p>合并数据源2：合并数据（获取图书详情以及评论）统一展示到客户端：采用merge()或者zip（）操作符</p>
<blockquote>
<p>merge（）例子：实现较为简单的从（网络+本地）获取数据，，统一展示</p>
</blockquote>
<blockquote>
<p>zip（）例子：结合<code>Retrofit</code>以及Rxjava,实现多个网络请求合并获得数据，，统一展示</p>
</blockquote>
<blockquote>
<p>二者区别为：merge()只添加被观察者合并数据源的操作在observable观察者的onnext（）里面处理，进行合并，合并的结果在<code>onComplete（）</code>处理，zip（）可以直接添加发射者，再添加合并数据源的bean，在转主线程，订阅，可以使用<code>new Consumer&lt;Bean&gt;() )</code>里面处理合并结果</p>
</blockquote>
<a id="more"></a>


<pre><code>/**
     * 合并发射者，按时间线执行
     * 合并事件，还是merge（）比较方便好用
     */

    String resultss = &quot;数据源来自：&quot;;

    private void merge() {

//        Observable.merge(
//                //延迟发送操作符
//                //从0开始发送，发送3个数据，第一次发件延迟时间1秒。间隔时间1s
//                //
//                Observable.intervalRange(0,3,1,1,TimeUnit.SECONDS),
//                Observable.intervalRange(2,3,1,1,TimeUnit.SECONDS)
//        ).subscribe(aLong -&gt; {
//
//        });

        Observable.merge(
                Observable.just(&quot;网络&quot;),
                Observable.just(&quot;本地文件&quot;)
        ).subscribe(new Observer&lt;String&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
            }
            @Override
            public void onNext(String s) {
                resultss += s;
            }
            @Override
            public void onError(Throwable e) {
            }
            @Override
            public void onComplete() {

                KLog.d(TTAG, &quot;接收完成统一处理事件：&quot; + resultss);
            }
        });
    }</code></pre><h3 id="下面使用zip操作："><a href="#下面使用zip操作：" class="headerlink" title="下面使用zip操作："></a>下面使用zip操作：</h3><pre><code>  /**
     * 合并数据源
     */
    private void zip() {

        Observable.zip(
                retrofitApi.getCall().subscribeOn(Schedulers.io()),
                retrofitApi.getCall().subscribeOn(Schedulers.io()),
                (translation, translation2) -&gt;
                        translation.toString() + translation2.toString())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(s -&gt; {

                    KLog.d(TTAG, &quot;合并的数据源是：&quot; + s.toString());
                }, throwable -&gt; {

                });
    }</code></pre><h3 id="concat（）实例"><a href="#concat（）实例" class="headerlink" title="concat（）实例"></a>concat（）实例</h3><pre><code> /**
     * 该类型的操作符的作用 = 组合多个被观察者
     * 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行
     * concat()
     * concatArray()
     * 
     * 实例：从内存以及磁盘和网络获取缓存
     */

    String memoryCache = null;
    String diskCache = &quot;磁盘缓存数据&quot;;

    private void concat() {


        Observable.concat(
                Observable.create(emitter -&gt; {

                    //判断内存是否含有缓存
                    if (null == memoryCache) {
                        emitter.onComplete();
                    } else {
                        emitter.onNext(memoryCache);
                    }
                }),
                Observable.create(emitter -&gt; {

                    //判断磁盘
                    if (null == diskCache) {
                        emitter.onComplete();
                    } else {
                        emitter.onNext(diskCache);
                    }
                }),
                Observable.create((ObservableOnSubscribe&lt;String&gt;) emitter -&gt; {

                    emitter.onNext(&quot;从网络获取缓存数据&quot;);
                })
                //通过firstElement()，从串联队列中取出并发送第1个有效事件（Next事件），即依次判断检查memory、disk、network
        ).firstElement()
                // 即本例的逻辑为：
                // a. firstElement()取出第1个事件 = memory，即先判断内存缓存中有无数据缓存；由于memoryCache = null，即内存缓存中无数据，所以发送结束事件（视为无效事件）
                // b. firstElement()继续取出第2个事件 = disk，即判断磁盘缓存中有无数据缓存：由于diskCache ≠ null，即磁盘缓存中有数据，所以发送Next事件（有效事件）
                // c. 即firstElement()已发出第1个有效事件（disk事件），所以停止判断。

                .subscribe(s -&gt; {

                    KLog.d(TTAG, &quot;缓存获得路径是：&quot; + s.toString());
                });
    }</code></pre><h3 id="combineLatest（）实例"><a href="#combineLatest（）实例" class="headerlink" title="combineLatest（）实例"></a>combineLatest（）实例</h3><p>进行多个输入框判断，有一个为空时按钮不可点击，都不为空时才可以点击（并且改变输入框颜色）</p>
<pre><code> /**
     * 通过combineLatest（）合并事件 &amp; 联合判断
     * &lt;p&gt;
     * 当两个Observables中的任何一个发送了数据后，
     * 将先发送了数据的Observables 的最新（最后）一个数据 与
     * 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据
     */
    private void init() {

        nameObser = RxTextView.textChanges(name).skip(1);
        ageObser = RxTextView.textChanges(age).skip(1);
        jobObser = RxTextView.textChanges(job).skip(1);

        Observable.combineLatest(nameObser, ageObser, jobObser,
                (charSequence, charSequence2, charSequence3) -&gt; {
                    boolean nameIsNOtEmpty = !TextUtils.isEmpty(name.getText());

                   // boolean nameIs = !TextUtils.isEmpty(name.getText()) &amp;&amp; name.getText().toString().length() &lt;= 10;
                    boolean ageIsNotEmpty = !TextUtils.isEmpty(age.getText());
                    boolean jobIsNotEmpty = !TextUtils.isEmpty(job.getText());

                    return nameIsNOtEmpty &amp;&amp; ageIsNotEmpty &amp;&amp; jobIsNotEmpty;
                }
        ).subscribe(aBoolean -&gt; {

            KLog.d(TTAG, &quot;点击结果是：&quot; + aBoolean);
            push.setEnabled(aBoolean);
        });
    }</code></pre><h3 id="有条件的轮询操作："><a href="#有条件的轮询操作：" class="headerlink" title="有条件的轮询操作："></a>有条件的轮询操作：</h3><p>使用关键字：repeatWhen</p>
<pre><code>// 设置变量 = 模拟轮询服务器次数
    private int i = 0 ;
    /**
     * 有条件的轮询
     * 使用操作符：repeatWhen
     */
    private void init3() {


        RetrofitApi retrofitApi = OkHttpUtils.newInstance().create(RetrofitApi.class);

        retrofitApi.getCall()
                .repeatWhen(objectObservable -&gt; {

                    // 将原始 Observable 停止发送事件的标识（Complete（） /  Error（））转换成1个 Object 类型数据传递给1个新被观察者（Observable）
                    // 以此决定是否重新订阅 &amp; 发送原来的 Observable，即轮询
                    // 此处有2种情况：
                    // 1. 若返回1个Complete（） /  Error（）事件，则不重新订阅 &amp; 发送原来的 Observable，即轮询结束
                    // 2. 若返回其余事件，则重新订阅 &amp; 发送原来的 Observable，即继续轮询

                    return objectObservable.flatMap((Function&lt;Object, ObservableSource&lt;?&gt;&gt;) o -&gt; {

                        // 加入判断条件：当轮询次数 = 5次后，就停止轮询
                        if (i&gt;3){
                            return Observable.error(new Throwable(&quot;轮询结束&quot;));
                        }
                        // 若轮询次数＜4次，则发送1Next事件以继续轮询
                        // 注：此处加入了delay操作符，作用 = 延迟一段时间发送（此处设置 = 2s），以实现轮询间间隔设置

                        return Observable.just(1).delay(2000, TimeUnit.MILLISECONDS);
                    });
                }).subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Observer&lt;Translation&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {

                    }

                    @Override
                    public void onNext(Translation translation) {

                        translation.show();
                        i++;
                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onComplete() {

                    }
                });


    }
</code></pre><h3 id="有条件的网络请求出错，重试，可以设置条件"><a href="#有条件的网络请求出错，重试，可以设置条件" class="headerlink" title="有条件的网络请求出错，重试，可以设置条件"></a>有条件的网络请求出错，重试，可以设置条件</h3><pre><code> /**
     * 请求出错去重复查询，可以设置条件
     * 使用操作符：retryWhen
     * 发送网络请求 &amp; 通过retryWhen（）进行重试
     * 主要异常才会回调retryWhen（）进行重试
     *   参数Observable&lt;Throwable&gt;中的泛型 = 上游操作符抛出的异常，可通过该条件来判断异常的类型
     */

    // 设置变量
    // 可重试次数
    private int maxConnectCount = 10;
    // 当前已重试次数
    private int currentRetryCount = 0;
    // 重试等待时间
    private int waitRetryTime = 0;

    private void init4() {

        retrofitApi.getCall()
                .retryWhen(throwableObservable -&gt;

                        throwableObservable.flatMap((Function&lt;Throwable, ObservableSource&lt;?&gt;&gt;) throwable -&gt; {

                            if (throwable instanceof IOException) {

                                if (currentRetryCount &lt; maxConnectCount) {
                                    currentRetryCount++;
                                    waitRetryTime = 1000 + currentRetryCount * 1000;

                                    return Observable.just(1).delay(waitRetryTime, TimeUnit.MILLISECONDS);
                                } else {

                                    return Observable.error(new Throwable(&quot;超过重试次数：&quot; + currentRetryCount));
                                }
                            } else {
                                return Observable.error(new Throwable(&quot;发生异常，非网络&quot;));
                            }
                        }))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Observer&lt;Translation&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {
                    }

                    @Override
                    public void onNext(Translation translation) {
                        translation.show();
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onComplete() {

                    }
                });
    }</code></pre><h3 id="有关过滤操作符"><a href="#有关过滤操作符" class="headerlink" title="有关过滤操作符"></a>有关过滤操作符</h3><h4 id="ofType"><a href="#ofType" class="headerlink" title="ofType"></a>ofType</h4><pre><code>  /**
     * 过滤操作符
     */
    private void useOfType() {

        Observable.just(1, &quot;asd&quot;, 2, 3, 4, &quot;qwe&quot;)
                .ofType(Integer.class)
                .subscribe(integer -&gt; {

                    KLog.d(TTAG, &quot;获得的整型消息事件是：&quot; + integer);

                });
    }</code></pre><h4 id="Skip，，，SkipLast"><a href="#Skip，，，SkipLast" class="headerlink" title="Skip，，，SkipLast"></a>Skip，，，SkipLast</h4><pre><code>  /**
     * 跳转开头和跳过结尾消息
     */
    private void userSkipAndSkipLast() {

        // 使用1：根据顺序跳过数据项
        Observable.just(1, 2, 3, 4, 5)
                .skip(1) // 跳过正序的前1项
                .skipLast(2) // 跳过正序的后2项
                .subscribe(integer -&gt; KLog.d(TTAG, &quot;获取到的整型事件元素是： &quot; + integer));

// 使用2：根据时间跳过数据项
        // 发送事件特点：发送数据0-5，每隔1s发送一次，每次递增1；第1次发送延迟0s
        Observable.intervalRange(0, 5, 0, 1, TimeUnit.SECONDS)
                .skip(1, TimeUnit.SECONDS) // 跳过第1s发送的数据
                .skipLast(1, TimeUnit.SECONDS) // 跳过最后1s发送的数据
                .subscribe(along -&gt; KLog.d(TTAG, &quot;获取到的整型事件元素是： &quot; + along));
    }
</code></pre><h4 id="throttleFirst（），，throttleLast（）"><a href="#throttleFirst（），，throttleLast（）" class="headerlink" title="throttleFirst（），，throttleLast（）"></a>throttleFirst（），，throttleLast（）</h4><p>在某段时间内，只发送该段时间内第1次事件 / 最后1次事件</p>
<pre><code>&lt;&lt;- 在某段时间内，只发送该段时间内第1次事件 -&gt;&gt;
Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
                // 隔段事件发送时间
                e.onNext(1);
                Thread.sleep(500);

                e.onNext(2);
                Thread.sleep(400);

                e.onNext(3);
                Thread.sleep(300);

                Thread.sleep(300);
                e.onComplete();
            }
        }).throttleFirst(1, TimeUnit.SECONDS)//每1秒中采用数据
                .subscribe(new Observer&lt;Integer&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {
                        Log.d(TAG, &quot;开始采用subscribe连接&quot;);
                    }

                    @Override
                    public void onNext(Integer value) {
                        Log.d(TAG, &quot;接收到了事件&quot;+ value  );
                    }

                    @Override
                    public void onError(Throwable e) {
                        Log.d(TAG, &quot;对Error事件作出响应&quot;);
                    }

                    @Override
                    public void onComplete() {
                        Log.d(TAG, &quot;对Complete事件作出响应&quot;);
                    }
                });


&lt;&lt;- 在某段时间内，只发送该段时间内最后1次事件 -&gt;&gt;
Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
                // 隔段事件发送时间
                e.onNext(1);
                Thread.sleep(500);

                e.onNext(2);
                Thread.sleep(400);

                Thread.sleep(300);
                e.onComplete();
            }
        }).throttleLast(1, TimeUnit.SECONDS)//每1秒中采用数据
                .subscribe(new Observer&lt;Integer&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {
                        KLog.d(TTAG, &quot;开始采用subscribe连接&quot;);
                    }

                    @Override
                    public void onNext(Integer value) {
                        KLog.d(TTAG, &quot;接收到了事件&quot;+ value  );
                    }

                    @Override
                    public void onError(Throwable e) {
                        KLog.d(TTAG, &quot;对Error事件作出响应&quot;);
                    }

                    @Override
                    public void onComplete() {
                       K Log.d(TTAG, &quot;对Complete事件作出响应&quot;);
                    }
                });</code></pre><p>实际应用：规定时间内，多次点击按钮禁止多次操作使用throttleFirst，操作符</p>
<pre><code>        RxView.clicks(button)
                .throttleFirst(2, TimeUnit.SECONDS)  // 才发送 2s内第1次点击按钮的事件
                .subscribe(new Observer&lt;Object&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {  
                    }
                    @Override
                    public void onNext(Object value) {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onComplete() {
                    }
                });</code></pre><h4 id="Sample（）实例应用实时搜索"><a href="#Sample（）实例应用实时搜索" class="headerlink" title="Sample（）实例应用实时搜索"></a>Sample（）实例应用实时搜索</h4><p>在某段时间内，只发送该段时间内最新（最后）1次事件,与 throttleLast（） 操作符类似</p>
<h4 id="throttleWithTimeout-（）-debounce（）"><a href="#throttleWithTimeout-（）-debounce（）" class="headerlink" title="throttleWithTimeout （） / debounce（）"></a>throttleWithTimeout （） / debounce（）</h4><p>发送数据事件时，若2次发送事件的间隔＜指定时间，就会丢弃前一次的数据，直到指定时间内都没有新数据发射时才会发送后一次的数据</p>
<pre><code>        RxTextView.textChanges(ed)
                .debounce(1, TimeUnit.SECONDS)
                .skip(1) //跳过 第1次请求 = 初始输入框的空字符状态
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Observer&lt;CharSequence&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {
                    }
                    @Override
                    public void onNext(CharSequence charSequence) {
                        tv.setText(&quot;发送给服务器的字符 = &quot; + charSequence.toString());
                    }
                    @Override
                    public void onError(Throwable e) {

                    }
                    @Override
                    public void onComplete() {
                      }
                });</code></pre><h4 id="firstElement（）-，，-lastElement（）"><a href="#firstElement（）-，，-lastElement（）" class="headerlink" title="firstElement（） ，， lastElement（）"></a>firstElement（） ，， lastElement（）</h4><p>仅选取第1个元素 ，，最后一个元素</p>
<pre><code>// 获取第1个元素
        Observable.just(1, 2, 3, 4, 5)
                  .firstElement()
                  .subscribe(new Consumer&lt;Integer&gt;() {
                      @Override
                      public void accept( Integer integer) throws Exception {
                          KLog.d(TTAG,&quot;获取到的第一个事件是： &quot;+ integer);
                      }
        });

// 获取最后1个元素
        Observable.just(1, 2, 3, 4, 5)
                .lastElement()
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept( Integer integer) throws Exception {
                        KLog.d(TTAG,&quot;获取到的最后1个事件是： &quot;+ integer);
                    }
                });</code></pre><h4 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt()"></a>elementAt()</h4><p>指定接收某个消息，根据索引，可以设置默认消息</p>
<pre><code>  private void userEleMentAt() {
        // 使用1：获取位置索引 = 2的 元素
        // 位置索引从0开始
        Observable.just(1, 2, 3, 4, 5)
                .elementAt(2)
                .subscribe(integer -&gt; KLog.d(TTAG,&quot;获取到的事件元素是： &quot;+ integer));

// 使用2：获取的位置索引 ＞ 发送事件序列长度时，设置默认参数
        Observable.just(1, 2, 3, 4, 5)
                .elementAt(6,10)
                .subscribe(integer -&gt; KLog.d(TTAG,&quot;获取到的事件元素是： &quot;+ integer));
    }
</code></pre><h4 id="elementAtOrError（）"><a href="#elementAtOrError（）" class="headerlink" title="elementAtOrError（）"></a>elementAtOrError（）</h4><p>在elementAt（）的基础上，当出现越界情况（即获取的位置索引 ＞ 发送事件序列长度）时，即抛出异常</p>
<pre><code> private void userElementAtOrError() {
        Observable.just(1, 2, 3, 4, 5)
                .elementAtOrError(6)
                .subscribe(integer -&gt; KLog.d(TTAG,&quot;获取到的事件元素是： &quot;+ integer));

    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>Rxjava2.0笔记-003-操作符-搭配Retrofit</title>
    <url>/2019/03/04/Rxjava2.0%E7%AC%94%E8%AE%B0-003-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E6%90%AD%E9%85%8DRetrofit/</url>
    <content><![CDATA[<h3 id="1-使用interval进行轮询操作，类似于请求用户消息（之前一直使用handler）"><a href="#1-使用interval进行轮询操作，类似于请求用户消息（之前一直使用handler）" class="headerlink" title="1. 使用interval进行轮询操作，类似于请求用户消息（之前一直使用handler）"></a>1. 使用<code>interval</code>进行轮询操作，类似于请求用户消息（之前一直使用handler）</h3><pre><code> /**
     * 轮询查询接口-使用操作符interval
     * 此处主要展示无限次轮询，若要实现有限次轮询，仅需将interval（）改成intervalRange（）即可
     */
    private void init() {
        /**
         * 参数说明：
         * 参数1==第一次延迟时间，1秒后发送查询请求
         * 参数2==间隔时间
         * 参数3==实践单位
         * 该例子发送的事件特点：延迟2s后发送事件，每隔1秒产生1个数字（从0开始递增1，无限个）
         */
        Observable.interval(2, 1, TimeUnit.SECONDS)
                /**
                 * 步骤2：每次发送数字前发送1次网络请求（doOnNext（）在执行Next事件前调用）
                 * 即每隔1秒产生1个数字前，就发送1次网络请求，从而实现轮询需求
                 */
                .doOnNext(aLong -&gt; {
                    KLog.d(TTAG, &quot;第&quot; + aLong + &quot;次查询&quot;);

                    retrofitApi.getCall()
                            .subscribeOn(Schedulers.io())
                            .observeOn(AndroidSchedulers.mainThread())
                            .subscribe(new Observer&lt;Translation&gt;() {
                                @Override
                                public void onSubscribe(Disposable d) {
                                    //切断
                                    d.dispose();
                                }
                                @Override
                                public void onNext(Translation translation) {
                                    translation.show();
                                }
                                @Override
                                public void onError(Throwable e) {
                                    KLog.d(TTAG, &quot;请求失败了：失败原因是：&quot; + e.getMessage());
                                }
                                @Override
                                public void onComplete() {
                                    KLog.d(TTAG, &quot;本次请求结束了&quot;);
                                }
                            });

                }).subscribe(aLong -&gt; {

            KLog.d(TTAG, &quot;接收到请求，这是第&quot; + aLong + &quot;次&quot;);

        });

    }</code></pre><a id="more"></a>

<h3 id="2-变换操作符，对时间序列进行加工处理，使其转变成不同的事件-序列"><a href="#2-变换操作符，对时间序列进行加工处理，使其转变成不同的事件-序列" class="headerlink" title="2. 变换操作符，对时间序列进行加工处理，使其转变成不同的事件/序列"></a>2. 变换操作符，对时间序列进行加工处理，使其转变成不同的事件/序列</h3><p>常用变换操作符有：</p>
<ul>
<li>map（）</li>
<li>flatMap（）</li>
<li>concatMap（）</li>
<li>buffer（）</li>
</ul>
<h4 id="2-1-Map（）"><a href="#2-1-Map（）" class="headerlink" title="2.1 Map（）"></a>2.1 Map（）</h4><p>作用：对 被观察者发送的每1个事件都通过 指定的函数 处理，从而变换成另外一种事件，<br>即， 将被观察者发送的事件转换为任意的类型事件。</p>
<p>例子如下：使用map（）操作符使事件参数从整形变换成字符串类型</p>
<pre><code>  Observable.create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; {

            emitter.onNext(1);
            emitter.onNext(2);
            emitter.onNext(3);
        }).map(integer -&gt;
                &quot;这是发送的第&quot; + integer + &quot;条消息&quot;)
                .subscribe(s -&gt;
                        KLog.d(TTAG, &quot;接收事件：：&quot; + s));</code></pre><h4 id="2-2-flatMap（）"><a href="#2-2-flatMap（）" class="headerlink" title="2.2 flatMap（）"></a>2.2 flatMap（）</h4><p>作用：将被观察者发送的事件序列进行 拆分 &amp; 单独转换，再合并成一个新的事件序列，最后再进行发送<br>无序的将被观察者发送的整个事件序列进行变换</p>
<pre><code> private void flatMap() {

        Observable.create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; {
            emitter.onNext(1);
            emitter.onNext(2);
            emitter.onNext(3);
        }).flatMap(integer -&gt; {
            final ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; 3; i++) {
                strings.add(&quot;我是事件&quot;+integer+&quot;拆分后的子事件&quot;+i);
            }
            return Observable.fromIterable(strings);

        }).subscribe(s -&gt; {

            KLog.d(TTAG, s);
        });

    }</code></pre><h4 id="2-3-ConcatMap（）"><a href="#2-3-ConcatMap（）" class="headerlink" title="2.3 ConcatMap（）"></a>2.3 ConcatMap（）</h4><p>作用：<br>类似于flatMap（），不过是有序的</p>
<blockquote>
<p>新合并生成的事件序列顺序是有序的，即 严格按照旧序列发送事件的顺序</p>
</blockquote>
<p>日志如下：</p>
<pre><code>(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件1拆分后的子事件0
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件1拆分后的子事件1
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件1拆分后的子事件2
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件2拆分后的子事件0
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件2拆分后的子事件1
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件2拆分后的子事件2
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件3拆分后的子事件0
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件3拆分后的子事件1
(Main3Activity.java:61)#lambda$flatMap$2$Main3Activity ] 我是事件3拆分后的子事件2
</code></pre><p>实例：接口嵌套</p>
<pre><code> /**
     * 接口合并，实例，注册登录
     */
    private void concatMap() {

        retrofitApi.getCall().subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnNext(translation -&gt; {
                    translation.show();
                }).observeOn(Schedulers.io())//注册线程结束，作为新的观察者，切换到io此线程（理应为设置subscribeOn(Schedulers.io())）
                //作为观察者，下面又有新的观察者，他就作为老的观察者，也就是新的被观察者，所以调控线程用observeOn(Schedulers.io())
                .concatMap(translation -&gt;
                        //添加注册失败是的判断返回空对象
                        null != translation ? retrofitApi.getCall() : Observable.empty())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(translation -&gt; {
                    translation.show();
                }, throwable -&gt; {
                    KLog.d(TTAG, throwable.getMessage());
                });
    }

</code></pre><h4 id="2-4-buffer（）"><a href="#2-4-buffer（）" class="headerlink" title="2.4 buffer（）"></a>2.4 buffer（）</h4><blockquote>
<p>作用：定期从 被观察者（Obervable）需要发送的事件中 获取一定数量的事件 &amp; 放到缓存区中，最终发送</p>
</blockquote>
<pre><code> /**
     * buffer 操作符接受两个参数，buffer(count,skip)，
     * 作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个  Observable 。
     * &lt;p&gt;
     * 意思就是取count个，发射之后，重头开始跳过skip个，在选count个发射，一直到最后一个
     */
    private void buffer() {

        Observable.just(1,2,3,4,5,6,7)
                .buffer(3,1)//设置缓存区大小==每次从被观察者中获取的事件数量
        //步长：每次获取新事件数量
        .subscribe(integers -&gt; {

            KLog.d(TTAG, &quot;缓存区数量&quot;+integers.size());
            for (Integer integer : integers) {
                KLog.d(TTAG, &quot;事件&quot;+integer);
            }
        });
    }
</code></pre><h3 id="3-组合操作符"><a href="#3-组合操作符" class="headerlink" title="3. 组合操作符"></a>3. 组合操作符</h3><h4 id="3-1-concat-以及concatArray"><a href="#3-1-concat-以及concatArray" class="headerlink" title="3.1 concat()以及concatArray()"></a>3.1 concat()以及concatArray()</h4><blockquote>
<p>作用：组合多个被观察者一起发送数据，合并后 按发送顺序串行执行</p>
</blockquote>
<blockquote>
<p>二者区别：组合被观察者的数量，即concat（）组合被观察者数量≤4个，而concatArray（）则可＞4个</p>
</blockquote>
<pre><code>  /**
     * 该类型的操作符的作用 = 组合多个被观察者
     * 组合多个被观察者一起发送数据，合并后 按发送顺序串行执行
     *concat()
     * concatArray()
     */
    private void concat() {

        Observable.concat(Observable.just(1,2)//发射者数量不超过4个
        ,Observable.just(3,4)
        ,Observable.just(7,8))
                .subscribe(integer -&gt; {
                });


        Observable.concatArray(Observable.just(1,2)//被观察者数量不受限制
        ,Observable.just(4,5)
        ,Observable.just(7,8)
        ,Observable.just(3,6))
                .subscribe(integer -&gt; {

                });
    }</code></pre><h4 id="3-2-merge-以及mergeArray"><a href="#3-2-merge-以及mergeArray" class="headerlink" title="3.2 merge()以及mergeArray()"></a>3.2 merge()以及mergeArray()</h4><blockquote>
<p>作用：组合多个被观察者一起发送数据，合并后 按时间线并行执行</p>
</blockquote>
<blockquote>
<p>区别为：merge()组合被观察者数量小于等于4，合并后按时间线执行</p>
</blockquote>
<pre><code> /**
     * 合并发射者，按时间线执行
     */
    private void merge() {

        Observable.merge(
                //延迟发送操作符
                //从0开始发送，工发送3个数据，第一次发件延迟时间1秒。间隔时间1s
                //
                Observable.intervalRange(0,3,1,1,TimeUnit.SECONDS),
                Observable.intervalRange(2,3,1,1,TimeUnit.SECONDS)
        ).subscribe(aLong -&gt; {

        });

    }
</code></pre><h4 id="3-3-concatDelayError-以及mergeDelayError"><a href="#3-3-concatDelayError-以及mergeDelayError" class="headerlink" title="3.3 concatDelayError()以及mergeDelayError()"></a>3.3 concatDelayError()以及mergeDelayError()</h4><blockquote>
<p>作用：使用conat以及merge操作符时，如果某个发射者发出error()时间，则会总结整个流程，我们希望onError（）事件推迟到其他发射者都发送完时间之后后才会触发，即可使用<code>concatDelayError()</code>以及<code>mergeDelayError()</code></p>
</blockquote>
<pre><code> /**
     * 使用conat以及merge操作符时，如果某个发射者发出error()时间，则会总结整个流程，
     * 我们希望onError（）事件推迟到其他发射者都发送完时间之后后才会触发，
     * 即可使用` concatDelayError()`以及`mergeDelayError()`
     */
    private void concatArrayDelayErrorTest() {

        Observable.concatArrayDelayError(Observable.create(emitter -&gt; {

            emitter.onNext(1);
            emitter.onNext(2);
            emitter.onNext(3);
            // 发送Error事件，因为使用了concatDelayError，所以第2个Observable将会发送事件，等发送完毕后，再发送错误事件
            emitter.onError(new NullPointerException());
            emitter.onComplete();

        }),Observable.just(4,5,6))
                .subscribe(integer -&gt; {
                });
    }</code></pre><h3 id="4-合并多个事件"><a href="#4-合并多个事件" class="headerlink" title="4. 合并多个事件"></a>4. 合并多个事件</h3><blockquote>
<p>作用：该类型的操作符主要是对多个发射者中的事件进行合并处理</p>
</blockquote>
<h4 id="4-1-zip-操作符"><a href="#4-1-zip-操作符" class="headerlink" title="4.1 zip()操作符"></a>4.1 zip()操作符</h4><p>作用：合并 多个被观察者（Observable）发送的事件，生成一个新的事件序列（即组合过后的事件序列），并最终发送</p>
<pre><code> /**
     * zip，可以用于接口合并
     * 操作符使用例子
     * zip 专用于合并事件，该合并不是连接（连接操作符后面会说），
     * 而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。
     * &lt;p&gt;
     * zip 组合事件的过程就是分别从发射器 A 和发射器 B 各取出一个事件来组合，并且一个事件只能被使用一次，
     * 组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1 永远是和 A 结合的，2 永远是和 B 结合的
     */
    public static void useZip() {

        Observable.zip(getStringObservable(), getIntegerObservable(),
                (s, integer) -&gt; s + integer).subscribe(s -&gt; KLog.d(TTAG, &quot;新的消息字段是&quot; + s));
    }

    private static Observable&lt;String&gt; getStringObservable() {
        return Observable.create((ObservableOnSubscribe&lt;String&gt;) e -&gt; {
            if (!e.isDisposed()) {
                aaa.append(&quot;asd&quot;);
                e.onNext(&quot;A&quot;);
                aaa.append(&quot;asd&quot;);
                e.onNext(&quot;B&quot;);
                aaa.append(&quot;asd&quot;);
                aaa.append(&quot;zxczxc&quot;);
                e.onNext(&quot;C&quot;);
            }
        }).subscribeOn(Schedulers.io());
    }

    private static Observable&lt;Integer&gt; getIntegerObservable() {
        return Observable.create((ObservableOnSubscribe&lt;Integer&gt;) e -&gt; {
            if (!e.isDisposed()) {

                e.onNext(1);
                aaa.append(&quot;--&quot; + 1);

                e.onNext(2);
                aaa.append(&quot;--&quot; + 2);

                e.onNext(3);
                aaa.append(&quot;--&quot; + 3);

                e.onNext(4);
                aaa.append(&quot;--&quot; + 4);

                e.onNext(5);
                aaa.append(&quot;--&quot; + 5);
            }
        }).subscribeOn(Schedulers.io());
    }</code></pre><h4 id="4-2-combineLatest"><a href="#4-2-combineLatest" class="headerlink" title="4.2 combineLatest()"></a>4.2 combineLatest()</h4><blockquote>
<p>作用：当两个Observables中的任何一个发送了数据后，将先发送了数据的Observables 的最新（最后）一个数据 与 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据</p>
</blockquote>
<pre><code> /**
     * 当两个Observables中的任何一个发送了数据后，
     * 将先发送了数据的Observables 的最新（最后）一个数据 与
     * 另外一个Observable发送的每个数据结合，最终基于该函数的结果发送数据
     */
    private void combineLatest() {

        Observable.combineLatest(
                Observable.just(1L, 2L, 3L, 4L, 5L),
                Observable.intervalRange(0, 3, 1, 1, TimeUnit.SECONDS),
                (aLong, aLong2) -&gt; {
                    KLog.d(TTAG, aLong);
                    KLog.d(TTAG, aLong2);
                    return aLong+aLong2;
                }
        ).subscribe(aLong -&gt; {
            KLog.d(TTAG, aLong);
        });

    }
</code></pre><p>事件接收结果是：</p>
<pre><code>3  0
3
3  1
4
3  2
5</code></pre><h4 id="4-3-reduce（）"><a href="#4-3-reduce（）" class="headerlink" title="4.3 reduce（）"></a>4.3 reduce（）</h4><blockquote>
<p>作用：把被观察者需要发送的事件聚合成1个事件 &amp; 发送</p>
</blockquote>
<pre><code>/**
     * 每次用一个方法处理一个值，可以有一个 seed 作为初始值
     */
    public static void useReduce() {

        Observable.just(1, 2, 3, 4)
                .reduce((integer, integer2) -&gt; {
                    KLog.d(TTAG, integer + &quot;&quot;);
                    KLog.d(TTAG, integer2 + &quot;&quot;);

                    //是所有事件相加
                    return integer + integer2;
                }).subscribe(integer -&gt; KLog.d(TTAG, integer + &quot;&quot;));
    }
</code></pre><h4 id="4-4-collect"><a href="#4-4-collect" class="headerlink" title="4.4 collect()"></a>4.4 collect()</h4><blockquote>
<p>作用：将被观察者<code>Observable</code>发送的时间收集到一个数据结构里面</p>
</blockquote>
<pre><code>  /**
     * 将被观察者Observable发送的数据事件收集到一个数据结构里
     */
    private void collect() {

        Observable.just(1,2,3,4,5,6,7,8)
                .collect((Callable&lt;ArrayList&lt;Integer&gt;&gt;) () -&gt;
                        new ArrayList&lt;&gt;(),
                        (integers, integer) -&gt; {
                    integers.add(integer);
                }).subscribe(integers -&gt;
                KLog.d(TTAG, integers.toString()));

    }
</code></pre><h3 id="5-发送事件前追加发送事件"><a href="#5-发送事件前追加发送事件" class="headerlink" title="5. 发送事件前追加发送事件"></a>5. 发送事件前追加发送事件</h3><h4 id="5-1-startWIth（）以及-startWithArray（）"><a href="#5-1-startWIth（）以及-startWithArray（）" class="headerlink" title="5.1 startWIth（）以及 startWithArray（）"></a>5.1 startWIth（）以及 startWithArray（）</h4><blockquote>
<p>作用： 在一个被观察者发送事件前，追加发送一些数据 / 一个新的被观察者</p>
</blockquote>
<pre><code>  /**
     *  在一个被观察者发送事件前，追加发送一些数据
     *  后追加，先调用，组合模式
     */
    private void startWith() {

        Observable.just(2,3,4,5)
                .startWith(0)
                .startWith(Observable.just(7,8))
                .startWithArray(1)
                .subscribe(integer -&gt; {

                });
    }
</code></pre><h3 id="6-统计发送事件数量"><a href="#6-统计发送事件数量" class="headerlink" title="6. 统计发送事件数量"></a>6. 统计发送事件数量</h3><h4 id="6-1-count（）"><a href="#6-1-count（）" class="headerlink" title="6.1 count（）"></a>6.1 count（）</h4><blockquote>
<p>作用：统计被观察者发送事件的数量</p>
</blockquote>
<pre><code>/**
     * 统计被观察者发送事件的数量
     */
    private void count() {

        Observable.just(1,2,3,4)
                .count()
                .subscribe(aLong -&gt; {
                    KLog.d(TTAG, &quot;发送事件数量是：&quot;+aLong);

                });
    }</code></pre><h3 id="7-在事件的生命周期中操作"><a href="#7-在事件的生命周期中操作" class="headerlink" title="7. 在事件的生命周期中操作"></a>7. 在事件的生命周期中操作</h3><p>在事件发送以及接收的整个生命周期中进行操作，如发送时间前的初始化，发送事件后的回调请求等</p>
<h4 id="7-1-操作符-do（-）"><a href="#7-1-操作符-do（-）" class="headerlink" title="7.1 操作符 do（ ）"></a>7.1 操作符 do（ ）</h4><p>作用：在某个时间的生命周期中调用</p>
<p>类型分为：</p>
<ul>
<li><p>当Observable每发送一次数据事件就会调用1次</p>
<ul>
<li>doOnEach（）</li>
<li>含onNext（）、onError（）和onCompleted（）</li>
</ul>
</li>
<li><p>Next事件</p>
<ul>
<li>执行Next事件前调用- doOnNext( )</li>
<li>执行Next事件后调用- doAfterNext（）</li>
</ul>
</li>
<li><p>发送事件完毕后调用</p>
<ul>
<li>发送错误事件后- doOnError（）</li>
<li>正常发送事件完毕后- doOnCompleted（）</li>
<li>无论正常发送完毕或者异常终止-doOnTerminate（）</li>
<li>最后执行： doFinally（）</li>
</ul>
</li>
<li><p>订阅相关：</p>
<ul>
<li>观察者订阅时调用-doOnSubscribe（）</li>
<li>观察者取消订阅时调用- doOnUnsubscribe（）</li>
</ul>
</li>
</ul>
<p>具体代码如下：</p>
<pre><code> /**
     * do操作符
     */
    private void useDo() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onError(new Throwable(&quot;发送错误&quot;));
            }
            //1. 当Observable每发送1次数据事件就会调用1次
        }).doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() {
            @Override
            public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception {

                KLog.d(TTAG, &quot;doOnEach:&quot; + integerNotification);
            }
            // 2. 执行Next事件前调用
        }).doOnNext(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {
                KLog.d(TTAG, &quot;doOnNext:&quot; + integer);
            }
            //3.执行Next事件后调用
        }).doAfterNext(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

            }
        }).doOnComplete(new Action() {
            @Override
            public void run() throws Exception {
                KLog.d(TTAG, &quot;doOnCompleted:&quot;);
            }
        }).doOnError(new Consumer&lt;Throwable&gt;() {
            @Override
            public void accept(Throwable throwable) throws Exception {

                KLog.d(TTAG, &quot;doOnError:&quot; + throwable.getMessage());
            }
        }).doOnSubscribe(new Consumer&lt;Disposable&gt;() {
            @Override
            public void accept(Disposable disposable) throws Exception {
                KLog.d(TTAG, &quot;doOnSubscribe:&quot;);
            }
        }).doAfterTerminate(new Action() {
            @Override
            public void run() throws Exception {
                KLog.d(TTAG, &quot;doAfterTerminate&quot;);
            }
        }).doFinally(new Action() {
            @Override
            public void run() throws Exception {
                KLog.d(TTAG, &quot;doFinally&quot;);
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                KLog.d(TTAG, &quot;开始发射了&quot;);
            }

            @Override
            public void onNext(Integer integer) {
                KLog.d(TTAG, &quot;接收到事件：&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                KLog.d(TTAG, &quot;发生错误了：&quot; + e.getMessage());
            }

            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;处理完成了&quot;);
            }
        });

    }

(Main3Activity.java:116)#accept ] doOnSubscribe:
(Main3Activity.java:131)#onSubscribe ] 开始发射了
(Main3Activity.java:88)#accept ] doOnEach:OnNextNotification[1]
(Main3Activity.java:94)#accept ] doOnNext:1
(Main3Activity.java:136)#onNext ] 接收到事件：1
(Main3Activity.java:88)#accept ] doOnEach:OnNextNotification[2]
(Main3Activity.java:94)#accept ] doOnNext:2
(Main3Activity.java:136)#onNext ] 接收到事件：2
 (Main3Activity.java:88)#accept ] doOnEach:OnNextNotification[3]
(Main3Activity.java:94)#accept ] doOnNext:3
(Main3Activity.java:136)#onNext ] 接收到事件：3
(Main3Activity.java:88)#accept ] doOnEach:OnErrorNotification[java.lang.Throwable: 发送错误]
(Main3Activity.java:111)#accept ] doOnError:发送错误
(Main3Activity.java:141)#onError ] 发生错误了：发送错误
(Main3Activity.java:126)#run ] doFinally
(Main3Activity.java:121)#run ] doAfterTerminate
</code></pre><h3 id="8-关于错误处理："><a href="#8-关于错误处理：" class="headerlink" title="8.  关于错误处理："></a>8.  关于错误处理：</h3><ul>
<li>onErrorReturn( )</li>
<li>onErrorResumeNext( )</li>
<li>onExceptionResumeNext( )</li>
<li>retry( )</li>
<li>retryUntil( )</li>
<li>retryWhen( )</li>
</ul>
<p>解决方案：</p>
<ol>
<li><p>发送数据：</p>
<ul>
<li><p>发送一个特殊事件&amp;正常终止- onErrorReturn( )</p>
</li>
<li><p>发送一个新的Observable，有如下两种：</p>
<ul>
<li>onErrorResumeNext( )</li>
<li>onExceptionResumeNext( )</li>
</ul>
</li>
</ul>
</li>
<li><p>重试： </p>
</li>
</ol>
<p>-直接重试  retry（）</p>
<ul>
<li><p>让Observable重新订阅 - retryUntil( )</p>
</li>
<li><p>将错误传递给另一个Observable来决定是否要重新订阅改Observable-  retryWhen( )</p>
</li>
</ul>
<p>具体使用见下面代码：</p>
<h4 id="8-1-onErrorReturn"><a href="#8-1-onErrorReturn" class="headerlink" title="8.1 onErrorReturn"></a>8.1 onErrorReturn</h4><pre><code>/**
     * 关于错误的解决方案
     */
    private void onErrorReturn() {


        /**
         * 方案1
         * 发送一个特殊书剑，正常结束
         */
        Observable.create((ObservableOnSubscribe&lt;Integer&gt;) emitter -&gt; {
            emitter.onComplete();
            emitter.onNext(1);
            emitter.onNext(2);
            emitter.onNext(3);
            emitter.onNext(4);
            emitter.onError(new Throwable(&quot;发生错误了&quot;));
        }).onErrorReturn(throwable -&gt; {
            KLog.d(TTAG, &quot;在onErrorReturn处理了错误::&quot; + throwable.getMessage());

            //发生错误时发送一个事件，正常结束
            return 666;
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {
                KLog.d(TTAG, &quot;接收到事件：&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                KLog.d(TTAG, &quot;失败了&quot;);
            }

            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;结束了&quot;);
            }
        });
    }</code></pre><h4 id="8-2-onErrorResumeNext"><a href="#8-2-onErrorResumeNext" class="headerlink" title="8.2 onErrorResumeNext"></a>8.2 onErrorResumeNext</h4><pre><code> /**
     * 方案2
     * 发送新的eObservable
     * 两种方式
     * onErrorResumeNext( )拦截的错误=Throwable；需要拦截Exception使用下面的方式
     * &lt;p&gt;
     * onExceptionResumeNext( )如果拦截的错误=Exception，则会发送新的Observable，不会走onerror（）方法
     * 如果拦截到Throwable错误，会将错误传递给观察者的onError方法，不在发送新的Observable
     */
    private void onErrorResumeNext() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onNext(4);
                emitter.onError(new Throwable(&quot;发生错误了呢&quot;));
            }
        }).onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception {

                KLog.d(TTAG, &quot;onErrorResumeNext:&quot; + throwable.getMessage());

                return Observable.just(7, 3, 6, 8);
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {

                KLog.d(TTAG, &quot;接收到事件：&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                KLog.d(TTAG, &quot;失败了&quot;);
            }

            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;结束了&quot;);
            }
        });
    }</code></pre><h4 id="8-3-onExceptionResumeNext"><a href="#8-3-onExceptionResumeNext" class="headerlink" title="8.3 onExceptionResumeNext"></a>8.3 onExceptionResumeNext</h4><pre><code> private void onExceptionResumeNext() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onNext(4);
                emitter.onError(new Exception(&quot;发生错误了呢&quot;));
            }
        }).onExceptionResumeNext(new Observable&lt;Integer&gt;() {
            @Override
            protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {

                observer.onNext(11);
                observer.onNext(22);
                observer.onComplete();
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {

                KLog.d(TTAG, &quot;接收到事件：&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                KLog.d(TTAG, &quot;失败了&quot;);
            }

            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;结束了&quot;);
            }
        });

    }</code></pre><h4 id="8-4-retry"><a href="#8-4-retry" class="headerlink" title="8.4 retry"></a>8.4 retry</h4><pre><code> /**
     * 当出现错误时，让被观察者（Observable）重新发射数据
     * Throwable 和 Exception都可拦截
     * &lt;p&gt;
     * 1. retry（）
     * 作用：出现错误时，让被观察者重新发送数据
     * 注：若一直错误，则一直重新发送
     * &lt;p&gt;
     * 2. retry（long time）
     * 作用：出现错误时，让被观察者重新发送数据（具备重试次数限制
     * 参数 = 重试次数
     * &lt;p&gt;
     * 3. retry（Predicate predicate）
     * 作用：出现错误后，判断是否需要重新发送数据（若需要重新发送&amp; 持续遇到错误，则持续重试）
     * 参数 = 判断逻辑
     * &lt;p&gt;
     * 4. retry（new BiPredicate&lt;Integer, Throwable&gt;）
     * 作用：出现错误后，判断是否需要重新发送数据（若需要重新发送 &amp; 持续遇到错误，则持续重试
     * 参数 =  判断逻辑（传入当前重试次数 &amp; 异常错误信息）
     * &lt;p&gt;
     * 5. retry（long time,Predicate predicate）
     * 作用：出现错误后，判断是否需要重新发送数据（具备重试次数限制
     * 参数 = 设置重试次数 &amp; 判断逻辑
     */
    private void retry() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onError(new Throwable(&quot;发送错误了&quot;));
                emitter.onNext(5);
                emitter.onNext(6);
            }
            //遇到错误时，让被观察者重新发射数据（若一直错误，则一直重新发送
        }).retry()
                //遇到错误时，重试3次
                .retry(3)
                //拦截错误后，判断是否需要重新发送请求
                .retry(new Predicate&lt;Throwable&gt;() {
                    @Override
                    public boolean test(Throwable throwable) throws Exception {
                        KLog.d(TTAG, &quot;错误是：&quot; + throwable.getMessage());

                        //返回false = 不重新重新发送数据 &amp; 调用观察者的onError结束
                        //返回true = 重新发送请求（若持续遇到错误，就持续重新发送）
                        return throwable.getMessage().equals(&quot;我是判定错误&quot;);
                    }
                    //出现错误后，判断是否需要重新发送数据（若需要重新发送 &amp; 持续遇到错误，则持续重试
                    // 参数 =  判断逻辑（传入当前重试次数 &amp; 异常错误信息）
                }).retry(new BiPredicate&lt;Integer, Throwable&gt;() {
            @Override
            public boolean test(Integer integer, Throwable throwable) throws Exception {
                KLog.d(TTAG, &quot;错误是：&quot; + throwable.getMessage());
                KLog.d(TTAG, &quot;重试次数是：&quot; + integer);

                return true;
            }
            // 作用：出现错误后，判断是否需要重新发送数据（具备重试次数限制
            // 参数 = 设置重试次数 &amp; 判断逻辑
        }).retry(3, new Predicate&lt;Throwable&gt;() {
            @Override
            public boolean test(Throwable throwable) throws Exception {
                KLog.d(TTAG, &quot;错误是：&quot; + throwable.getMessage());

                //返回false = 不重新重新发送数据 &amp; 调用观察者的onError（）结束
                //返回true = 重新发送请求（最多重新发送3次）
                return true;
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onComplete() {

            }
        });


    }
</code></pre><h4 id="8-5-retryUntil"><a href="#8-5-retryUntil" class="headerlink" title="8.5 retryUntil"></a>8.5 retryUntil</h4><pre><code> /**
     * 出现错误后，判断是否需要重新发送数据
     * &lt;p&gt;
     * 若需要重新发送 &amp; 持续遇到错误，则持续重试
     * 作用类似于retry（Predicate predicate）
     * 返回false就一直重试
     * 返回true结束
     */
    private void retryUntil() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onError(new Exception(&quot;发生错误了&quot;));
                emitter.onNext(5);
                emitter.onNext(8);
            }
        }).retryUntil(new BooleanSupplier() {
            @Override
            public boolean getAsBoolean() throws Exception {

                //返回false就一直重试
                //返回true结束
                return true;
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {

                KLog.d(TTAG, &quot;onNext:&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {

                KLog.d(TTAG, &quot;错误是：&quot; + e.getMessage());

            }

            @Override
            public void onComplete() {

            }
        });

    }
</code></pre><h4 id="8-6-retryWhen"><a href="#8-6-retryWhen" class="headerlink" title="8.6 retryWhen"></a>8.6 retryWhen</h4><pre><code>  /**
     * 出现错误后，判断是否需要重新发送数据
     * &lt;p&gt;
     * 若需要重新发送 &amp; 持续遇到错误，则持续重试
     * 作用类似于retry（Predicate predicate）
     * 返回false就一直重试
     * 返回true结束
     */
    private void retryUntil() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onError(new Exception(&quot;发生错误了&quot;));
                emitter.onNext(5);
                emitter.onNext(8);
            }
        }).retryUntil(new BooleanSupplier() {
            @Override
            public boolean getAsBoolean() throws Exception {

                //返回false就一直重试
                //返回true结束
                return true;
            }
        }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {

                KLog.d(TTAG, &quot;onNext:&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {

                KLog.d(TTAG, &quot;错误是：&quot; + e.getMessage());

            }

            @Override
            public void onComplete() {

            }
        });

    }</code></pre><h3 id="9-重复发送操作："><a href="#9-重复发送操作：" class="headerlink" title="9. 重复发送操作："></a>9. 重复发送操作：</h3><h4 id="9-1-repeat（）"><a href="#9-1-repeat（）" class="headerlink" title="9.1 repeat（）"></a>9.1 repeat（）</h4><blockquote>
<p>作用：无条件地、重复发送 被观察者事件，具备重载方法，可设置重复创建次数</p>
</blockquote>
<pre><code>/**
     * 无条件地、重复发送 被观察者事件
     */
    private void repeat() {

        Observable.just(1, 2, 3, 4)
                //设置重复发送次数3次
                .repeat(3)
                .subscribe(new Observer&lt;Integer&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {
                        KLog.d(TTAG, &quot;开始了链接&quot;);
                    }

                    @Override
                    public void onNext(Integer integer) {
                        KLog.d(TTAG, &quot;接收事件是：&quot; + integer);
                    }

                    @Override
                    public void onError(Throwable e) {
                        KLog.d(TTAG, &quot;收到错误了&quot;);
                    }

                    @Override
                    public void onComplete() {
                        KLog.d(TTAG, &quot;完成&quot;);
                    }
                });

    }</code></pre><h4 id="9-2-repeartWhen（）"><a href="#9-2-repeartWhen（）" class="headerlink" title="9.2  repeartWhen（）"></a>9.2  repeartWhen（）</h4><blockquote>
<p>作用：有条件地、重复发送 被观察者事件，将原始 Observable 停止发送事件的标识（Complete（） /  Error（）） 转换成1个 Object 类型数据传递给1个新被观察者（Observable），以此决定是否重新订阅 &amp; 发送原来的 Observable</p>
</blockquote>
<pre><code>**
     * 有条件地、重复发送 被观察者事件
     * 将原始 Observable 停止发送事件的标识（Complete（） /  Error（））
     * 转换成1个 Object 类型数据传递给1个新被观察者（Observable），以此决定是否重新订阅 &amp; 发送原来的 Observable
     * &lt;p&gt;
     * 返回结果分为两种情况：
     * 1.若新被观察者（Observable）返回1个Complete / Error事件，则不重新订阅 &amp; 发送原来的 Observable
     * 2.若新被观察者（Observable）返回其余事件时，则重新订阅 &amp; 发送原来的 Observable
     */
    private void repeatWhen() {

        Observable.just(1,2,3)
                .repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() {
                    @Override
                    public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception {

                        // 在Function函数中，必须对输入的 Observable&lt;Object&gt;进行处理，这里使用的是flatMap操作符接收上游的数据

                        return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() {
                            @Override
                            public ObservableSource&lt;?&gt; apply(Object o) throws Exception {

                                //情况1：若新被观察者（Observable）返回1个Complete（） /  Error（）事件，则不重新订阅 &amp; 发送原来的 Observable

                                // Observable.empty() = 发送Complete事件，但不会回调观察者的onComplete（）

                                // return Observable.error(new Throwable(&quot;不再重新订阅事件&quot;));
                                // 返回Error事件 = 回调onError（）事件，并接收传过去的错误信息。

                                // 情况2：若新被观察者（Observable）返回其余事件，则重新订阅 &amp; 发送原来的 Observable
                                 return Observable.just(1);
                                // 仅仅是作为1个触发重新订阅被观察者的通知，发送的是什么数据并不重要，只要不是Complete（） /  Error（）事件
                            }
                        });
                    }
                }).subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                KLog.d(TTAG, &quot;开始连接&quot;);
            }
            @Override
            public void onNext(Integer integer) {
                KLog.d(TTAG, &quot;收到事件：&quot; + integer);
            }
            @Override
            public void onError(Throwable e) {
                KLog.d(TTAG, &quot;收到错误是：&quot;+e.getMessage());
            }
            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;完成&quot;);
            }
        });

    }</code></pre><h3 id="10-线程调控"><a href="#10-线程调控" class="headerlink" title="10. 线程调控"></a>10. 线程调控</h3><blockquote>
<p>注意：Observable.subscribeOn（）可以多次指定，但是只有第一次有效，Observable.observeOn（）每次都会生效</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Schedulers.immediate()</td>
<td>当前线程 == 不指定线程</td>
<td>默认线程</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>Android主线程</td>
<td>操作UI</td>
</tr>
<tr>
<td>Schedulers.newThread()</td>
<td>常规新线程</td>
<td>进行耗时操作</td>
</tr>
<tr>
<td>Schedulers.io()</td>
<td>IO操作线程</td>
<td>网络请求，读写文件等IO密集型操作</td>
</tr>
<tr>
<td>Schedulers.computation()</td>
<td>CPU计算操作线程</td>
<td>大量计算操作</td>
</tr>
</tbody></table>
<h3 id="11-取消订阅"><a href="#11-取消订阅" class="headerlink" title="11. 取消订阅"></a>11. 取消订阅</h3><blockquote>
<p>使用Disposable.dispose()</p>
</blockquote>
<blockquote>
<p>多个Disposable时，可采用RxJava内置容器CompositeDisposable进行统一管理</p>
</blockquote>
<pre><code>
CompositeDisposable compositeDisposable = new CompositeDisposable();
compositeDisposable.add();
compositeDisposable.clear();
</code></pre>]]></content>
  </entry>
  <entry>
    <title>Rxjava2.0笔记-002-创建操作符</title>
    <url>/2019/03/03/Rxjava2.0%E7%AC%94%E8%AE%B0-002-%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="1-observer的subscribe-具备多个重载的方法"><a href="#1-observer的subscribe-具备多个重载的方法" class="headerlink" title="1.observer的subscribe()具备多个重载的方法"></a>1.observer的subscribe()具备多个重载的方法</h3><pre><code>public final Disposable subscribe() {}
 // 表示观察者不对被观察者发送的事件作出任何响应（但被观察者还是可以继续发送事件）

public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) {}
// 表示观察者只对被观察者发送的Next事件作出响应

public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) {} 
// 表示观察者只对被观察者发送的Next事件 &amp; Error事件作出响应

public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) {}
// 表示观察者只对被观察者发送的Next事件、Error事件 &amp; Complete事件作出响应

public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) {}
// 表示观察者只对被观察者发送的Next事件、Error事件 、Complete事件 &amp; onSubscribe事件作出响应

public final void subscribe(Observer&lt;? super T&gt; observer) {}
// 表示观察者对被观察者发送的任何事件都作出响应
</code></pre><a id="more"></a>


<h3 id="2-切断连接采用Disposable-dispose-，观察者-无法继续-接收-被观察者的事件，但被观察者还是可以继续发送事件"><a href="#2-切断连接采用Disposable-dispose-，观察者-无法继续-接收-被观察者的事件，但被观察者还是可以继续发送事件" class="headerlink" title="2.切断连接采用Disposable.dispose()，观察者 无法继续 接收 被观察者的事件，但被观察者还是可以继续发送事件"></a>2.切断连接采用<code>Disposable.dispose()</code>，观察者 无法继续 接收 被观察者的事件，但被观察者还是可以继续发送事件</h3><pre><code> mDisposable.dispose();</code></pre><h3 id="3-创建操作符分类如下："><a href="#3-创建操作符分类如下：" class="headerlink" title="3.创建操作符分类如下："></a>3.创建操作符分类如下：</h3><ul>
<li><p>基本创建 <code>create()</code></p>
</li>
<li><p>快速创建，</p>
<ul>
<li><p><code>just()</code>：最多发送十个参数</p>
</li>
<li><p><code>fromArray()</code>：传入一个数组，长度不限制，传入集合必须转为数组，否则当成一个事件</p>
</li>
<li><p><code>fromIterable()</code>：传入list集合</p>
</li>
<li><p><code>never()</code>：不发送任何事件</p>
</li>
<li><p><code>empty()</code>：仅发送<code>Complete</code>事件，直接通知<code>Observable observable = Observable.empty();</code></p>
</li>
<li><p><code>error()</code>：该方法创建的被观察者对象仅发送Error事件，直接通知异常，可以自定义<code>Observable observable2=Observable.error(new RuntimeException())</code>即观察者接收后会直接调用<code>onError()</code></p>
</li>
</ul>
</li>
<li><p>延迟创建</p>
<p>1.定时操作：经过X秒后，自动执行Y操作<br>2.周期性操作：每隔X秒后，自动执行Y操作</p>
<ul>
<li><p><code>defer()</code>：直到有观察者订阅时，才会动态创建被观察者，发送事件</p>
<ol>
<li><p>通过 Observable工厂方法创建被观察者对象（Observable）</p>
</li>
<li><p>每次订阅后，都会得到一个刚创建的最新的Observable对象，这可以确保Observable对象里的数据是最新的</p>
<pre><code>// 注：此时被观察者对象还没创建
Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {
   @Override
   public ObservableSource&lt;? extends Integer&gt; call() throws Exception {
       return Observable.just(i);
   }
});</code></pre></li>
</ol>
</li>
<li><p><code>timer()</code></p>
<ol>
<li>快速创建一个被观察者对象(Observable)</li>
<li>发送事件的特点：延迟指定时间后，发送1个数值0（long了类型）</li>
<li>延迟指定时间后，调用一次onnext(0)，一般用于检测</li>
</ol>
</li>
<li><p><code>interval()</code></p>
<ol>
<li>快速创建1个被观察者对象（Observable）</li>
<li>发送事件的特点：每隔指定时间 就发送 事件</li>
</ol>
</li>
<li><p><code>intervalRange()</code></p>
<ol>
<li>每隔指定时间 就发送 事件，可指定发送的数据的数量</li>
</ol>
</li>
<li><p><code>range()</code></p>
<ol>
<li>连续发送 1个事件序列，可指定范围</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Retrofit 各个注解的使用</title>
    <url>/2019/03/02/Retrofit%20%E5%90%84%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<pre><code>* 请求方式有：
 * @Get
 * @post
 * @PUT
 * @DELETE
 * @HEAD
 * @OPTIONS
 * @HTTP (可用于替换上面所有的请求方式)
 * &lt;p&gt;
 * &lt;p&gt;
 * 标记请求方法有：
 * @FormUrlEncoded 表示请求是一个Form表单
 * 每个键值对需要用@Filed来注解键名，随后的对象需要提供值。
 * &lt;p&gt;
 * &lt;p&gt;
 * @Multipart 表示请求体是一个支持文件上传的Form表单
 * 每个键值对需要用@Part来注解键名，随后的对象需要提供值。
 * &lt;p&gt;
 * &lt;p&gt;
 * @Streaming 表示返回的数据以流的形式返回，适用于返回数据较大的场景
 * （如果没有该注解，默认把数据全部载入内存，之后获取数据也是从内存中读取）
 * &lt;p&gt;
 * &lt;p&gt;
 * 网络请求参数如下：
 * @Headers 添加请求头，固定参数
 * @Body 以 Post方式 传递 自定义数据类型 给服务器，也可以传递Map，相当于@Field，需要做处理
 * FormBody.Builder builder = new FormBody.Builder();
 * builder.add(&quot;key&quot;,&quot;value&quot;);
 * &lt;p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * @Field以及@FieldMap 传递单个参数或者一个Map集合
 * &lt;p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * @Part &amp; @PartMap，提交文件，注意Map添加参数是，值为responseBody
 * &lt;p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * @Query以及@QueryMap 用法与@Field相同
 * &lt;p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * @Path 访问的API是：https://api.github.com/users/{user}/repos
 * 在发起请求时， {user} 会被替换为方法的第一个参数 user（被@Path注解作用）
 * &lt;p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * @Url 当有URL注解时，@GET传入的URL就可以省略,当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供
 *
 *
 */
public interface RetrofitApi {

    /**
     * method：网络请求的方法（区分大小写）
     * path：网络请求地址路径
     * hasBody：是否有请求体
     */
    @HTTP(method = &quot;GET&quot;, path = &quot;blog/id=8&quot;, hasBody = true)
    Observable&lt;LoginResponse&gt; testHttp(@Body LoginRequest request);

    @POST(&quot;/post&quot;)
    Observable&lt;LoginResponse&gt; login(@Body LoginRequest request);

    /**
     * 添加请求头，不固定形式，参数需要传值
     *
     * @param plat 参数值
     * @return 访问的API是：https://api.github.com/users/{user}/repos
     * 在发起请求时， {user} 会被替换为方法的第一个参数 user（被@Path注解作用）
     */
    @POST(&quot;users/{user}/rew&quot;)
    @FormUrlEncoded
    Observable&lt;LoginResponse&gt; getUser(@Path(&quot;user&quot;) String user, @Header(&quot;plat&quot;) String plat, @Field(&quot;userName&quot;) String name, @Field(&quot;age&quot;) int age);


    /**
     * 添加Map集合请求参数
     *
     * @param map 当有URL注解时，@GET传入的URL就可以省略,当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供
     * @return
     */
    @POST
    @FormUrlEncoded
    Observable&lt;LoginResponse&gt; testFileMap(@Url String url, @FieldMap Map&lt;String, String&gt; map);


    /**
     * @param name {@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型
     * @param age  除 {@link okhttp3.MultipartBody.Part} 以外，
     *             其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，
     * @param file
     * @return
     */
    @POST(&quot;/asd&quot;)
    @Multipart
    Observable&lt;LoginResponse&gt; testPart(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;age&quot;) RequestBody age, @Part MultipartBody.Part file);


    /**
     * 用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）
     * url = http://www.println.net/?cate=android，其中，Query = cate
     *
     * @param cate
     * @return
     */
    @GET
    Observable&lt;LoginResponse&gt; useQuery(@Query(&quot;cate&quot;) String cate);

    /**
     * 表单形式上传文件，添加参数到RequestBody
     *
     * @param map
     * @param file
     * @return
     */
    @POST(&quot;asds&quot;)
    @Multipart
    Observable&lt;LoginResponse&gt; testPartMap(@PartMap Map&lt;String, RequestBody&gt; map, @Part MultipartBody.Part file);

    /**
     * 添加固定参数的请求头
     *
     * @param request
     * @param name
     * @return
     */
    @POST(&quot;/post&quot;)
    @Headers(&quot;plat: 1&quot;)
    @FormUrlEncoded
    Observable&lt;LoginResponse&gt; testForm(@Body LoginRequest request, @Field(&quot;userName&quot;) String name);

    @POST
    Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);

    @POST
    @Multipart
    Observable&lt;RegisterResponse&gt; testMuilt(@Body RegisterRequest request, @Part(&quot;name&quot;) RequestBody name, @Part MultipartBody.Part file);

    @POST
    Observable&lt;BookInfoResponse&gt; getBookInfo(@Body BookInfoRequest request);

    @POST
    Observable&lt;BookCommentResponse&gt; getBookComment(@Body BookCommentRequest request);
</code></pre>]]></content>
  </entry>
  <entry>
    <title>Rxjava2.0笔记-001-基本使用</title>
    <url>/2019/03/01/Rxjava2.0%E7%AC%94%E8%AE%B0-001-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>该笔记参考如下两篇博客<br><a href="https://www.jianshu.com/p/0cd258eecf60" target="_blank" rel="noopener">这可能是最好的RxJava 2.x 教程（完结版）</a><br><a href="https://www.jianshu.com/p/464fa025229e" target="_blank" rel="noopener">给初学者的RxJava2.0教程(一)</a></p>
</blockquote>
<blockquote>
<blockquote>
<p><a href="https://github.com/ALguojian/RxjavaDemo" target="_blank" rel="noopener">Demo地址，快快点我</a></p>
</blockquote>
</blockquote>
<a id="more"></a>


<pre><code>
Disposable mDisposable;
    int i;

    /**
     * 上游可以发送无限个onNext, 下游也可以接收无限个onNext.
     * 当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送,
     * 而下游收到onComplete事件之后将不再继续接收事件.
     * 当上游发送了一个onError后, 上游onError之后的事件将继续发送,
     * 而下游收到onError事件之后将不再继续接收事件.
     * 上游可以不发送onComplete或onError.
     * 最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete,
     * 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然
     */
    public void getSomeThing() {

        //创建上游，被观察者，发射者
        //它可以发出三种类型的事件，通过调用emitter的onNext(T value)、
        // onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。

        //注: 关于onComplete和onError唯一并且互斥这一点,
        // 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则,
        // **并不一定会导致程序崩溃. ** 比如发送多个onComplete是可以正常运行的,
        // 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError,
        // 则收到第二个onError事件会导致程序会崩溃.
        Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {

            /**
             *
             * @param emitter 发射器 它可以发出三种类型的事件，通过调用emitter的onNext(T value)、
             *                  onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。
             *
             *                ---------------------------------注意如下--------------------------
             *
             *                1.上游可以发送无限个onNext, 下游也可以接收无限个onNext.
             *
             *                2.当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送,
             *                  而下游收到onComplete事件之后将不再继续接收事件.
             *
             *                3.当上游发送了一个onError后, 上游onError之后的事件将继续发送,
             *                  而下游收到onError事件之后将不再继续接收事件.
             *
             *                4.上游可以不发送onComplete或onError.
             *
             *                5.最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete,
             *                  也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然
             *
             * @throws Exception
             */
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onNext(4);
                emitter.onComplete();
            }
        });


        //创建下游，观察者，
        Observer&lt;Integer&gt; integerObserver = new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                mDisposable = d;
            }

            @Override
            public void onNext(Integer o) {
                //调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件.
                if (i == 2) {
                    mDisposable.dispose();
                }
            }

            @Override
            public void onError(Throwable e) {
            }

            @Override
            public void onComplete() {
            }
        };
        observable.subscribe(integerObserver);
    }

    //关联字段subscribe()

    /**
     * public final Disposable subscribe() {}
     * public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) {}
     * public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) {}
     * public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) {}
     * public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) {}
     * public final void subscribe(Observer&lt;? super T&gt; observer) {}
     **/

    /**不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 老子可不管你发什么.**/

    /**
     * 带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写:
     */
    public void useConsumer() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

            }
        }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

            }
        });

    }

    /**
     * 关于线程的调控，上下游默认是在同一个线程工作
     * &lt;p&gt;
     * 指定上游发送事件的线程，多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略.
     * .subscribeOn(Schedulers.newThread())
     * &lt;p&gt;
     * 指定下游接收事件所在线程，多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次.
     * .observeOn(AndroidSchedulers.mainThread())
     * &lt;p&gt;
     * Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作
     * Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作
     * Schedulers.newThread() 代表一个常规的新线程
     * AndroidSchedulers.mainThread() 代表Android的主线程
     **/
    //例子如下
    public void aa() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

            }
        }).subscribeOn(Schedulers.newThread())
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .observeOn(Schedulers.io())
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {

                    }
                });

    }


    /**
     * Flowable在设计的时候采用了一种新的思路也就是响应式拉取的方式来更好的解决上下游流速不均衡的问题.
     * &lt;p&gt;
     * 上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM.
     * &lt;p&gt;
     * 上有事件发送也要做特殊处理
     * &lt;p&gt;
     * &lt;p&gt;
     * 为什么上游发送第一个事件后下游就抛出了MissingBackpressureException异常,
     * 这是因为下游没有调用request, 上游就认为下游没有处理事件的能力, 而这又是一个同步的订阅,
     * 既然下游处理不了, 那上游不可能一直等待吧, 如果是这样, 万一这两根水管工作在主线程里, 界面不就卡死了吗, 因
     * 此只能抛个异常来提醒我们. 那如何解决这种情况呢, 很简单啦, 下游直接调用request(Long.MAX_VALUE)就行了,
     * 或者根据上游发送事件的数量来request就行了, 比如这里request(3)就可以了.
     * &lt;p&gt;
     * 在Flowable里默认有一个大小为128的水缸, 当上下游工作在不同的线程中时,
     * 上游就会先把事件发送到这个水缸中, 因此, 下游虽然没有调用request,
     * 但是上游在水缸中保存着这些事件, 只有当下游调用request时, 才从水缸里取出事件发给下游.
     * &lt;p&gt;
     * 用BackpressureStrategy.ERROR这种方式, 这种方式会在出现上下游流速不均衡的时候直接抛出一个异常,
     * 这个异常就是著名的MissingBackpressureException
     * 以下有多个方式
     * &lt;p&gt;
     * MISSING,
     * ERROR,直接抛出一个异常
     * BUFFER,设置新水缸，没有大小限制, 因此可以存放许许多多的事件.
     * DROP,直接把存不下的事件丢弃
     * LATEST，只保留最新的事件
     */


    public void useFlowable() {

        Flowable&lt;Integer&gt; integerFlowable = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onNext(4);
                emitter.onComplete();
            }
        }, BackpressureStrategy.ERROR);

        Subscriber&lt;Integer&gt; stream = new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {

                //切断水管
                s.cancel();
                //向上又发出消息，这次需要处理到的事件个数
                s.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(Integer integer) {
            }

            @Override
            public void onError(Throwable t) {
            }

            @Override
            public void onComplete() {
            }
        };

        integerFlowable.subscribe(stream);


    }


    /**
     * 使用Flowable操作符--interval
     * &lt;p&gt;
     * interval操作符发送Long型的事件, 从0开始, 每隔指定的时间就把数字加1并发送出来,
     * 在这个例子里, 我们让它每隔1毫秒就发送一次事件, 在下游延时1秒去接收处理, 不用猜也知道结果是什么:
     * &lt;p&gt;
     * 处理方式--加上背压-- .onBackpressureDrop()
     * &lt;p&gt;
     * 当上下游工作在不同的线程里时，每一个线程里都有一个requested，
     * 而我们调用request（1000）时，实际上改变的是下游主线程中的requested，
     * 而上游中的requested的值是由RxJava内部调用request(n)去设置的，这个调用会在合适的时候自动触发。
     */
    public void useFlowableInterval() {

        Flowable.interval(1, TimeUnit.MICROSECONDS)
                .onBackpressureDrop()
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;Long&gt;() {
                    @Override
                    public void onSubscribe(Subscription s) {

                        s.request(Long.MAX_VALUE);
                    }

                    @Override
                    public void onNext(Long aLong) {

                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                    @Override
                    public void onError(Throwable t) {

                    }

                    @Override
                    public void onComplete() {

                    }
                });


    }


    /**
     * 同步情况下：
     * 当上下游在同一个线程中的时候，在下游调用request(n)就会直接改变上游中的requested的值，
     * 多次调用便会叠加这个值，而上游每发送一个事件之后便会去减少这个值，
     * 当这个值减少至0的时候，继续发送事件便会抛异常了。
     * &lt;p&gt;
     * 异步情况：
     * &lt;p&gt;
     * 上下游工作在不同的线程里时，每一个线程里都有一个requested，
     * 而我们调用request（1000）时，实际上改变的是下游主线程中的requested，
     * 而上游中的requested的值是由RxJava内部调用request(n)去设置的，
     * 这个调用会在合适的时候自动触发。
     * &lt;p&gt;
     * &lt;p&gt;
     * 现在我们就能理解为什么没有调用request，上游中的值是128了，
     * 因为下游在一开始就在内部调用了request(128)去设置了上游中的值，因此即使下游没有调用request()，
     * 上游也能发送128个事件，这也可以解释之前我们为什么说Flowable中默认的水缸大小是128，其实就是这里设置的
     */
    public void setRequestId() {

        Flowable
                .create(new FlowableOnSubscribe&lt;Integer&gt;() {
                    @Override
                    public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {

                    }
                }, BackpressureStrategy.ERROR)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;Integer&gt;() {
                    @Override
                    public void onSubscribe(Subscription s) {

                        s.request(10);
                    }

                    @Override
                    public void onNext(Integer integer) {

                    }

                    @Override
                    public void onError(Throwable t) {

                    }

                    @Override
                    public void onComplete() {

                    }
                });

    }

</code></pre><h2 id="rxjava操作符使用如下："><a href="#rxjava操作符使用如下：" class="headerlink" title="rxjava操作符使用如下："></a>rxjava操作符使用如下：</h2><pre><code>/**
 * RxJava操作符使用工具类
 *
 * @author ALguojian
 * @date 2018/1/4
 */


public class RxJavaUtils {

    private static StringBuilder aaa = new StringBuilder();

    /**
     * map操作符使用,操作消息int转化为string，
     */
    public static void useMap() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
                emitter.onNext(4);
                emitter.onNext(5);

            }
        }).map(new Function&lt;Integer, String&gt;() {

            /**
             * 用于返回新的消息类型
             * @param integer
             * @return
             * @throws Exception
             */
            @Override
            public String apply(Integer integer) throws Exception {
                return &quot;这是第&quot; + integer + &quot;条消息&quot;;
            }
        }).subscribe(new Consumer&lt;String&gt;() {

            /**
             * 用户接收map转换之后的新的消息
             * @param s 新的消息
             * @throws Exception
             */
            @Override
            public void accept(String s) throws Exception {

                KLog.d(TTAG, &quot;开始--打印&quot; + s);
            }
        });
    }

    /**
     * 基本使用流程
     * 1.创建被观察者(上游事件)，俗称发射者
     * 2.创建观察者（下游事件），俗称接收者
     * 3.关联二者使用，subscribe
     */
    public static void commentUser() {

        final StringBuilder stringBuilder = new StringBuilder();

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

                stringBuilder.append(&quot;哈哈&quot;);
                emitter.onNext(1);
                stringBuilder.append(&quot;，我是&quot;);
                emitter.onNext(2);
                //下面事件可以发送，但是不再接收
                emitter.onComplete();
                stringBuilder.append(&quot;小学生&quot;);
                emitter.onNext(3);
            }
        }).subscribe(new Observer&lt;Integer&gt;() {

            /**
             *接收者回调方法
             * @param d 用于判断是否可以接收事件true-停止接受；false可以正常接收
             */
            @Override
            public void onSubscribe(Disposable d) {
                stringBuilder.append(&quot;666&quot;);
                KLog.d(TTAG, stringBuilder.toString() + &quot;---Disposable---&quot; + d.isDisposed());
            }

            @Override
            public void onNext(Integer s) {
                stringBuilder.append(&quot;666&quot;);
                KLog.d(TTAG, stringBuilder.toString() + &quot;---onNext初始化&quot;);
                switch (s) {
                    case 1:
                        KLog.d(TTAG, &quot;接收到1---&quot; + stringBuilder.toString());
                        break;
                    case 2:
                        KLog.d(TTAG, &quot;接收到2---&quot; + stringBuilder.toString());
                        break;
                    case 3:
                        KLog.d(TTAG, &quot;接收到3---&quot; + stringBuilder.toString());
                        break;
                    default:
                        break;
                }
            }

            @Override
            public void onError(Throwable e) {
                KLog.d(TTAG, &quot;处理失败&quot;);
            }

            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;处理完成所有事件&quot;);
            }
        });
    }


    /**
     * zip
     * 操作符使用例子
     * zip 专用于合并事件，该合并不是连接（连接操作符后面会说），
     * 而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。
     * &lt;p&gt;
     * zip 组合事件的过程就是分别从发射器 A 和发射器 B 各取出一个事件来组合，并且一个事件只能被使用一次，
     * 组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1 永远是和 A 结合的，2 永远是和 B 结合的
     */
    public static void useZip() {

        Observable.zip(getStringObservable(), getIntegerObservable(), new BiFunction&lt;String, Integer, String&gt;() {
            @Override
            public String apply(String s, Integer integer) throws Exception {
                return s + integer;
            }
        }).subscribe(new Consumer&lt;String&gt;() {
            @Override
            public void accept(String s) throws Exception {
                KLog.d(TTAG, &quot;新的消息字段是&quot; + s);
            }
        });
    }

    private static Observable&lt;String&gt; getStringObservable() {
        return Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {
                if (!e.isDisposed()) {
                    aaa.append(&quot;asd&quot;);
                    e.onNext(&quot;A&quot;);
                    aaa.append(&quot;asd&quot;);
                    e.onNext(&quot;B&quot;);
                    aaa.append(&quot;asd&quot;);
                    aaa.append(&quot;zxczxc&quot;);
                    e.onNext(&quot;C&quot;);
                }
            }
        });
    }

    private static Observable&lt;Integer&gt; getIntegerObservable() {
        return Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {
                if (!e.isDisposed()) {

                    e.onNext(1);
                    aaa.append(&quot;--&quot; + 1);

                    e.onNext(2);
                    aaa.append(&quot;--&quot; + 2);

                    e.onNext(3);
                    aaa.append(&quot;--&quot; + 3);

                    e.onNext(4);
                    aaa.append(&quot;--&quot; + 4);

                    e.onNext(5);
                    aaa.append(&quot;--&quot; + 5);
                }
            }
        });
    }


    /**
     * 对于单一的把两个发射器连接成一个发射器，虽然 zip 不能完成，
     * 但我们还是可以自力更生，官方提供的 concat 让我们的问题得到了完美解决。
     */
    public static void useConcat() {

        Observable.concat(Observable.just(1, 2, 3, 4), Observable.just(6, 7, 8))
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {

                        KLog.d(TTAG, &quot;这是第几个？&quot; + integer);
                    }
                });

    }


    /**
     * FlatMap 是一个很有趣的东西，我坚信你在实际开发中会经常用到。
     * 它可以把一个发射器 Observable 通过某种方法转换为多个 Observables，
     * 然后再把这些分散的 Observables装进一个单一的发射器 Observable。但有个需要注意的是，
     * flatMap 并不能保证事件的顺序，如果需要保证，需要用到我们下面要讲的 ConcatMap。
     */
    public static void useFlatMap() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
            }
        }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {
            @Override
            public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception {

                ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();

                for (int i = 0; i &lt; 3; i++) {
                    strings.add(&quot;这是第几个&quot; + i);
                }
                int time = (int) (1 + Math.random() * 10);
                return Observable.fromIterable(strings).delay(time, TimeUnit.MILLISECONDS);
            }
        }).subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;String&gt;() {
                    @Override
                    public void accept(String s) throws Exception {

                        KLog.d(TTAG, s);
                    }
                });
    }


    /**
     * concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序
     */
    public static void useConcatMap() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onNext(3);
            }
        }).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {
            @Override
            public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception {

                ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();

                for (int i = 0; i &lt; 3; i++) {
                    strings.add(&quot;这是第几个&quot; + i);
                }
                int time = (int) (1 + Math.random() * 10);
                return Observable.fromIterable(strings).delay(time, TimeUnit.MILLISECONDS);
            }
        }).subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;String&gt;() {
                    @Override
                    public void accept(String s) throws Exception {

                        KLog.d(TTAG, s);
                    }
                });

    }


    /**
     * 发射器发送消息最多十个
     * distinct 去除所有重复消息
     * distinctUntilChanged去除连续重复的消息
     */
    public static void useDistinct() {

        Observable.just(1, 1, 1, 2, 2, 2, 12, 2, 3, 3)
                .distinct()
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {

                        KLog.d(TTAG, &quot;第几条&quot; + integer);
                    }
                });
    }


    /**
     * 添加过滤器
     */
    public static void useFilter() {

        Observable.just(1, 20, -20, 57, 43, 80)
                .filter(new Predicate&lt;Integer&gt;() {
                    @Override
                    public boolean test(Integer integer) throws Exception {
                        return integer % 2 == 1;
                    }
                }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {
                KLog.d(TTAG, &quot;接收消息是&quot; + integer);
            }
        });
    }


    /**
     * buffer 操作符接受两个参数，buffer(count,skip)，
     * 作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个  Observable 。
     * &lt;p&gt;
     * 意思就是做多取count个，发射之后，重头开始跳过skip个，在选count个发射，一直到最后一个
     */
    public static void useBuffer() {

        Observable.just(1, 2, 3, 4, 5, 0)
                .buffer(4, 2)
                .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() {
                    @Override
                    public void accept(List&lt;Integer&gt; integers) throws Exception {

                        KLog.d(TTAG, integers);
                    }
                });

    }


    /**
     * 设置延迟发送
     * timer 和 interval 均默认在新线程。
     */
    public static void useTimer() {

        KLog.d(TTAG, TimeUtils.getNowTime());
        aaa.append(TimeUtils.getNowTime());

        Observable.timer(2, TimeUnit.SECONDS)
                .subscribeOn(Schedulers.io())
                // timer 默认在新线程，所以需要切换回主线程
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Long&gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        KLog.d(TTAG, TimeUtils.getNowTime() + &quot;&quot;);
                    }
                });
    }


    /**
     * 设置interval 操作符用于间隔时间执行某个操作，其接受三个参数，分别是第一次发送延迟，间隔时间，时间单位。
     */
    public static void useInterval() {

        KLog.d(TTAG, TimeUtils.getNowTime());
        aaa.append(TimeUtils.getNowTime());

        Disposable subscribe = Observable.interval(3, 2, TimeUnit.SECONDS)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Long&gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        KLog.d(TTAG, aLong + &quot;---&quot; + TimeUtils.getNowTime());
                    }
                });
    }
    //subscribe.dispose();
    //记得activity销毁时取消发送


    /**
     * 让订阅者在接收到数据之前干点有意思的事情
     */
    public static void useDoOnNext() {

        Observable.just(1, 2, 3, 4)
                .doOnNext(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(@NonNull Integer integer) throws Exception {
                        aaa.append(&quot;doOnNext 保存 &quot; + integer);
                        KLog.d(TTAG, aaa.toString());
                    }
                }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(@NonNull Integer integer) throws Exception {
                KLog.d(TTAG, &quot;accept--&quot; + aaa.toString());
            }
        });
    }


    /**
     * 其实作用就和字面意思一样，接受一个 long 型参数 count ，代表跳过 count 个数目开始接收
     */
    public static void useSkip() {

        Observable.just(1, 2, 3, 4, 5, 6, 7)
                .skip(3)
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {
                        KLog.d(TTAG, integer);
                    }
                });
    }


    /**
     * 接受一个 long 型参数 count ，代表至多接收 count 个数据。
     */
    public static void useTake() {

        Flowable.fromArray(1, 2, 3, 4, 5, 6, 7, 7)
                .take(4)
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {

                        KLog.d(TTAG, integer);
                    }
                });
    }


    /**
     * 简单的发射器依次调用 onNext() 方法。还调用了 onComplete()。
     */
    public static void useJust() {

        Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;)
                .subscribeOn(Schedulers.io())
                .subscribe(new Consumer&lt;String&gt;() {
                    @Override
                    public void accept(String s) throws Exception {
                        KLog.d(TTAG, s);
                    }
                });
    }

    /**
     * Single 只会接收一个参数，而 SingleObserver 只会调用 onError() 或者 onSuccess()。
     */
    public static void useSingle() {

        Single.just(new Random().nextInt())
                .subscribe(new SingleObserver&lt;Integer&gt;() {
                    @Override
                    public void onSubscribe(Disposable d) {

                    }

                    @Override
                    public void onSuccess(Integer integer) {

                        KLog.d(TTAG, integer + &quot;&quot;);
                    }

                    @Override
                    public void onError(Throwable e) {

                        KLog.d(TTAG, e.toString() + &quot;---&quot; + e.getMessage());
                    }
                });

    }


    /**
     * 去除发送频率过快的项,timeout为分界线
     */
    public static void useDebonunce() {

        Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {

                emitter.onNext(1);
                Thread.sleep(300);
                emitter.onNext(2);
                Thread.sleep(500);
                emitter.onComplete();
            }
        }).debounce(500, TimeUnit.MILLISECONDS)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {

                        KLog.d(TTAG, integer);
                    }
                });
    }


    /**
     * 每次订阅都会创建一个新的 Observable，并且如果没有被订阅，就不会产生新的 Observable。
     */
    public static void useDefer() {

        Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends Integer&gt; call() throws Exception {
                return Observable.just(1, 2, 3, 4);
            }
        });

        observable.subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Integer integer) {

                KLog.d(TTAG, &quot;第几个&quot; + integer);
            }

            @Override
            public void onError(Throwable e) {

                KLog.d(TTAG, &quot;错误是&quot; + e.getMessage());
            }

            @Override
            public void onComplete() {
                KLog.d(TTAG, &quot;完成处理&quot;);
            }
        });
    }


    /**
     * 仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。
     */
    public static void useLast() {

        Observable.just(1, 2, 3, 4, 5, 6, 7, 8)
                .last(4)
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {
                        KLog.d(TTAG, integer + &quot;&quot;);
                    }
                });
    }


    /**
     * 把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。
     * 注意它和 concat 的区别在于，不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送。
     */
    public static void useMerge() {

        Observable.merge(Observable.just(1, 2, 3), Observable.just(5, 6, 7, 8))
                .subscribe(new Consumer&lt;Integer&gt;() {
                    @Override
                    public void accept(Integer integer) throws Exception {

                        KLog.d(TTAG, &quot;第几个&quot; + integer);
                    }
                });
    }

    ;


    /**
     * 每次用一个方法处理一个值，可以有一个 seed 作为初始值
     */
    public static void useReduce() {

        Observable.just(1, 2, 3, 4)
                .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {
                    @Override
                    public Integer apply(Integer integer, Integer integer2) throws Exception {
                        KLog.d(TTAG, integer + &quot;&quot;);
                        KLog.d(TTAG, integer2 + &quot;&quot;);
                        return integer + integer2;
                    }
                }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

                KLog.d(TTAG, integer + &quot;&quot;);
            }
        });
    }


    /**
     * reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。
     */
    public static void useScan() {

        Observable.just(1, 2, 3, 4)
                .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {
                    @Override
                    public Integer apply(Integer integer, Integer integer2) throws Exception {
                        KLog.d(TTAG, integer + &quot;&quot;);
                        KLog.d(TTAG, integer2 + &quot;&quot;);
                        return integer + integer2;
                    }
                }).subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {
                KLog.d(TTAG, integer + &quot;&quot;);
            }
        });
    }


    /**
     * 按照实际划分窗口，将数据发送给不同的 Observable
     */
    public static void useWindow() {
        aaa.append(&quot;哈哈我是&quot;);
        Observable.interval(1, TimeUnit.SECONDS)// 间隔一秒发一次
                .take(15)//最多接收15个
                .window(3, TimeUnit.SECONDS)
                .subscribeOn(Schedulers.io())
                .subscribe(new Consumer&lt;Observable&lt;Long&gt;&gt;() {
                    @Override
                    public void accept(Observable&lt;Long&gt; longObservable) throws Exception {
                        aaa.append(&quot;aa&quot;);
                        KLog.d(TTAG, aaa.toString());
                        longObservable.subscribeOn(Schedulers.io())
                                .observeOn(AndroidSchedulers.mainThread())
                                .subscribe(new Consumer&lt;Long&gt;() {
                                    @Override
                                    public void accept(Long aLong) throws Exception {
                                        aaa.append(&quot;bb&quot;);
                                        KLog.d(TTAG, aaa.toString());
                                    }
                                });
                    }
                });
    }</code></pre>]]></content>
  </entry>
  <entry>
    <title>android数据库GreenDao的使用</title>
    <url>/2019/02/19/android%E6%95%B0%E6%8D%AE%E5%BA%93GreenDao%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>GreenDao对象字段注释如下</p>
<blockquote>
<p><a href="https://github.com/ALguojian/GreenDaoDemo" target="_blank" rel="noopener">项目地址</a>   <a href="https://github.com/ALguojian/GreenDaoDemo" target="_blank" rel="noopener">https://github.com/ALguojian/GreenDaoDemo</a></p>
</blockquote>
<ul>
<li>@Entity：告诉GreenDao该对象为实体，只有被@Entity注释的Bean类才能被dao类操作</li>
<li>@Id：对象的Id，使用Long类型作为EntityId，否则会报错。(autoincrement = true)表示主键会自增，如果false就会使用旧值</li>
<li>@Property：可以自定义字段名，注意外键不能使用该属性</li>
<li>@NotNull：属性不能为空</li>
<li>@Transient：使用该注释的属性不会被存入数据库的字段中</li>
<li>@Unique：该属性值必须在数据库中是唯一值</li>
<li>@Generated：编译后自动生成的构造函数、方法等的注释，提示构造函数、方法等不能被修改</li>
</ul>
<a id="more"></a>

<p>Dao对象API如下：</p>
<ul>
<li><p>增加单个数据</p>
<ul>
<li>getShopDao().insert(shop);<ul>
<li>getShopDao().insertOrReplace(shop)(有的话就更新覆盖);</li>
</ul>
</li>
</ul>
</li>
<li><p>增加多个数据</p>
<ul>
<li>getShopDao().insertInTx(shopList);</li>
<li>getShopDao().insertOrReplaceInTx(shopList);</li>
</ul>
</li>
<li><p>查询全部</p>
<ul>
<li>List&lt; Shop&gt; list = getShopDao().loadAll();</li>
<li>List&lt; Shop&gt; list = getShopDao().queryBuilder().list();</li>
</ul>
</li>
<li><p>查询条件数据</p>
<ul>
<li>.where()</li>
<li>.whereOr()</li>
</ul>
</li>
<li><p>查询附加多个条件</p>
<ul>
<li>.where(, , ,)</li>
<li>.whereOr(, , ,)</li>
</ul>
</li>
<li><p>查询附加排序</p>
<ul>
<li>.orderDesc()</li>
<li>.orderAsc()</li>
</ul>
</li>
<li><p>查询限制当页个数</p>
<ul>
<li>.limit()</li>
</ul>
</li>
<li><p>查询总个数</p>
<ul>
<li>.count()</li>
</ul>
</li>
<li><p>修改单个数据</p>
<ul>
<li>getShopDao().update(shop);</li>
</ul>
</li>
<li><p>修改多个数据</p>
<ul>
<li>getShopDao().updateInTx(shopList);</li>
</ul>
</li>
<li><p>删除单个数据</p>
<ul>
<li>getTABUserDao().delete(user);</li>
</ul>
</li>
<li><p>删除多个数据</p>
<ul>
<li>getUserDao().deleteInTx(userList);</li>
</ul>
</li>
<li><p>删除数据ByKey</p>
<ul>
<li>getTABUserDao().deleteByKey();</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>android常用注解以及自定义注解替代枚举</title>
    <url>/2019/02/18/android%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%9B%BF%E4%BB%A3%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h3><pre><code>/**
 * @author ALguojian
 * @date 2018/1/16
 * 自定义注解
 */
public interface UserType {

    String TOPIC = &quot;topic&quot;;
    String ORIGIN = &quot;origin&quot;;
    String MINI = &quot;mini&quot;;

    @StringDef({TOPIC, ORIGIN, MINI})
    @Retention(RetentionPolicy.SOURCE)//指定注解仅存在与源码中,不加入到 class 文件中
    @interface Type {}
}
</code></pre><a id="more"></a>


<p>实体类：</p>
<pre><code>public class User {

    @UserType.Type
    private String name;
    @NonNull
    private int age;

    public String getName() {
        return name;
    }
    public void setName(@UserType.Type String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}</code></pre><p>使用：</p>
<pre><code>
        User user = new User();
        user.setAge(12);
        user.setName(UserType.MINI);

        @UserType.Type String aa = UserType.MINI;

        switch (aa) {
            case UserType.MINI:
                break;
            default:
                break;
        }
</code></pre><h3 id="2-NoNull，不能为null"><a href="#2-NoNull，不能为null" class="headerlink" title="2. @NoNull，不能为null"></a>2. @NoNull，不能为null</h3><p>源码如下：</p>
<pre><code> @Retention(CLASS)
 @Target({METHOD, PARAMETER, FIELD})
 public @interface NonNull {
 }</code></pre><h3 id="3-Nullable-可以为null"><a href="#3-Nullable-可以为null" class="headerlink" title="3. @Nullable 可以为null"></a>3. @Nullable 可以为null</h3><p>源码如下：</p>
<pre><code>@Documented
@Retention(CLASS)
@Target({METHOD, PARAMETER, FIELD, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE})
public @interface Nullable {
}
</code></pre><h3 id="4-Resource-Type-资源类型注解"><a href="#4-Resource-Type-资源类型注解" class="headerlink" title="4. Resource Type 资源类型注解"></a>4. Resource Type 资源类型注解</h3><ul>
<li>@AnimatorRes: animator资源类型</li>
<li>@AnimRes: anim资源类型</li>
<li>@AnyRes: 任意资源类型</li>
<li>@DrawableRes： drawable资源类型</li>
<li>@LayoutRes: layout资源类型</li>
<li>@ColorInt： RGB颜色类型</li>
</ul>
<p>此类注解以Res结尾，比如@BoolRes, @IdRes, @IntegerRes, @StringRes, @ColorRes等，这里以@ColorRes为例说明</p>
<pre><code> @Documented
    @Retention(CLASS)
    @Target({METHOD, PARAMETER, FIELD, LOCAL_VARIABLE})
    public @interface ColorRes {
    }</code></pre><p>列子：</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        getCurColor(R.id.ic_launcher);
    }

    void getCurColor(@ColorRes int color) {
        Toast.makeText(this, &quot;Color: &quot; + getString(color), Toast.LENGTH_LONG).show();
    }
}</code></pre><p>我们给getColor函数的参数color加上了@ColorRes注解，即该参数是一个颜色资源，而上面我们上面传递的是id资源</p>
<h3 id="5-设置取值范围：Value-Constraints"><a href="#5-设置取值范围：Value-Constraints" class="headerlink" title="5. 设置取值范围：Value Constraints"></a>5. 设置取值范围：Value Constraints</h3><pre><code>@Size, @IntRange, @FloatRange

private void test(@IntRange(from=0,to=100)int perent){
</code></pre><ul>
<li>集合不能为空: @Size(min=1)</li>
<li>字符串最大只能有23个字符: @Size(max=23)</li>
<li>数组只能有2个元素: @Size(2)</li>
<li>数组的大小必须是2的倍数 (例如图形API中获取位置的x/y坐标数组: @Size(multiple=2)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>android有关gradle的一些配置</title>
    <url>/2019/02/14/android%E6%9C%89%E5%85%B3gradle%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h5 id="gradle使用source-set-的概念，一个source-set就是一系列资源文件，其将会被便衣和执行，对于android项目，main就是一个source-set，其包含了所有的资源文件，相对main测试文件test也是一个source-set，只做测试"><a href="#gradle使用source-set-的概念，一个source-set就是一系列资源文件，其将会被便衣和执行，对于android项目，main就是一个source-set，其包含了所有的资源文件，相对main测试文件test也是一个source-set，只做测试" class="headerlink" title="gradle使用source  set 的概念，一个source  set就是一系列资源文件，其将会被便衣和执行，对于android项目，main就是一个source  set，其包含了所有的资源文件，相对main测试文件test也是一个source  set，只做测试"></a>gradle使用source  set 的概念，一个source  set就是一系列资源文件，其将会被便衣和执行，对于android项目，main就是一个source  set，其包含了所有的资源文件，相对main测试文件test也是一个source  set，只做测试</h5><h3 id="基础命令："><a href="#基础命令：" class="headerlink" title="基础命令："></a>基础命令：</h3><ul>
<li>查看gradle版本 <code>gradlew -v</code></li>
<li>查看所有可运行的tasks<code>gradlew tasks</code></li>
<li>清除目录下的output文件夹 <code>gradlew clean</code></li>
<li>打包编译, 包括debug和release<code>gradlew build</code></li>
<li>编译并打Debug包 <code>gradlew assembleDebug</code></li>
<li>编译并打Release的包 <code>gradlewassembleRelease</code></li>
<li>只打包阿里release版本 <code>gradlew assemblealiRelease</code></li>
<li>关于多moudle <code>gradlew :UpdateAppUtils:assembleDebug</code></li>
<li>帮助 <code>gradlew --help</code></li>
<li>查看编译信息 <code>gradlew build --info</code>或<code>–stacktrace</code></li>
<li>制定module <code>gradlew -p app build</code></li>
</ul>
<a id="more"></a>


<p>打包需要在build配置签名文件以及密码</p>
<pre><code> signingConfigs {
        debug {
            // No debug config
        }

        release {
            storeFile file(&quot;../yourapp.keystore&quot;)
            storePassword &quot;your password&quot;
            keyAlias &quot;your alias&quot;
            keyPassword &quot;your password&quot;
        }
    }</code></pre><h3 id="gradlew配置文件结构和eclipse结构相同"><a href="#gradlew配置文件结构和eclipse结构相同" class="headerlink" title="gradlew配置文件结构和eclipse结构相同"></a>gradlew配置文件结构和eclipse结构相同</h3><pre><code>android {
     sourceSets {
       main {
         manifest.srcFile &#39;AndroidManifest.xml&#39;
         java.srcDirs = [&#39;src&#39;]
         resources.srcDirs = [&#39;src&#39;]
         aidl.srcDirs = [&#39;src&#39;]
         renderscript.srcDirs = [&#39;src&#39;]
         res.srcDirs = [&#39;res&#39;]
         assets.srcDirs = [&#39;assets&#39;]
    }
     androidTest.setRoot(&#39;tests&#39;)
    } 
}</code></pre><p>在grade文件中配置，将会保存eclipse目录结构，如果有依赖的jar包，需要告诉gradle，假设jar包会在一个叫做libs的文件夹内，那么你应该这么配置(现在这条会默认配置)：</p>
<pre><code>dependencies {
       compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
}</code></pre><h3 id="gradle-配置解析："><a href="#gradle-配置解析：" class="headerlink" title="gradle 配置解析："></a>gradle 配置解析：</h3><p>创建一个新的android项目时，会默认生成三个gradle文件</p>
<ul>
<li>project 的build.gradle文件</li>
<li>settings.build文件（声明包含的moudle都有哪些）</li>
<li>默认moudle的App下的build.gradle文件</li>
</ul>
<h4 id="根目录的gradle文件一般如下"><a href="#根目录的gradle文件一般如下" class="headerlink" title="根目录的gradle文件一般如下"></a>根目录的gradle文件一般如下</h4><pre><code>//声明自定义的gradle文件
apply from: &quot;config.gradle&quot;
buildscript {
    repositories {//配置仓库，使用jcenter，现在studio3.0以后默认使用google
        jcenter()
        google()
    }
    dependencies {//配置gradle的插件默认配置gradle，我这里还配置tinker插件，用于热更新
        classpath &#39;com.android.tools.build:gradle:3.0.1&#39;
        classpath &#39;com.tencent.bugly:tinker-support:1.1.1&#39;
        }
}

allprojects {//定义模块默认属性
    repositories {
        jcenter()
        google()
    }
}

task clean(type: Delete) {//我这里配置task clean的时候直接删除项目的build文件夹
    delete rootProject.buildDir
}
</code></pre><h3 id="模块内build-gradle文件"><a href="#模块内build-gradle文件" class="headerlink" title="模块内build.gradle文件"></a>模块内build.gradle文件</h3><p>以下是studio3.0之前的配置，3.0之后稍后改动</p>
<pre><code>//声明模块要使用的插件，默认配置android.application
apply plugin: &#39;com.android.application&#39;
   android {
       compileSdkVersion 22//配置编译app的api版本
       buildToolsVersion &quot;22.0.1&quot;//3.0之后已经去除，不需要再配置
       defaultConfig {
           applicationId &quot;com.gradleforandroid.gettingstarted&quot;//默认对应清单文件里的包名
           minSdkVersion 14//兼容的最小版本号
           targetSdkVersion 22//最适合的版本号
           versionCode 1//版本号标识
           versionName &quot;1.0&quot;//版本名字，一般用于给用户展示，除此没有其他用处
       }
       buildTypes {
           release {
               minifyEnabled false
               proguardFiles getDefaultProguardFile
                (&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
           }
        } 
    }
    dependencies {//3.0以后使用implementation  来代替compile
       compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
       compile &#39;com.android.support:appcompat-v7:22.2.0&#39;
       implementation  &#39;com.android.support:appcompat-v7:22.2.0&#39;

     }</code></pre><h3 id="使用BuildConfig和resources动态配置不同渠道资源"><a href="#使用BuildConfig和resources动态配置不同渠道资源" class="headerlink" title="使用BuildConfig和resources动态配置不同渠道资源"></a>使用BuildConfig和resources动态配置不同渠道资源</h3><p>比如baseUrl</p>
<pre><code>  release {
            //关闭日志输出
            buildConfigField(&quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;)
            //配置默认baseUrl
            buildConfigField(&quot;String&quot;, &quot;SERVER_URL&quot;, rootProject.ext.configs[&#39;releaseUrl&#39;])
            //配置下载地址
            buildConfigField(&quot;String&quot;, &quot;DOWNLOAD_URL&quot;, rootProject.ext.download[&#39;releaseUrl&#39;])
            // 移除无用的resource文件
            shrinkResources true
            //是否混淆
            minifyEnabled true
            //混淆文件(.text处于SDK下面，针对全项目，.pro只针对本项目)
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            //配置签名文件
            signingConfig signingConfigs.sweetorange_sign
        }</code></pre><p>比如app名字：</p>
<pre><code>android {
       buildTypes {
           debug {
               resValue &quot;string&quot;, &quot;app_name&quot;, &quot;我的测试版本&quot;
           }
           release {
               resValue &quot;string&quot;, &quot;app_name&quot;, &quot;我是正式版本&quot;
            } 
       }
}
</code></pre><h3 id="配置全局配置"><a href="#配置全局配置" class="headerlink" title="配置全局配置"></a>配置全局配置</h3><p>关于多moudle开发，方便多人分模块开发，这也是组件化开发的模式，这样每个moudle都会配置各自的build.gradle文件，为了配置统一，一般配置全局配置，让各个moudle去调用</p>
<p>全局配置有两种方法</p>
<ul>
<li>直接在project的build.gradle文件中配置</li>
<li>自定义一个gradle文件，然后再project中声明一下，然后去调用</li>
</ul>
<p>两种方式一样，个人觉得第二种更方便管理</p>
<p>有关第二种：</p>
<ul>
<li>醒目目录改为project，主目录下创建一个.gradle文件名字随便，例如我的config.gradle文件</li>
</ul>
<p>主要是配置了项目所使用到的第三方依赖库，有关依赖哭的混淆可以看我的混淆配置<a href="https://www.jianshu.com/p/181d6f2d5bae" target="_blank" rel="noopener">https://www.jianshu.com/p/181d6f2d5bae</a></p>
<pre><code>ext {

    configs = [//配置baseUrl
            debugUrl  : &#39;&quot;http://111.111.1.111.8080&quot;&#39;,
            releaseUrl: &#39;&quot;https://www.baidu.com&quot;&#39;,
    ]

       android = [compileSdkVersion        : 25,
               applicationId            : &quot;com.sweetorange.read&quot;,
               minSdkVersion            : 16,
               targetSdkVersion         : 25,
               versionCode              : 13,
               versionName              : &quot;1.3&quot;,
               testInstrumentationRunner: &quot;android.support.test.runner.AndroidJUnitRunner&quot;]

    dependencies = [//配置所有的第三方依赖库（不多不多，也就二十个）

            //multidex方法书超过64K
            &quot;multidex&quot;                     : &#39;com.android.support:multidex:1.0.1&#39;,

            //bumptech，用于glide配置okhttp请求
            &quot;bumptech&quot;                     : &#39;com.github.bumptech.glide:okhttp3-integration:1.4.0@aar&#39;,

            //pgyer蒲公英用于测试
            &quot;pgyer&quot;                        : &#39;com.pgyersdk:sdk:2.8.1&#39;,

            //MZBannerView，banner轮播图，用于引导页面
            &quot;MZBannerView&quot;                 : &#39;com.github.pinguo-zhouwei:MZBannerView:v2.0.0&#39;,

            //bugly ，热修复
            &quot;bugly&quot;                        : &#39;com.tencent.bugly:crashreport_upgrade:1.3.4&#39;,

            //微信
            &quot;wechat&quot;                       : &#39;com.tencent.mm.opensdk:wechat-sdk-android-with-mta:1.0.2&#39;,

            //伸缩textView
            &quot;expandableTextView&quot;           : &#39;com.ms-square:expandableTextView:0.1.4&#39;,

            //屏幕适配
            &quot;autolayout&quot;                   : &#39;com.zhy:autolayout:1.4.5&#39;,

            //v7包
            &quot;support_v7&quot;                   : &#39;com.android.support:appcompat-v7:25.3.1&#39;,

            //设置阅读页动画
            &quot;nineoldandroids&quot;              : &#39;com.nineoldandroids:library:2.4.0&#39;,

            //Xutils3用于网络请求
            &quot;xutils&quot;                       : &#39;org.xutils:xutils:3.3.40&#39;,

            //design包
            &quot;support_design&quot;               : &#39;com.android.support:design:25.3.0&#39;,

            //glide
            &quot;glide&quot;                        : &#39;com.github.bumptech.glide:glide:3.7.0&#39;,

            //v4
            &quot;support_v4&quot;                   : &#39;com.android.support:support-v4:25.3.0&#39;,

            //drawable
            &quot;support_drawable&quot;             : &#39;com.android.support:support-vector-drawable:25.1.0&#39;,

            //eventbus
            &quot;eventbus&quot;                     : &#39;org.greenrobot:eventbus:3.0.0&#39;,

            //fastJson
            &quot;fastjson&quot;                     : &#39;com.alibaba:fastjson:1.2.23&#39;,

            //litepal
            &quot;litepal&quot;                      : &#39;org.litepal.android:core:1.5.1&#39;,

            //circleimageview
            &quot;circleimageview&quot;              : &#39;de.hdodenhof:circleimageview:2.1.0&#39;,

            //klog
            &quot;klog&quot;                         : &#39;com.github.zhaokaiqiang.klog:library:1.5.0&#39;,

            //Luban
            &quot;Luban&quot;                        : &#39;top.zibin:Luban:1.1.3&#39;,

            //jsoup
            &quot;jsoup&quot;                        : &#39;org.jsoup:jsoup:1.10.2&#39;,

            //permission
            &quot;permission&quot;                   : &#39;com.yanzhenjie:permission:1.0.7&#39;,

            //album
            &quot;album&quot;                        : &#39;com.yanzhenjie:album:1.0.7&#39;,

            //constraint-layout
            &quot;constraint_layout&quot;            : &#39;com.android.support.constraint:constraint-layout:1.0.0-alpha8&#39;,

            //BaseRecyclerViewAdapterHelper
            &quot;BaseRecyclerViewAdapterHelper&quot;: &#39;com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.18&#39;,

            //badgeview
            &quot;badgeview&quot;                    : &#39;q.rorbin:badgeview:1.1.2&#39;,

            //butterknife
            &quot;butterknife&quot;                  : &#39;com.jakewharton:butterknife:8.7.0&#39;,

            //butterknife
            &quot;butterknife_two&quot;              : &#39;com.jakewharton:butterknife-compiler:8.7.0&#39;,

            //lombok
            &quot;lombok&quot;                       : &#39;org.projectlombok:lombok:1.16.18&#39;,

            //nohttp
            &quot;nohttp&quot;                       : &#39;com.yanzhenjie.nohttp:nohttp:1.1.4&#39;,

            //junit
            &quot;junit&quot;                        : &#39;junit:junit:4.12&#39;,

            //okhttp
            &quot;okhttp&quot;                       : &#39;com.yanzhenjie.nohttp:okhttp:1.1.4&#39;,

            //添加注解，配合lombok
            &quot;annotation&quot;                   : &#39;org.glassfish:javax.annotation:10.0-b28&#39;,

            &quot;SmartRefreshLayout&quot;           : &#39;com.scwang.smartrefresh:SmartRefreshLayout:1.0.3&#39;,
            &quot;SmartRefreshHeader&quot;           : &#39;com.scwang.smartrefresh:SmartRefreshHeader:1.0.3&#39;,
    ]
}</code></pre><h3 id="使用全局配置"><a href="#使用全局配置" class="headerlink" title="使用全局配置"></a>使用全局配置</h3><p>主项目build文件声明自定义的build文件</p>
<pre><code>apply from: &quot;config.gradle&quot;</code></pre><p>在moudle中使用</p>
<pre><code>apply plugin: &#39;com.android.application&#39;

// 依赖插件脚本
apply from: &#39;tinker-support.gradle&#39;

android {

    //项目编译版本
    compileSdkVersion rootProject.ext.android.compileSdkVersion
    defaultConfig {
        //项目包名
        applicationId rootProject.ext.android.applicationId
        //最低兼容
        minSdkVersion rootProject.ext.android.minSdkVersion
        //最佳使用版本
        targetSdkVersion rootProject.ext.android.targetSdkVersion
        //版本号
        versionCode rootProject.ext.android.versionCode
        //版本名
        versionName rootProject.ext.android.versionName
        testInstrumentationRunner rootProject.ext.android.testInstrumentationRunner
        vectorDrawables.useSupportLibrary = true
        multiDexEnabled true
        flavorDimensions &quot;versionCode&quot;
    }
    buildTypes {
        release {
            //关闭日志输出
            buildConfigField(&quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;)
            //配置默认baseUrl
            buildConfigField(&quot;String&quot;, &quot;SERVER_URL&quot;, rootProject.ext.configs[&#39;releaseUrl&#39;])
            //配置下载地址
            buildConfigField(&quot;String&quot;, &quot;DOWNLOAD_URL&quot;, rootProject.ext.download[&#39;releaseUrl&#39;])
            // 移除无用的resource文件
            shrinkResources true
            //是否混淆
            minifyEnabled true
            //混淆文件(.text处于SDK下面，针对全项目，.pro只针对本项目)
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
           }

        debug {
            buildConfigField(&quot;String&quot;, &quot;SERVER_URL&quot;, rootProject.ext.configs[&#39;debugUrl&#39;])
            minifyEnabled true
            //混淆文件(.text处于SDK下面，针对全项目，.pro只针对本项目)
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            buildConfigField(&quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;)
            //配置下载地址
            buildConfigField(&quot;String&quot;, &quot;DOWNLOAD_URL&quot;, rootProject.ext.download[&#39;debugUrl&#39;])
            }
    }

    //配置多渠道包
    productFlavors {
        huawei {}
        xiaomi {}
        qh360 {}
        baidu {}
    }

     //使用友盟多渠道打包替换
    productFlavors.all {
        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
    }

    //layout文件分包
    sourceSets {
        main {
            res.srcDirs =
                    [
                            &#39;src/main/res/layouts/activities&#39;,
                            &#39;src/main/res/layouts/dialogs&#39;,
                            &#39;src/main/res/layouts/fragments&#39;,
                            &#39;src/main/res/layouts/headviews&#39;,
                            &#39;src/main/res/layouts/items&#39;,
                            &#39;src/main/res/layouts/views&#39;,
                            &#39;src/main/res/layouts&#39;,
                            &#39;src/main/res&#39;
                    ]
        }
    }

    //配置使用lambda表达式
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

//配置仓库，可以使用全局配置，默认jcenter，3.0以后默认google
allprojects {
    repositories {
        jcenter()
        maven { url &quot;https://jitpack.io&quot; }
        maven { url &quot;https://raw.githubusercontent.com/Pgyer/mvn_repo_pgyer/master&quot; }

    }
}

dependencies {
    implementation fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    androidTestImplementation(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, {
        exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;
    })
    implementation files(&#39;libs/alipaySdk-20170309.jar&#39;)
    implementation project(&#39;:sharelibrary&#39;)
    implementation project(&#39;:UpdateAppUtils&#39;)
    implementation rootProject.ext.dependencies.pgyer
    implementation rootProject.ext.dependencies.bumptech
    implementation rootProject.ext.dependencies.wechat
    implementation rootProject.ext.dependencies.MZBannerView
    implementation rootProject.ext.dependencies.expandableTextView
    implementation rootProject.ext.dependencies.autolayout
    implementation rootProject.ext.dependencies.support_v7
    implementation rootProject.ext.dependencies.nineoldandroids
    implementation rootProject.ext.dependencies.xutils
    implementation rootProject.ext.dependencies.support_design
    implementation rootProject.ext.dependencies.glide
    implementation rootProject.ext.dependencies.support_v4
    implementation rootProject.ext.dependencies.support_drawable
    implementation rootProject.ext.dependencies.eventbus
    implementation rootProject.ext.dependencies.fastjson
    implementation rootProject.ext.dependencies.litepal
    implementation rootProject.ext.dependencies.circleimageview
    implementation rootProject.ext.dependencies.klog
    implementation rootProject.ext.dependencies.Luban
    implementation rootProject.ext.dependencies.jsoup
    implementation rootProject.ext.dependencies.permission
    implementation rootProject.ext.dependencies.album
    implementation rootProject.ext.dependencies.constraint_layout
    implementation rootProject.ext.dependencies.BaseRecyclerViewAdapterHelper
    implementation rootProject.ext.dependencies.badgeview
    implementation rootProject.ext.dependencies.butterknife
    annotationProcessor rootProject.ext.dependencies.butterknife_two
    implementation rootProject.ext.dependencies.lombok
    annotationProcessor rootProject.ext.dependencies.lombok
    implementation rootProject.ext.dependencies.nohttp
    implementation rootProject.ext.dependencies.okhttp
    testImplementation rootProject.ext.dependencies.junit
    provided rootProject.ext.dependencies.annotation
    implementation rootProject.ext.dependencies.SmartRefreshLayout
    implementation rootProject.ext.dependencies.SmartRefreshHeader
    implementation rootProject.ext.dependencies.bugly
    implementation rootProject.ext.dependencies.multidex
    implementation project(&#39;:PushSDK&#39;)
    implementation files(&#39;libs/umeng-analytics-7.4.0.jar&#39;)
    implementation files(&#39;libs/umeng-common-1.4.0.jar&#39;)
}
</code></pre><h3 id="gradle的以依赖管理"><a href="#gradle的以依赖管理" class="headerlink" title="gradle的以依赖管理"></a>gradle的以依赖管理</h3><p>gradle支持三种仓库</p>
<ul>
<li>Maven</li>
<li>lvy</li>
<li>文件夹</li>
</ul>
<p>一个依赖需要三个元素：</p>
<ul>
<li>group——组织名字</li>
<li>name——库名字</li>
<li>version—-库版本</li>
</ul>
<p>例如：</p>
<pre><code>implementation &#39;com.github.ALguojian:SpannableHelper:1.0&#39;</code></pre><p>gradle使用groovy编写，完整表述如下：</p>
<pre><code>implementation group: &#39;com.github.ALguojian&#39; , name: &#39;SpannableHelper&#39; , version: &#39;1.0&#39;</code></pre><p>有关公司私人权限仓库配置：</p>
<pre><code>repositories {
       maven {
           url &quot;http://repo.acmecorp.com/maven2&quot;
           credentials {
               username &#39;user&#39;
               password &#39;secretpassword&#39;
           }
        } 
</code></pre><p>建议有关密码都配置在gradle.properties文件中，并添加到忽略文件</p>
<pre><code># 应用版本名称
VERSION_NAME=1.0.0
# 应用版本号
VERSION_CODE=100</code></pre><p>使用如下：</p>
<pre><code>android {
    compileSdkVersion project.ANDROID_BUILD_SDK_VERSION as int
    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION

    defaultConfig {
        versionCode project.VERSION_CODE as int
        versionName project.VERSION_NAME
        minSdkVersion project.ANDROID_BUILD_MIN_SDK_VERSION as int
        targetSdkVersion project.ANDROID_BUILD_TARGET_SDK_VERSION as int
    }
}</code></pre><h4 id="添加so包如下："><a href="#添加so包如下：" class="headerlink" title="添加so包如下："></a>添加so包如下：</h4><p>用c或者c++写的library叫做so包，android插件默认是支持的，需要把so文件放在对应文件夹中</p>
<pre><code>app
   ├── AndroidManifest.xml
   └── jniLibs
       ├── armeabi
       │   └── nativelib.so
       ├── armeabi-v7a
       │   └── nativelib.so
       ├── mips
       │   └── nativelib.so
       └── x86
           └── nativelib.so</code></pre><p>被依赖的moudle编译之后会生成aar文件，使用aar文件和jar相同</p>
<p>关于以来的配置：</p>
<ul>
<li>implementation 其含义是包含所有的依赖包，即在APK里，implementation 的依赖会存在。</li>
<li>Runtime only 仅仅编译是使用</li>
<li>testImplementation 添加额外的library支持针对测试</li>
<li>androidTestCompile添加额外的library支持针对测试</li>
<li>Debug implementation 针对不同的渠道配置</li>
</ul>
<h3 id="关于配置多版本"><a href="#关于配置多版本" class="headerlink" title="关于配置多版本"></a>关于配置多版本</h3><p>buildTypes下面配置多渠道配置：</p>
<pre><code>android {
    buildTypes {
        alguojain{
            applicationIdSuffix &quot;.alguojain&quot;
            versionNameSuffix &quot;-alguojain&quot;
            buildConfigField &quot;String&quot;，&quot;API_URL&quot;，&quot;\&quot;http://alguojain.com&quot;\&quot;
         }
    }
}</code></pre><h3 id="关于配制多渠道-product-flavors"><a href="#关于配制多渠道-product-flavors" class="headerlink" title="关于配制多渠道 product flavors"></a>关于配制多渠道 product flavors</h3><pre><code>android {

    flavorDimensions &quot;123&quot;, &quot;456&quot;
    productFlavors {
        aaa{
             applicationId &#39;com.alguojian.aaa&#39;
              flavorDimension &quot;123&quot;
             versionCode 3
        }
        bbb{
             flavorDimension &quot;456&quot;
             applicationId &#39;com.alguojian.bbb&#39;
             minSdkVersion 14
             versionCode 4
        }
    }
}</code></pre><h4 id="配置渠道过滤器"><a href="#配置渠道过滤器" class="headerlink" title="配置渠道过滤器"></a>配置渠道过滤器</h4><pre><code>android.variantFilter { variant -&gt;
       if(variant.buildType.name.equals(&#39;release&#39;)) {
           variant.getFlavors().each() { flavor -&gt;
               if (flavor.name.equals(tbl)) { variant.setIgnore(true);
            }
        }
    }
}</code></pre><h3 id="配置多版本的签名文件"><a href="#配置多版本的签名文件" class="headerlink" title="配置多版本的签名文件"></a>配置多版本的签名文件</h3><p>有关签名，debug版本shistudio默认的签名，使用的是公共的签名文件，下面alguojian版本使用initWith方法是使用debug版本的配置</p>
<pre><code>android {
       signingConfigs {

           alguojian.initWith(signingConfigs.debug)

           release {
               storeFile file(&quot;release.keystore&quot;)
               storePassword&quot;secretpassword&quot;
               keyAlias &quot;gradleforandroid&quot;
               keyPassword &quot;secretpassword&quot;
           }
      }
}</code></pre><h3 id="针对不同版本不同渠道配置不同签名"><a href="#针对不同版本不同渠道配置不同签名" class="headerlink" title="针对不同版本不同渠道配置不同签名"></a>针对不同版本不同渠道配置不同签名</h3><pre><code>android {
       buildTypes {
           release {
               productFlavors.red.signingConfig signingConfigs.aaa
               productFlavors.blue.signingConfig signingConfigs.bbb
           }
       }
}</code></pre><h3 id="多moudle开启多线程构建（电脑内存要大，要大，要大！！！）"><a href="#多moudle开启多线程构建（电脑内存要大，要大，要大！！！）" class="headerlink" title="多moudle开启多线程构建（电脑内存要大，要大，要大！！！）"></a>多moudle开启多线程构建（电脑内存要大，要大，要大！！！）</h3><p>需要在grade.properties文件中配置如下属性：</p>
<pre><code>
org.gradle.parallel=true
</code></pre><h3 id="自定义gradle插件，待定，正在学习grovvy"><a href="#自定义gradle插件，待定，正在学习grovvy" class="headerlink" title="自定义gradle插件，待定，正在学习grovvy"></a>自定义gradle插件，待定，正在学习grovvy</h3>]]></content>
  </entry>
  <entry>
    <title>项目用到的库以及配置的混淆文件</title>
    <url>/2019/02/12/%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E7%9A%84%E5%BA%93%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B7%B7%E6%B7%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p> //生命声明本地依赖<br>    compile fileTree(include: [‘*.jar’], dir: ‘libs’)<br>    //声明测试用例库<br>    androidTestCompile(‘com.android.support.test.espresso:espresso-core:2.2.2’, {<br>        exclude group: ‘com.android.support’, module: ‘support-annotations’<br>    })<br>    //支付宝支付<br>    compile files(‘libs/alipaySdk-20170309.jar’)<br>    //MOB分享<br>    compile project(‘:sharelibrary’)<br>    //微信SDK<br>    compile ‘com.tencent.mm.opensdk:wechat-sdk-android-with-mta:1.0.2’<br>    //可以伸缩的TextView<br>    compile ‘com.ms-square:expandableTextView:0.1.4’<br>    //屏幕适配<br>    compile ‘com.zhy:autolayout:1.4.5’<br>    compile ‘com.android.support:appcompat-v7:25.3.1’<br>    //设置阅读页动画<br>    compile ‘com.nineoldandroids:library:2.4.0’<br>    //Xutils3用于网络请求<br>    compile ‘org.xutils:xutils:3.3.40’<br>    compile ‘com.android.support:design:25.3.0’<br>    //加载图片<br>    compile ‘com.github.bumptech.glide:glide:3.7.0’<br>    compile ‘com.android.support:support-v4:25.3.0’<br>    compile ‘com.android.support:support-vector-drawable:25.1.0’<br>    //项目内部传递消息<br>    compile ‘org.greenrobot:eventbus:3.0.0’<br>    //json解析<br>    compile ‘com.alibaba:fastjson:1.2.23’<br>    //数据库<br>    compile ‘org.litepal.android:core:1.5.1’<br>    //圆角图片<br>    compile ‘de.hdodenhof:circleimageview:2.1.0’<br>    //log打印<br>    compile ‘com.github.zhaokaiqiang.klog:library:1.5.0’<br>    //图片压缩<br>    compile ‘top.zibin:Luban:1.1.3’<br>    //html<br>    compile ‘org.jsoup:jsoup:1.10.2’<br>    //友盟统计<br>    compile ‘com.umeng.analytics:analytics:latest.integration’<br>    //权限管理<br>    compile ‘com.yanzhenjie:permission:1.0.7’<br>    //相册<br>    compile ‘com.yanzhenjie:album:1.0.7’<br>    //拖拽布局<br>    compile ‘com.android.support.constraint:constraint-layout:1.0.0-alpha8’<br>    //RecyclerView适配器<br>    compile ‘com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.18’<br>    //轮播<br>    compile ‘com.github.pinguo-zhouwei:MZBannerView:v1.1.0’<br>    //高亮引导<br>    compile ‘com.isanwenyu.highlight:highlight:1.8.0’<br>    //动态生成小红点<br>    compile ‘q.rorbin:badgeview:1.1.2’<br>    //绑定View<br>    compile ‘com.jakewharton:butterknife:8.7.0’<br>    //生成git和set方法<br>    compile ‘org.projectlombok:lombok:1.16.18’<br>    annotationProcessor “org.projectlombok:lombok:1.16.18”<br>    //数据请求<br>    compile ‘com.yanzhenjie.nohttp:nohttp:1.1.4’<br>    compile ‘com.yanzhenjie.nohttp:okhttp:1.1.4’<br>    testCompile ‘junit:junit:4.12’<br>    annotationProcessor ‘com.jakewharton:butterknife-compiler:8.7.0’<br>    provided ‘org.glassfish:javax.annotation:10.0-b28’<br>    //更新下载安装<br>    compile project(‘:UpdateAppUtils’)</p>
<pre><code>
&lt;!--more--&gt;


#实体类

-keep class com.sweetorange.read.bean.** { *; }


#保护注解
-keepattributes *Annotation*
-keepattributes Signature


-ignorewarnings


#第三方包

#jsoup
-keeppackagenames org.jsoup.nodes

#MOB
-keep class cn.sharesdk.**{*;}
-keep class com.sina.**{*;}
-keep class **.R$* {*;}
-keep class **.R{*;}
-keep class com.mob.**{*;}
-dontwarn com.mob.**
-dontwarn cn.sharesdk.**
-dontwarn **.R$*

#butterknife
-keep class butterknife.** { *; }
-dontwarn butterknife.internal.**
-keep class **$$ViewBinder { *; }
-keepclasseswithmembernames class * {
    @butterknife.* &lt;fields&gt;;
}
-keepclasseswithmembernames class * {
    @butterknife.* &lt;methods&gt;;
}

#eventBus
-keepclassmembers class ** {
    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;
}
-keep enum org.greenrobot.eventbus.ThreadMode { *; }
-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {
    &lt;init&gt;(java.lang.Throwable);
}

#glide
-keep public class * implements com.bumptech.glide.module.GlideModule
-keep public class * extends com.bumptech.glide.module.AppGlideModule
-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {
  **[] $VALUES;
  public *;
}

#album相册
-dontwarn com.yanzhenjie.album.**
-keep class com.yanzhenjie.album.**{*;}

-dontwarn com.yanzhenjie.fragment.**
-keep class com.yanzhenjie.fragment.**{*;}

-dontwarn com.yanzhenjie.mediascanner.**
-keep class com.yanzhenjie.mediascanner.**{*;}

-dontwarn com.yanzhenjie.loading.**
-keep class com.yanzhenjie.loading.**{*;}

-dontwarn com.yanzhenjie.statusview.**
-keep class com.yanzhenjie.statusview.**{*;}

# permission权限管理
-keepclassmembers class ** {
    @com.yanzhenjie.permission.PermissionYes &lt;methods&gt;;
}
-keepclassmembers class ** {
    @com.yanzhenjie.permission.PermissionNo &lt;methods&gt;;
}

#brvah
-keep class com.chad.library.adapter.** {
*;
}
-keep public class * extends com.chad.library.adapter.base.BaseQuickAdapter
-keep public class * extends com.chad.library.adapter.base.BaseViewHolder
-keepclassmembers  class **$** extends com.chad.library.adapter.base.BaseViewHolder {
     &lt;init&gt;(...);
}

#nohttp

-dontwarn com.yanzhenjie.nohttp.**
-keep class com.yanzhenjie.nohttp.**{*;}

#okhttp3
-dontwarn okhttp3.**
-keep class okhttp3.** {*;}
-dontwarn okio.**
-keep class okio.** {*;}

#fastJson
-keep class javax.ws.rs.** { *; }
-dontwarn com.alibaba.fastjson.**
-keep class com.alibaba.fastjson.** { *; }

#支付宝支付
-keep class com.alipay.android.app.IAlixPay{*;}
-keep class com.alipay.android.app.IAlixPay$Stub{*;}
-keep class com.alipay.android.app.IRemoteServiceCallback{*;}
-keep class com.alipay.android.app.IRemoteServiceCallback$Stub{*;}
-keep class com.alipay.sdk.app.PayTask{ public *;}
-keep class com.alipay.sdk.app.AuthTask{ public *;}
-keep class com.alipay.sdk.app.H5PayCallback {
    &lt;fields&gt;;
    &lt;methods&gt;;
}
-keep class com.alipay.android.phone.mrpc.core.** { *; }
-keep class com.alipay.apmobilesecuritysdk.** { *; }
-keep class com.alipay.mobile.framework.service.annotation.** { *; }
-keep class com.alipay.mobilesecuritysdk.face.** { *; }
-keep class com.alipay.tscenter.biz.rpc.** { *; }
-keep class org.json.alipay.** { *; }
-keep class com.alipay.tscenter.** { *; }
-keep class com.ta.utdid2.** { *;}
-keep class com.ut.device.** { *;}
-dontwarn android.net.**
-keep class android.net.SSLCertificateSocketFactory{*;}

#方法数量超过64K
-keepattributes EnclosingMethod

#微信登录分享以及支付
-keep class com.tencent.mm.opensdk.** { *;}
-keep class com.tencent.wxop.** {*;}
-keep class com.tencent.mm.sdk.** {*;}
-dontwarn com.tencent.mm.**
-dontwarn com.tencent.wxop.stat.**
-keep class com.tencent.mm.** {*;}
-keep class com.tencent.wxop.stat.**{*;}

#litepal
-dontwarn org.litepal.*
-keep class org.litepal.** { *; }
-keep enum org.litepal.**
-keep interface org.litepal.** { *; }
-keep public class * extends org.litepal.**
-keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

#新浪微博
 -keep class com.sina.weibo.sdk.* { *; }
-keep class android.support.v4.* { *; }
-keep class com.tencent.* { *; }
-keep class com.baidu.* { *; }
-keep class lombok.ast.ecj.* { *; }
-dontwarn android.support.v4.**
-dontwarn com.tencent.**s
-dontwarn com.baidu.**


#Rxandroid
-dontwarn sun.misc.**
-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* {
    long producerIndex;
    long consumerIndex;
}
-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef {
    rx.internal.util.atomic.LinkedQueueNode producerNode;
}
-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef {
    rx.internal.util.atomic.LinkedQueueNode consumerNode;
}

#友盟统计
# 友盟统计分析
-keepclassmembers class * { public &lt;init&gt;(org.json.JSONObject); }
-keepclassmembers enum com.umeng.analytics.** {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

-dontshrink
-dontoptimize
-dontwarn com.google.android.maps.**
-dontwarn android.webkit.WebView
-dontwarn com.umeng.**
-dontwarn com.tencent.weibo.sdk.**
-dontwarn com.facebook.**
-keep public class javax.**
-keep public class android.webkit.**
-dontwarn android.support.v4.**
-keep enum com.facebook.**
-keepattributes Exceptions,InnerClasses,Signature
-keepattributes *Annotation*
-keepattributes SourceFile,LineNumberTable

-keep public interface com.facebook.**
-keep public interface com.tencent.**
-keep public interface com.umeng.socialize.**
-keep public interface com.umeng.socialize.sensor.**
-keep public interface com.umeng.scrshot.**

-keep public class com.umeng.socialize.* {*;}


-keep class com.facebook.**
-keep class com.facebook.** { *; }
-keep class com.umeng.scrshot.**
-keep public class com.tencent.** {*;}
-keep class com.umeng.socialize.sensor.**
-keep class com.umeng.socialize.handler.**
-keep class com.umeng.socialize.handler.*
-keep class com.umeng.weixin.handler.**
-keep class com.umeng.weixin.handler.*
-keep class com.umeng.qq.handler.**
-keep class com.umeng.qq.handler.*
-keep class UMMoreHandler{*;}
-keep class com.tencent.mm.sdk.modelmsg.WXMediaMessage {*;}
-keep class com.tencent.mm.sdk.modelmsg.** implements com.tencent.mm.sdk.modelmsg.WXMediaMessage$IMediaObject {*;}
-keep class im.yixin.sdk.api.YXMessage {*;}
-keep class im.yixin.sdk.api.** implements im.yixin.sdk.api.YXMessage$YXMessageData{*;}
-keep class com.tencent.mm.sdk.** {
   *;
}
-keep class com.tencent.mm.opensdk.** {
   *;
}
-keep class com.tencent.wxop.** {
   *;
}
-keep class com.tencent.mm.sdk.** {
   *;
}
-dontwarn twitter4j.**
-keep class twitter4j.** { *; }

-keep class com.tencent.** {*;}
-dontwarn com.tencent.**
-keep class com.kakao.** {*;}
-dontwarn com.kakao.**
-keep public class com.umeng.com.umeng.soexample.R$*{
    public static final int *;
}
-keep public class com.linkedin.android.mobilesdk.R$*{
    public static final int *;
}
-keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

-keep class com.tencent.open.TDialog$*
-keep class com.tencent.open.TDialog$* {*;}
-keep class com.tencent.open.PKDialog
-keep class com.tencent.open.PKDialog {*;}
-keep class com.tencent.open.PKDialog$*
-keep class com.tencent.open.PKDialog$* {*;}
-keep class com.umeng.socialize.impl.ImageImpl {*;}
-keep class com.sina.** {*;}
-dontwarn com.sina.**
-keep class  com.alipay.share.sdk.** {
   *;
}

-keepnames class * implements android.os.Parcelable {
    public static final ** CREATOR;
}

-keep class com.linkedin.** { *; }
-keep class com.android.dingtalk.share.ddsharemodule.** { *; }
-keepattributes Signature




#js互相调用

-keep class com.sweetorange.read.utils.WebViewSettingsUtils



#基本默认混淆

#代码混淆压缩比，在0~7之间，默认为5，
-optimizationpasses 5

# 指定不去忽略非公共库的类成员
-dontskipnonpubliclibraryclassmembers

-printmapping proguardMapping.txt

 #不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。
-dontpreverify

-optimizations !code/simplification/cast,!field/*,!class/merging/*
-keepattributes *Annotation*,InnerClasses
-keepattributes Signature
-keepattributes SourceFile,LineNumberTable
#----------------------------------------------------------------------------

#---------------------------------默认保留区---------------------------------
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingService
-keep class android.support.** {*;}
# 保留继承的
-keep public class * extends android.support.v4.**
-keep public class * extends android.support.v7.**
-keep public class * extends android.support.annotation.**
-keep public class * extends android.view.View{
    *** get*();
    void set*(***);
    public &lt;init&gt;(android.content.Context);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclasseswithmembers class * {
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

# 保留R下面的资源
-keep class **.R$* {
 *;
}
-keepclassmembers class * {
    void *(**On*Event);
}

#---------------------------------webview------------------------------------
-keepclassmembers class fqcn.of.javascript.interface.for.Webview {
   public *;
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, jav.lang.String);
}

</code></pre>]]></content>
  </entry>
  <entry>
    <title>泛型学习笔记</title>
    <url>/2019/02/10/%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h4><p>泛型就是参数化类型，可以将类型当作参数传递给一个类或者是方法。</p>
<pre><code>public class Cache {
    Object value;

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
}</code></pre><a id="more"></a>


<p>假设 Cache 能够存取任何类型的值：</p>
<pre><code>Cache cache = new Cache();
cache.setValue(134);
int value = (int) cache.getValue();
cache.setValue(&quot;hello&quot;);
String value1 = (String) cache.getValue();</code></pre><p>使用泛型：</p>
<pre><code>public class Cache&lt;T&gt; {
    T value;

    public Object getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

}</code></pre><pre><code>Cache&lt;String&gt; cache1 = new Cache&lt;String&gt;();
cache1.setValue(&quot;123&quot;);
String value2 = cache1.getValue();

Cache&lt;Integer&gt; cache2 = new Cache&lt;Integer&gt;();
cache2.setValue(456);
int value3 = cache2.getValue();</code></pre><p>泛型除了可以将类型参数化外，而参数一旦确定好，如果类似不匹配，编译器就不通过。 </p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol>
<li><p>与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</p>
</li>
<li><p>当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。</p>
</li>
<li><p>泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 Cache<string> 这个类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。</string></p>
</li>
</ol>
<h3 id="泛型的定义和使用"><a href="#泛型的定义和使用" class="headerlink" title="泛型的定义和使用"></a>泛型的定义和使用</h3><p>泛型安扎使用情况可以分为3种。</p>
<ol>
<li><p><strong>泛型类</strong></p>
</li>
<li><p><strong>泛型方法</strong></p>
</li>
<li><p><strong>泛型接口</strong></p>
</li>
</ol>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>简单定义一个泛型类</p>
<pre><code>public class Test&lt;T&gt; {
    T field1;
}</code></pre><p>尖括号 &lt;&gt; 中的 T 被称作是类型参数，用于指代任何类型。事实上，T只是一种习惯性写法，如果你愿意。你可以这样写。</p>
<pre><code>public class Test&lt;Hello&gt; {
    Hello field1;
}</code></pre><p>但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如： </p>
<ol>
<li><strong>T</strong> 代表一般的任何类。 </li>
<li><strong>E</strong> 代表 Element 的意思，或者 Exception 异常的意思。 </li>
<li><strong>K</strong> 代表 Key 的意思。 </li>
<li><strong>V</strong> 代表 Value 的意思，通常与 K 一起配合使用。 </li>
<li><strong>S</strong> 代表 Subtype 的意思，文章后面部分会讲解示意。</li>
</ol>
<p>如果一个类被 <code>&lt;T&gt;</code> 的形式定义，那么它就被称为是泛型类。</p>
<p>泛型类的使用：</p>
<pre><code>Test&lt;String&gt; test1 = new Test&lt;&gt;();
Test&lt;Integer&gt; test2 = new Test&lt;&gt;();</code></pre><p>对泛型类创建实例的时候，在尖括号中赋值相应的类型便是。T 就会被替换成对应的类型，如 String 或者是 Integer。当一个泛型类被创建时，内部自动扩展成下面的代码。</p>
<pre><code>public class Test&lt;String&gt; {
    String field1;
}
</code></pre><p>泛型类还可以这样接受多个类型参数。</p>
<pre><code>public class MultiType &lt;E,T&gt;{
    E value1;
    T value2;

    public E getValue1(){
        return value1;
    }

    public T getValue2(){
        return value2;
    }
}
</code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><pre><code>public class Test1 {

    public &lt;T&gt; void testMethod(T t){

    }
}
</code></pre><p>泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。<t> 中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。</t></p>
<p>当然，声明的类型参数，其实也是可以当作返回值的类型的。</p>
<pre><code>public  &lt;T&gt; T testMethod1(T t){
        return null;
}</code></pre><h4 id="泛型类与泛型方法共存"><a href="#泛型类与泛型方法共存" class="headerlink" title="泛型类与泛型方法共存"></a>泛型类与泛型方法共存</h4><pre><code>public class Test1&lt;T&gt;{

    public  void testMethod(T t){
        System.out.println(t.getClass().getName());
    }
    public  &lt;T&gt; T testMethod1(T t){
        return t;
    }
}</code></pre><p>上面代码中，Test1<t> 是泛型类，testMethod 是泛型类中的普通方法，而 testMethod1 是一个泛型方法。而泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的，<strong>泛型方法始终以自己定义的类型参数为准</strong>。</t></p>
<p>所以，针对上面的代码，我们可以这样编写测试代码。</p>
<pre><code>Test1&lt;String&gt; t = new Test1();
t.testMethod(&quot;generic&quot;);
Integer i = t.testMethod1(new Integer(1));</code></pre><p>避免混淆，如果在一个泛型类中存在泛型方法，那么两者的类型参数最好不要同名。比如，Test1<t> 代码可以更改为这样</t></p>
<pre><code>public class Test1&lt;T&gt;{

    public  void testMethod(T t){
        System.out.println(t.getClass().getName());
    }
    public  &lt;E&gt; E testMethod1(E e){
        return e;
    }
}</code></pre><h3 id="泛型接口和泛型类类似"><a href="#泛型接口和泛型类类似" class="headerlink" title="泛型接口和泛型类类似"></a>泛型接口和泛型类类似</h3><pre><code>public interface Iterable&lt;T&gt; {
}</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符  ?"></a>通配符  ?</h3><p>除了用 <code>&lt;T&gt;</code> 表示泛型外，还有 <code>&lt;?&gt;</code> 这种形式。<code>？</code> 被称为通配符。</p>
<pre><code>class Base{}

class Sub extends Base{}

Sub sub = new Sub();
Base base = sub;            </code></pre><p>上面代码显示，Base 是 Sub 的父类，它们之间是继承关系，所以 Sub 的实例可以给一个 Base 引用赋值，那么</p>
<pre><code>List&lt;Sub&gt; lsub = new ArrayList&lt;&gt;();
List&lt;Base&gt; lbase = lsub;</code></pre><p>Sub 是 Base 的子类，不代表 <code>List&lt;Sub&gt;</code> 和 <code>List&lt;Base&gt;</code> 有继承关系。</p>
<h4 id="通配符有-3-种形式。"><a href="#通配符有-3-种形式。" class="headerlink" title="通配符有 3 种形式。"></a>通配符有 3 种形式。</h4><pre><code>1. &lt;?&gt; 被称作无限定的通配符。

2. &lt;? extends T&gt; 被称作有上限的通配符。

3. &lt;? super T&gt; 被称作有下限的通配符。</code></pre><h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><pre><code>public void testWildCards(Collection&lt;?&gt; collection){
}</code></pre><p>上面的代码中，方法内的参数是被无限定通配符修饰的Collection对象，它隐略地表达了一个意图或者可以说是限定，那就是 testWidlCards()这个方法内部无需关注Collection中的真实类型，因为它是未知的。所以只能调用 Collection 中与类型无关的方法。 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-d7f2f18a8882fe3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<pre><code>我们可以看到，当 &lt;?&gt; 存在时，Collection 对象丧失了 add() 方法的功能，编译器不通过。 </code></pre><p>在看如下代码</p>
<pre><code>List&lt;?&gt; wildlist = new ArrayList&lt;String&gt;();
wildlist.add(123);// 编译不通过</code></pre><p>有人说，&lt;?&gt; 提供了只读的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能。它不管装载在这个容器内的元素是什么类型，它只关心元素的数量、容器是否为空？</p>
<h4 id="lt-extends-T-gt"><a href="#lt-extends-T-gt" class="headerlink" title="&lt;? extends T&gt;"></a><code>&lt;? extends T&gt;</code></h4><p><code>&lt;?&gt;</code> 代表着类型未知，但是我们的确需要对于类型的描述再精确一点，我们希望在一个范围内确定类别，比如类型 A 及 类型 A 的子类都可以。</p>
<pre><code>public void testSub(Collection&lt;? extends Base&gt; para){

}</code></pre><p>上面代码中，para这个collection接收Base及Base的之类的类型</p>
<p>但是，它仍然丧失了写操作的能力。也就是说</p>
<pre><code>para.add(new Sub());//失败
para.add(new Base());//失败</code></pre><p>仍然是编译不通过的，因为para是继承自base的一个子类（现在并不清楚具体是什么）</p>
<h4 id="lt-super-T-gt"><a href="#lt-super-T-gt" class="headerlink" title="&lt;? super T&gt;"></a><code>&lt;? super T&gt;</code></h4><p>这个和<code>&lt;? extends T&gt;</code>相对应，代表T以及T的超类</p>
<pre><code>public void testSuper(Collection&lt;? super Sub&gt; para){
}</code></pre><p><code>&lt;? super T&gt;</code>神奇的地方在于，它拥有一定程度的写操作的能力</p>
<pre><code> public void testSuper(Collection&lt;? super Sub&gt; para){
    para.add(new Sub());//编译通过，para是sub的一个父类，可以将子类对象引用给他，实际就是java的多态（性质相同）
    para.add(new Base());//编译不通过
}</code></pre><h4 id="通配符与参数类型的区别"><a href="#通配符与参数类型的区别" class="headerlink" title="通配符与参数类型的区别"></a>通配符与参数类型的区别</h4><p>一般而言，通配符能干的事情可以用类型参数替换</p>
<p>比如</p>
<p><code>public void testWildCards(Collection&lt;?&gt; collection){}</code></p>
<p>可以被</p>
<p><code>public &lt;T&gt; void test(Collection&lt;T&gt; collection){}</code></p>
<p>取代</p>
<p>如果用泛型方法来取代通配符，那么上面代码中collection是能够进行写操作的。只不过要进行强制转换。</p>
<pre><code>public &lt;T&gt; void test(Collection&lt;T&gt; collection){
    collection.add((T)new Integer(12));
    collection.add((T)&quot;123&quot;);
}</code></pre><p>类型参数适用于参数之间的类别依赖关系：</p>
<pre><code>public class Test2 &lt;T,E extends T&gt;{
    T value1;
    E value2;
}</code></pre><pre><code>public &lt;D,S extends D&gt; void test(D d,S s){

    }</code></pre><p>E 类型是 T 类型的子类，显然这种情况类型参数更适合。 </p>
<p>有一种情况是，通配符和类型参数一起使用。</p>
<pre><code>public &lt;T&gt; void test(T t,Collection&lt;? extends T&gt; collection){

}</code></pre><p>如果一个方法的返回类型依赖于参数的类型，那么通配符也不行。</p>
<pre><code>public T test1(T t){
    return value1;
}</code></pre><h3 id="类型擦除，看了好几遍（尚不能完全理解，先做个记录）"><a href="#类型擦除，看了好几遍（尚不能完全理解，先做个记录）" class="headerlink" title="类型擦除，看了好几遍（尚不能完全理解，先做个记录）"></a>类型擦除，看了好几遍（尚不能完全理解，先做个记录）</h3><p>泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，泛型代码能够很好地和之前版本的代码很好地兼容。</p>
<p>这是因为，<strong>泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除</strong>。</p>
<p>泛型类和普通类在 java 虚拟机内是没有什么特别的地方。回顾文章开始时的那段代码</p>
<pre><code>List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();
List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();

System.out.println(l1.getClass() == l2.getClass());</code></pre><p>打印的结果为 true 是因为 <code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在 jvm 中的 Class 都是 <code>List.class</code>。</p>
<p>泛型信息被擦除了。</p>
<p>答案是泛型转译。</p>
<pre><code>public class Erasure &lt;T&gt;{
    T object;

    public Erasure(T object) {
        this.object = object;
    }
}</code></pre><p>Erasure 是一个泛型类，查看它在运行时的状态信息可以通过反射。</p>
<pre><code>Erasure&lt;String&gt; erasure = new Erasure&lt;String&gt;(&quot;hello&quot;);
Class eclz = erasure.getClass();
System.out.println(&quot;erasure class is:&quot;+eclz.getName());</code></pre><p>结果如下：</p>
<pre><code>erasure class is:com.alguojian.test.Erasure</code></pre><p>Class 的类型仍然是 Erasure 并不是 <code>Erasure&lt;T&gt;</code> 这种形式，再看泛型类中 T 的类型在 jvm 中是什么类型。</p>
<pre><code>Field[] fs = eclz.getDeclaredFields();
for ( Field f:fs) {
    System.out.println(&quot;Field name &quot;+f.getName()+&quot; type:&quot;+f.getType().getName());
}</code></pre><p>打印结果：</p>
<p><code>Field name object type:java.lang.Object</code></p>
<p>改变代码如下：</p>
<pre><code>public class Erasure &lt;T extends String&gt;{
//  public class Erasure &lt;T&gt;{
    T object;

    public Erasure(T object) {
        this.object = object;
    }
}</code></pre><p>打印结果：</p>
<pre><code>Field name object type:java.lang.String</code></pre><p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <t> 则会被转译成普通的 Object 类型，如果指定了上限如 <code>&lt;T extends String&gt;</code>则类型参数就被替换成类型上限。</t></p>
<p>所以在反射中：</p>
<pre><code>public class Erasure &lt;T&gt;{
    T object;

    public Erasure(T object) {
        this.object = object;
    }

    public void add(T object){

    }
}</code></pre><p>add()方法对应的Method的签名应该是Object.class</p>
<pre><code>Erasure&lt;String&gt; erasure = new Erasure&lt;String&gt;(&quot;hello&quot;);
Class eclz = erasure.getClass();
System.out.println(&quot;erasure class is:&quot;+eclz.getName());

Method[] methods = eclz.getDeclaredMethods();
for ( Method m:methods ){
    System.out.println(&quot; method:&quot;+m.toString());
}</code></pre><p>打印结果如下：</p>
<pre><code> method:public void com.frank.test.Erasure.add(java.lang.Object)</code></pre><p>也就是说，如果要在反射中找到 add 对应的 Method，应该调用 getDeclaredMethod(“add”,Object.class) 否则程序会报错，提示没有这么一个方法，原因就是类型擦除的时候，T 被替换成 Object 类型了。</p>
<h3 id="类型擦除的局限性"><a href="#类型擦除的局限性" class="headerlink" title="类型擦除的局限性"></a>类型擦除的局限性</h3><p>类型擦除，是泛型能够与之前的java版本代码兼容共存的原因，但也因为类型擦除，会抹掉很多继承相关的特性</p>
<p><strong>利用类型擦除的原理，用反射的手段就绕过了正常开发中编译器不允许的操作限制。</strong></p>
<h3 id="注意地方"><a href="#注意地方" class="headerlink" title="注意地方"></a>注意地方</h3><h4 id="泛型类或者泛型方法中，不接受8种基本数据类型"><a href="#泛型类或者泛型方法中，不接受8种基本数据类型" class="headerlink" title="泛型类或者泛型方法中，不接受8种基本数据类型"></a>泛型类或者泛型方法中，不接受8种基本数据类型</h4><pre><code>List&lt;int&gt; li = new ArrayList&lt;&gt;();
List&lt;boolean&gt; li = new ArrayList&lt;&gt;();</code></pre><p>需要使用包装类</p>
<pre><code>List&lt;Integer&gt; li = new ArrayList&lt;&gt;();
List&lt;Boolean&gt; li1 = new ArrayList&lt;&gt;();</code></pre><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><blockquote>
<p><a href="http://mp.weixin.qq.com/s/_G3ApT8dphl74e759kOUag" target="_blank" rel="noopener">设计模式番外篇之泛型</a><br><a href="https://www.ziwenxie.site/2017/03/01/java-generic/" target="_blank" rel="noopener">Java泛型详解</a><br><a href="http://www.weixueyuan.net/view/6321.html" target="_blank" rel="noopener">Java泛型详解，通俗易懂只需5分钟</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>以一种更酷的方式使用TextView</title>
    <url>/2019/02/08/%E4%BB%A5%E4%B8%80%E7%A7%8D%E6%9B%B4%E9%85%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8TextView/</url>
    <content><![CDATA[<blockquote>
<p>本文SpannableString已封装为libary上传github和jitpack，欢迎使用，地址：<a href="https://github.com/ALguojian/SpannableHelper" target="_blank" rel="noopener">SpannableHelper</a></p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-ea12c4b877cdfa2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240" alt></p>
<p>用法：</p>
<pre><code>SpannableStringUtils spannableStringUtils = new SpannableStringUtils(&quot;飞流直下三千尺，疑是银河落九天&quot;);

        spannableStringUtils.setColor(Color.GREEN, 2, 6)
                .setBackGround(ContextCompat.getColor(this,R.color.bbb), 4, 8)
                .setBold(6, 10)
                .setOnClick(9, 14, ContextCompat.getColor(this,R.color.aaa))
                .setImage(this, R.mipmap.ic_launcher, 3, 6, 120, 160)
                .setOnClickSpanListener(new SpannableStringUtils.OnClickSpanListener() {
                    @Override
                    public void OnClickSpanListener() {

                        Toast.makeText(MainActivity.this, &quot;点我&quot;, Toast.LENGTH_SHORT).show();
                    }
                });

        textView.setMovementMethod(LinkMovementMethod.getInstance());
        textView.setTextSize(20);
        textView.setText(spannableStringUtils);
</code></pre><a id="more"></a>


<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p><code>spannableString</code>和<code>string</code>类似都是一种字符串类型，都可以用于<code>textview</code>设置为版本</p>
<p><code>setSpan((Object what, int start, int end, int flags))</code></p>
<ul>
<li><code>what</code>:设置格式</li>
<li><code>start</code>：开始下标索引</li>
<li><code>end</code>：结束下表索引</li>
<li><code>flags</code>：<ul>
<li><code>Spanned.SPAN_INCLUSIVE_EXCLUSIVE</code>从起始下标到终了下标，包括起始下标</li>
<li><code>Spanned.SPAN_INCLUSIVE_INCLUSIVE</code> 从起始下标到终了下标，同时包括起始下标和终了下标</li>
<li><code>Spanned.SPAN_EXCLUSIVE_EXCLUSIVE</code> 从起始下标到终了下标，但都不包括起始下标和终了下标</li>
<li><code>Spanned.SPAN_EXCLUSIVE_INCLUSIVE</code> 从起始下标到终了下标，包括终了下标</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="改变字体颜色"><a href="#改变字体颜色" class="headerlink" title="改变字体颜色"></a>改变字体颜色</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;文字为绿色&quot;);
ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor(&quot;#57caa1&quot;));
spannableString.setSpan(colorSpan, 2, spannableString.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);
</code></pre><h4 id="设置背景色"><a href="#设置背景色" class="headerlink" title="设置背景色"></a>设置背景色</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;大珠小珠落玉盘&quot;);
BackgroundColorSpan colorSpan = new BackgroundColorSpan(Color.parseColor(&quot;#57caa1&quot;));
spannableString.setSpan(colorSpan, 2, spannableString.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><h4 id="设置文字大小"><a href="#设置文字大小" class="headerlink" title="设置文字大小"></a>设置文字大小</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;大珠小珠落玉盘&quot;);
RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(1.2f);
spannableString.setSpan(sizeSpan01, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><h4 id="设置文字中划线"><a href="#设置文字中划线" class="headerlink" title="设置文字中划线"></a>设置文字中划线</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;锄禾日当午，汗滴禾下土&quot;);
StrikethroughSpan span = new StrikethroughSpan();
spannableString.setSpan(span, 2, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><h4 id="设置下划线"><a href="#设置下划线" class="headerlink" title="设置下划线"></a>设置下划线</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;谁知盘中餐，汗滴禾下土&quot;);
UnderlineSpan span = new UnderlineSpan();
spannableString.setSpan(span, 2, spannableString.length(),Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><h4 id="设置上下标"><a href="#设置上下标" class="headerlink" title="设置上下标"></a>设置上下标</h4><p>上标</p>
<pre><code>SpannableString spannableString = new SpannableString(&quot;飞流直下三千尺，疑是银河落九天&quot;);
SuperscriptSpan span = new SuperscriptSpan();
spannableString.setSpan(span, 2, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><p>下标</p>
<pre><code>SpannableString spannableString = new SpannableString(&quot;飞流直下三千尺，疑是银河落九天&quot;);
SubscriptSpan span = new SubscriptSpan();
spannableString.setSpan(span, 2, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><h4 id="设置粗体、斜体"><a href="#设置粗体、斜体" class="headerlink" title="设置粗体、斜体"></a>设置粗体、斜体</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;飞流直下三千尺，疑是银河落九天&quot;);
StyleSpan span1 = new StyleSpan(Typeface.BOLD);
StyleSpan span2  = new StyleSpan(Typeface.ITALIC);
spannableString.setSpan(span1, 2, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
spannableString.setSpan(span2, 5, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setHighlightColor(Color.parseColor(&quot;#57caa1&quot;));
textView.setText(spannableString);</code></pre><h4 id="添加表情"><a href="#添加表情" class="headerlink" title="添加表情"></a>添加表情</h4><pre><code>SpannableString spannableString = new SpannableString(&quot;飞流直下三千尺&quot;);
Drawable drawable = getResources().getDrawable(R.mipmap.ic);
drawable.setBounds(0, 0, 22, 22);
ImageSpan span = new ImageSpan(drawable);
spannableString.setSpan(span, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
textView.setText(spannableString);</code></pre><h4 id="设置监听事件"><a href="#设置监听事件" class="headerlink" title="设置监听事件"></a>设置监听事件</h4><pre><code> SpannableString spannableString = new SpannableString(item.getContent());

    ClickableSpan span = new ClickableSpan() {

        @Override
        public void onClick(View widget) {

            ToastUtils.show(getActivity(), &quot;haha&quot;);

        }

        @Override
        public void updateDrawState(TextPaint ds) {
            super.updateDrawState(ds);
            ds.setColor(ds.linkColor);
            ds.setUnderlineText(false);
       }
    };
spannableString.setSpan(span, 2, item.getContent().length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);
ForegroundColorSpan cspan = newForegroundColorSpan(Color.parseColor(&quot;#57caa1&quot;)); 
spannableString.setSpan(cspan, 2, item.getContent().length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
TextView textView = helper.getView(R.id.group_count);
textView.setText(spannableString);
//控制点击的时候的背景色
textView.setHighlightColor(Color.parseColor(&quot;#57caa1&quot;));
textView.setMovementMethod(LinkMovementMethod.getInstance());</code></pre>]]></content>
  </entry>
  <entry>
    <title>使用google的瀑布流开源库--flexbox-layout</title>
    <url>/2019/02/07/%E4%BD%BF%E7%94%A8google%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81%E5%BC%80%E6%BA%90%E5%BA%93--flexbox-layout/</url>
    <content><![CDATA[<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>github地址如下：</p>
<blockquote>
<p><a href="https://github.com/google/flexbox-layout" target="_blank" rel="noopener">flexbox-layout</a></p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="gridle添加依赖"><a href="#gridle添加依赖" class="headerlink" title="gridle添加依赖"></a>gridle添加依赖</h4><blockquote>
<p>compile ‘com.google.android:flexbox:0.3.0’</p>
</blockquote>
<h4 id="xml使用"><a href="#xml使用" class="headerlink" title="xml使用"></a>xml使用</h4><pre><code>&lt;com.google.android.flexbox.FlexboxLayout
        android:id=&quot;@+id/flexBoxLayout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:alignContent=&quot;stretch&quot;
        app:alignItems=&quot;stretch&quot;
        app:flexDirection=&quot;row&quot;
        app:flexWrap=&quot;wrap&quot;
        app:justifyContent=&quot;flex_start&quot;
        app:showDividerHorizontal=&quot;beginning|middle&quot;&gt;

    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</code></pre><a id="more"></a>


<h4 id="动态添加子view"><a href="#动态添加子view" class="headerlink" title="动态添加子view"></a>动态添加子view</h4><pre><code>//设置交叉轴起点对齐
        flexBoxLayout.setAlignContent(FLEX_START);

        //控制副轴的对齐方式
        flexBoxLayout.setAlignItems(FLEX_START);

        //设置主轴方向
        flexBoxLayout.setFlexDirection(ROW);

        //设置换行
        flexBoxLayout.setFlexWrap(WRAP);

        //设置元素主轴方向上的对齐方式
        flexBoxLayout.setJustifyContent(FLEX_START);

        //设置水平方向分割线
        flexBoxLayout.setShowDividerHorizontal(DividerItemDecoration.VERTICAL);

        for (int i = 0; i &lt; 15; i++) {

            flexBoxLayout.addView(getItemView(&quot;just贝贝h喀&quot;));
        }

    }

    private TextView getItemView(final String string) {

        textView = new TextView(this);
        textView.setText(string);
        textView.setGravity(Gravity.CENTER);
        textView.setPadding(13, 5, 13, 5);
        textView.setTextColor(Color.BLUE);
        textView.setBackgroundColor(Color.YELLOW);
        //设置点击事件
        textView.setClickable(true);

        //设置外间距
        FlexboxLayout.LayoutParams params1 = new FlexboxLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        params1.setMargins(dpToPx(14),dpToPx(6),dpToPx(6),dpToPx(14));
        textView.setLayoutParams(params1);

        //添加点击事件
        textView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                Toast.makeText(MainActivity.this, string, Toast.LENGTH_SHORT).show();

            }
        });

        return textView;

    }

    /**
     * px转dp工具类
     *
     * @param pixel
     * @return
     */
    public int pxToDp(int pixel) {
        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
        return pixel &lt; 0 ? pixel : Math.round(pixel / displayMetrics.density);
    }

    /**
     * dp转px工具类
     *
     * @param dp
     * @return
     */
    public int dpToPx(int dp) {
        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
        return dp &lt; 0 ? dp : Math.round(dp * displayMetrics.density);
    }</code></pre><h4 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h4><h5 id="flexbox-layout属性"><a href="#flexbox-layout属性" class="headerlink" title="flexbox-layout属性"></a><code>flexbox-layout</code>属性</h5><p>1.<code>alignContent</code>属性控制多根轴线的对齐方式(也就是控制多行，如果子元素只有一行，则不起作用):</p>
<pre><code>stretch (default): 默认值，充满交叉轴的高度（测试发现，需要alignItems 的值也为stretch 才有效）。
flex_start: 与交叉轴起点对齐。
flex_end: 与交叉轴终点对齐。
center: 与交叉轴居中对齐。
space_between: 交叉轴两端对齐，中间间隔相等。
space_around: 到交叉轴两端的距离相等。</code></pre><p>2.<code>alignItems</code>性控制元素在副轴方向的对齐方式：</p>
<pre><code>stretch (default) ：默认值，如果item没有设置高度，则充满容器高度。
flex_start：顶端对齐
flex_end：底部对齐
center：居中对齐
baseline：第一行内容的的基线对齐。</code></pre><p>3.<code>flexDirection</code>属性决定了主轴的方向，即<code>FlexboxLayout</code>里子<code>Item</code>的排列方向:</p>
<pre><code>row (default)： 默认值，主轴为水平方向，起点在左端，从左到右。
row_reverse：主轴为水平方向，起点在右端，从右到左。
column：主轴为竖直方向，起点在上端，从上到下。
column_reverse：主轴为竖直方向，起点在下端，从下往上。</code></pre><p>4.<code>flexWrap</code> 这个属性决定<code>flexbox-layout</code> 容器是单行还是多行，并且决定副轴（与主轴垂直的轴）的方向:</p>
<pre><code>nowrap: 不换行，一行显示完子元素。
wrap: 按正常方向换行。
wrap_reverse: 按反方向换行。</code></pre><p>5.<code>justifyContent</code>属性控制元素主轴方向上的对齐方式:</p>
<pre><code>flex_start (default): 默认值，左对齐
flex_end: 右对齐
center: 居中对齐
space_between: 两端对齐，中间间隔相同
space_around: 每个元素到两侧的距离相等。</code></pre><p>6.<code>showDividerHorizontal</code>控制显示水平方向的分割线,值为<code>none</code>| <code>beginning</code> | <code>middle</code>| <code>end</code> 其中的一个或者多个</p>
<h5 id="flexbox-layout子view的属性"><a href="#flexbox-layout子view的属性" class="headerlink" title="flexbox-layout子view的属性"></a>flexbox-layout子view的属性</h5><p>1.<code>layout_order</code></p>
<pre><code>属性可以改变子元素的排列顺序，默认情况下，`FlexboxLayout`子元素的排列是按照xml文件中出现的顺序。默认值为1，值越小排在越靠前。</code></pre><p>2.<code>layout_flexGrow(float)</code></p>
<pre><code>layout_flexGrow 子元素的放大比例， 决定如何分配剩余空间（如果存在剩余空间的话），默认值为0,不会分配剩余空间，
如果有一个item的 layout_flexGrow 是一个正值，那么会将全部剩余空间分配给这个Item,如果有多个Item这个属性都为正值，
那么剩余空间的分配按照layout_flexGrow定义的比例（有点像LinearLayout的layout_weight属性）。</code></pre><p>3.<code>layout_flexShrink(float)：</code></p>
<pre><code>layout_flexShrink:子元素缩小比例，当空间不足时，子元素需要缩小（设置了换行则无效），默认值为1，
如果所有子元素的layout_flexShrink 值为1,空间不足时，都等比缩小，如果有一个为0，其他为1，空间不足时，为0的不缩小，负值无效。</code></pre><p>4.<code>layout_alignSelf</code></p>
<pre><code>layout_alignSelf 属性可以给子元素设置对齐方式，上面讲的alignItems属性可以设置对齐，这个属性的功能和alignItems一样，只不过alignItems作用于所有子元素，
而layout_alignSelf 作用于单个子元素。默认值为auto, 表示继承alignItems属性，如果为auto以外的值，则会覆盖alignItems属性。：</code></pre><pre><code>auto (default)
flex_start
flex_end
center
baseline
stretch

除了auto以外，其他和alignItems属性一样。</code></pre><p>5.<code>layout_flexBasisPercent (fraction)</code></p>
<pre><code>layout_flexBasisPercent的值为一个百分比，表示设置子元素的长度为它父容器长度的百分比，如果设置了这个值，那么通过这个属性计算的值将会
覆盖layout_width或者layout_height的值。但是需要注意，这个值只有设置了父容器的
长度时才有效（也就是MeasureSpec mode 是 MeasureSpec.EXACTLY）。默认值时-1。</code></pre><p>6.<code>layout_minWidth / layout_minHeight (dimension)</code></p>
<pre><code>强制限制 FlexboxLayout的子元素（宽或高）不会小于最小值，不管layout_flexShrink这个属性的值为多少，子元素不会被缩小到小于设置的这个最小值。</code></pre><p>7.<code>layout_maxWidth / layout_maxHeight (dimension)</code></p>
<pre><code>这个和上面的刚好相反，强制限制FlexboxLayout子元素不会大于这个最大值, 不管layout_flexGrow的值为多少，子元素不会被放大到超过这个最大值</code></pre><p>8.<code>layout_wrapBefore</code></p>
<pre><code>layout_wrapBefore 属性控制强制换行，默认值为false,如果将一个子元素的这个属性设置为true，那么这个子元素将会成为一行的第一个元素。这个属性将忽略flex_wrap 设置的 noWrap值。</code></pre>]]></content>
  </entry>
  <entry>
    <title>关于android使用线程池记录一下</title>
    <url>/2019/02/03/%E5%85%B3%E4%BA%8Eandroid%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>关于创建线程现在还在使用：</p>
<pre><code>new Thread(new Runnable() {

    @Override
    public void run() {
        Log.d(TAG,&quot;asd&quot;)
    }
}).start();
</code></pre><p>上面方法是有一些弊端：</p>
<ul>
<li>每次new Thread都会新建对象。</li>
<li>线程没有统一管理，有可能会创建无数个线程，占用资源过多导致卡死，OOM</li>
<li>缺少一些特定功能，（定时，定期，执行和中断）等</li>
</ul>
<a id="more"></a>

<p>相比之下线程池优点：</p>
<ul>
<li>复用线程对象，减少创建</li>
<li>控制线程并发量，避免堵塞</li>
<li>可以设置定期执行</li>
</ul>
<p>常用的几种线程池：</p>
<ul>
<li><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</code></pre></li>
<li><p>创建一个控制线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</code></pre></li>
<li><p>创建一个控制线程数量的长线程池，支持定时及周期性任务执行</p>
<pre><code>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable() {

  @Override
  public void run() {
      System.out.println(&quot;表示延迟5秒执行&quot;);
  }
}, 5, TimeUnit.SECONDS);</code></pre></li>
</ul>
<pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable() {

    @Override
    public void run() {
        System.out.println(&quot;表示延迟1秒后每5秒执行一次&quot;);
    }
}, 1, 5, TimeUnit.SECONDS);</code></pre><ul>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行,结果依次输出，相当于顺序执行各个任务。(适用于操作数据库等防止并发的操作)<pre><code>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</code></pre></li>
</ul>
<p>执行线程：</p>
<pre><code>thread.execute(new Runnable() ;</code></pre><p><a href="http://android.jobbole.com/82092/" target="_blank" rel="noopener">关于扩展线程池，以及自定义线程池</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android发布Library到JitPack</title>
    <url>/2019/02/02/Android%E5%8F%91%E5%B8%83Library%E5%88%B0JitPack/</url>
    <content><![CDATA[<h3 id="首发你要学会使用git"><a href="#首发你要学会使用git" class="headerlink" title="首发你要学会使用git"></a>首发你要学会使用git</h3><p>具体可以参考<br><a href="https://alguojian.github.io/再不学git我们就老了.html" target="_blank" rel="noopener">再不学git我们就老了</a></p>
<p>1.studio新建一个工程project，再添加一个library<br>2.再工程build。gradle添加</p>
<pre><code>buildscript { 
  dependencies {
    classpath &#39;com.github.dcendents:android-maven-gradle-plugin:1.5&#39;
                }
            }</code></pre><a id="more"></a>


<p><a href="https://github.com/dcendents/android-maven-gradle-plugin" target="_blank" rel="noopener">最新版本号可以查看github地址</a></p>
<p>3.在新建library的最上面的build.gradle(),添加maven插件</p>
<pre><code>apply plugin: &#39;com.android.library&#39;
apply plugin: &#39;com.github.dcendents.android-maven&#39;
group = &#39;com.github.ALguojian&#39;</code></pre><p>ALguojian是我的github名字，记得改成你自己的</p>
<p>4.将最新的代码提交到github然后设置一个Tag</p>
<p>点击releases，记得new一个</p>
<p>填写版本号，例如： V 1.1</p>
<p>描述也是无所谓写不写的~~</p>
<p>5.在jitpack搜索你的工程地址，点击git it 就可到使用地址</p>
<p>6.记得更新新功能，升级你的版本号，然后再次提交jitpack</p>
<p>7.点击git it 之后下面会出现图标，JitPack v1.0 的图标点击之后复制内容到项目的README.md中，你会发现有一个gitpack bar，嗯，逼格稳稳的</p>
]]></content>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/2019/02/01/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h4><p><code>Activity</code>的管理是采用<strong>任务栈</strong>(类似于集合)的形式</p>
<ul>
<li><code>Android</code>任务栈又称为Task，它是一个栈结构，具有后进先出的特性，用于存放我们的<code>Activity</code>组件。 </li>
<li>每次打开个新的<code>Activity</code>或者退出当前<code>Activity</code>都会在任务栈的中添加或者减少一个<code>Activity</code>，因此一个任务栈包含了一个<code>activity</code>的集合, <code>android</code>系统可以通过Task有序地管理每个<code>activity</code>，并决定哪个<code>Activity</code>与用户进行交互:只有在任务栈栈顶的<code>activity</code>才可以跟用户进行交互。 </li>
<li>在退出应用程序时，必须把所有的任务栈中所有的<code>activity</code>清除出栈时,任务栈才会被销毁。</li>
<li>一个App中可能不止一个任务栈，某些特殊情况下，单独一个<code>Actvity</code>可以独享一个任务栈。还有一点就是一个Task中的Actvity可以来自不同的App，同一个App的Activity也可能不在一个Task中。</li>
</ul>
<p><code>Activity</code>启动模式有如下几种</p>
<ul>
<li>标准模式（<code>standard</code>）</li>
<li>栈顶复用模式（<code>singleTop</code>）</li>
<li>栈内复用模式（<code>singleTask</code>）</li>
<li>单例模式（<code>singleInstance</code>）</li>
</ul>
<a id="more"></a>


<h5 id="标准模式（standard）"><a href="#标准模式（standard）" class="headerlink" title="标准模式（standard）"></a>标准模式（standard）</h5><ul>
<li>启动一次<code>Activity</code>就会创建一个新的<code>Activity</code>实例并且处于栈顶（启动该<code>Activity</code>的那个栈）</li>
</ul>
<h5 id="栈顶复用模式（singleTop）"><a href="#栈顶复用模式（singleTop）" class="headerlink" title="栈顶复用模式（singleTop）"></a>栈顶复用模式（singleTop）</h5><ul>
<li>如果启动的<code>Activity</code>处于栈顶，就直接重用该实例（调用<code>onNewIntent()</code>、不调用<code>onCreate()</code>和<code>onStart()</code>）</li>
<li>如果启动的<code>Activity</code>不在栈顶，就创建新的实例</li>
</ul>
<h5 id="栈内复用模式-singleTask-（在同一个栈内中的基础上）"><a href="#栈内复用模式-singleTask-（在同一个栈内中的基础上）" class="headerlink" title="栈内复用模式(singleTask)（在同一个栈内中的基础上）"></a>栈内复用模式(singleTask)（在同一个栈内中的基础上）</h5><ul>
<li>栈内已经存在该<code>Activity</code>的实例，就移除该实例上面所有<code>Activity</code></li>
<li>不存在，就创建新的实例</li>
</ul>
<h5 id="单利模式（singleInstance）"><a href="#单利模式（singleInstance）" class="headerlink" title="单利模式（singleInstance）"></a>单利模式（singleInstance）</h5><ul>
<li>启动<code>Activity</code>是就创建一个新的栈，再创建<code>Activity</code>实例放进去</li>
</ul>
<blockquote>
<p>用于多个app共享一个<code>Activity</code>实例</p>
</blockquote>
<h4 id="设置启动模式"><a href="#设置启动模式" class="headerlink" title="设置启动模式"></a>设置启动模式</h4><ul>
<li><p>清单文件里面Activity添加属性,默认为标准模式</p>
<p><code>android:launchMode=&quot;启动模式&quot;</code></p>
</li>
<li><p>通过Intent设置</p>
</li>
</ul>
<pre><code>Intent inten = new Intent (context,ActivityB.class);
intent,addFlags(Intent,FLAG_ACTIVITY_NEW_TASK);//启动模式
startActivity(intent);</code></pre><ul>
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code> //singleTop</li>
<li><code>FLAG_ACTIVITY_NEW_TASK</code> //standard</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Android常用权限</title>
    <url>/2019/01/23/Android%E5%B8%B8%E7%94%A8%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>经常用的权限，忘记就备注吧~~</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>权限</th>
</tr>
</thead>
<tbody><tr>
<td>访问登记属性</td>
<td>android.permission.ACCESS_CHECKIN_PROPERTIES ，读取或写入登记check-in数据库属性表的权限</td>
</tr>
<tr>
<td>获取错略位置</td>
<td>android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米</td>
</tr>
<tr>
<td>获取精确位置</td>
<td>android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内</td>
</tr>
<tr>
<td>访问定位额外命令</td>
<td>android.permission.ACCESS_LOCATION_EXTRA_COMMANDS，允许程序访问额外的定位提供者指令</td>
</tr>
<tr>
<td>获取模拟定位信息</td>
<td>android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用</td>
</tr>
<tr>
<td>获取网络状态</td>
<td>android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效</td>
</tr>
<tr>
<td>访问Surface Flinger</td>
<td>android.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图</td>
</tr>
<tr>
<td>获取WiFi状态</td>
<td>android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息</td>
</tr>
<tr>
<td>账户管理</td>
<td>android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限</td>
</tr>
<tr>
<td>验证账户</td>
<td>android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息</td>
</tr>
<tr>
<td>电量统计</td>
<td>android.permission.BATTERY_STATS，获取电池电量统计信息</td>
</tr>
</tbody></table>
<a id="more"></a>


<p>|绑定小插件| android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限|<br>|绑定设备管理|    android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用|<br>|绑定输入法  |android.permission.BIND_INPUT_METHOD ，请求InputMethodService服务，只有系统才能使用|<br>|绑定RemoteView|  android.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用|<br>|绑定壁纸|  android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用|<br>|使用蓝牙|  android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备|<br>|蓝牙管理|  android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备|<br>|变成砖头|  android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头|<br>|应用删除时广播    |android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播|<br>|收到短信时广播|android.permission.BROADCAST_SMS，当收到短信时触发一个广播|<br>|连续广播|  android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播|<br>|WAP PUSH广播|    android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播|<br>|拨打电话|  android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码|<br>|通话权限|  android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面|<br>|拍照权限|  android.permission.CAMERA，允许访问摄像头进行拍照|<br>|改变组件状态|    android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态|<br>|改变配置|  android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位|<br>|改变网络状态|    android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网|<br>|改变WiFi多播状态|    android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态|<br>|改变WiFi状态|  android.permission.CHANGE_WIFI_STATE，改变WiFi状态|<br>|清除应用缓存|    android.permission.CLEAR_APP_CACHE，清除应用缓存|<br>|清除用户数据|    android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据|<br>|底层访问权限|    android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息|<br>|手机优化大师扩展权限|    android.permission.CELL_PHONE_MASTER_EX，手机优化大师扩展权限|<br>|控制定位更新|    android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变|<br>|删除缓存文件|    android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件|<br>|删除应用|  android.permission.DELETE_PACKAGES，允许程序删除应用|<br>|电源管理|  android.permission.DEVICE_POWER，允许访问底层电源管理|<br>|应用诊断|  android.permission.DIAGNOSTIC，允许程序到RW到诊断资源|<br>|禁用键盘锁| android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁|<br>|转存系统信息|    android.permission.DUMP，允许程序获取系统dump信息从系统服务<br>|状态栏控制| android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏|<br>|工厂测试模式|    android.permission.FACTORY_TEST，允许程序运行工厂测试模式|<br>|使用闪光灯| android.permission.FLASHLIGHT，允许访问闪光灯|<br>|强制后退|  android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层|<br>|访问账户Gmail列表|   android.permission.GET_ACCOUNTS，访问GMail账户列表|<br>|获取应用大小|    android.permission.GET_PACKAGE_SIZE，获取应用的文件大小|<br>|获取任务信息|    android.permission.GET_TASKS，允许程序获取当前或最近运行的应用|<br>|允许全局搜索|    android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能|<br>|硬件测试|  android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试|<br>|注射事件|  android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流|<br>|安装定位提供|    android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供|<br>|安装应用程序|    android.permission.INSTALL_PACKAGES，允许程序安装应用|<br>|内部系统窗口|    android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限|<br>|访问网络|  android.permission.INTERNET，访问网络连接，可能产生GPRS流量|<br>|结束后台进程|    android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程|<br>|管理账户|  android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表|<br>|管理程序引用|    android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统|<br>|高级权限|  android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限|<br>|社区权限|  android.permission.MTWEAK_FORUM，允许使用mTweak社区权限|<br>|软格式化|  android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息|<br>|修改声音设置|    android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息|<br>|修改电话状态|    android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面|<br>|格式化文件系统|   android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡|<br>|挂载文件系统|    android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统|<br>|允许NFC通讯|   android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持|<br>|永久Activity|    android.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除|<br>|处理拨出电话|    android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话|<br>|读取日程提醒|    android.permission.READ_CALENDAR，允许程序读取用户的日程信息|<br>|读取联系人| android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息|<br>|屏幕截图|  android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图|<br>|读取收藏夹和历史记录|    com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录|<br>|读取输入状态|    android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统|<br>|读取系统日志|    android.permission.READ_LOGS，读取系统底层日志|<br>|读取电话状态|    android.permission.READ_PHONE_STATE，访问电话状态|<br>|读取短信内容|    android.permission.READ_SMS，读取短信内容|<br>|读取同步设置|    android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置|<br>|读取同步状态|    android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态|<br>|重启设备|  android.permission.REBOOT，允许程序重新启动设备|<br>|开机自动允许|    android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行|<br>|接收彩信|  android.permission.RECEIVE_MMS，接收彩信|<br>|接收短信|  android.permission.RECEIVE_SMS，接收短信|<br>|接收Wap Push|    android.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息|<br>|录音|    android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克|<br>|排序系统任务|    android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务|<br>|结束系统任务|    android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃|<br>|发送短信|  android.permission.SEND_SMS，发送短信|<br>|设置Activity观察其| android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试|<br>|设置闹铃提醒|    com.android.alarm.permission.SET_ALARM，设置闹铃提醒|<br>|设置总是退出|    android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出|<br>|设置动画缩放|    android.permission.SET_ANIMATION_SCALE，设置全局动画缩放|<br>|设置调试程序|    android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发|<br>|设置屏幕方向|    android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用|<br>|设置应用参数|    android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍|<br>|设置进程限制|    android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制|<br>|设置系统时间|    android.permission.SET_TIME，设置系统时间|<br>|设置系统时区|    android.permission.SET_TIME_ZONE，设置系统时区|<br>|设置桌面壁纸|    android.permission.SET_WALLPAPER，设置桌面壁纸|<br>|设置壁纸建议|    android.permission.SET_WALLPAPER_HINTS，设置壁纸建议|<br>|发送永久进程信号|  android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号|<br>|状态栏控制| android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏|<br>|访问订阅内容|    android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库|<br>|写入订阅内容|    android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库|<br>|显示系统窗口|    android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口|<br>|更新设备状态|    android.permission.UPDATE_DEVICE_STATS，更新设备状态|<br>|使用证书|  android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager<br>|使用SIP视频|   android.permission.USE_SIP，允许程序使用SIP视频服务|<br>|使用振动|  android.permission.VIBRATE，允许振动|<br>|唤醒锁定|  android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行|<br>|写入GPRS接入点设置|   android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置|<br>|写入日程提醒|    android.permission.WRITE_CALENDAR，写入日程，但不可读取|<br>|写入联系人  |android.permission.WRITE_CONTACTS，写入联系人，但不可读取|<br>|写入外部存储|    android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件|<br>|写入Google地图数据|  android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据|<br>|写入收藏夹和历史记录|    com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取|<br>|读写系统敏感设置|  android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项|<br>|读写系统设置 |android.permission.WRITE_SETTINGS，允许读写系统设置项|<br>|编写短信|  android.permission.WRITE_SMS，允许编写短信|<br>|写入在线同步设置|  android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置|</p>
]]></content>
  </entry>
  <entry>
    <title>Android沉浸式状态栏</title>
    <url>/2018/08/23/Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
    <content><![CDATA[<h3 id="沉浸式状态栏有几种方式"><a href="#沉浸式状态栏有几种方式" class="headerlink" title="沉浸式状态栏有几种方式"></a>沉浸式状态栏有几种方式</h3><ul>
<li>代码动态配置</li>
<li>配置不同版本的主题信息</li>
</ul>
<a id="more"></a>

<p>下面说一下动态配置，比较简单，也好理解</p>
<p>首先你要先去掉状态栏对吧，当然还可以去掉导航栏(比如华为的大黑边实在是很丑)<br>你可以在你的Activity(建议在baseavtivity里面管理)写如下代码：</p>
<pre><code> if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {

            //隐藏状态栏
            getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);

            //隐藏导航栏
            getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
        }</code></pre><p>接下来你就会发现布局会顶到手机最上面，那么状态栏颜色怎么确定呢，这时候就需要设置你想要的颜色的那个布局：</p>
<pre><code>android:fitsSystemWindows=&quot;true&quot;</code></pre><!--more-->


<p>或者还可以在主题配置里面去写死，都是可以的(但是不够优雅)，装逼就要装的有深度不是~~</p>
<p>效果图如下：最外层是一个webview，加载的就是我的blog</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/7426378-818726a1f874c2dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
]]></content>
  </entry>
  <entry>
    <title>Android反编译</title>
    <url>/2018/07/23/Android%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ul>
<li><p><a href="https://github.com/iBotPeaches/Apktool" target="_blank" rel="noopener">apktool (github地址)</a></p>
</li>
<li><p><a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="noopener">dex2jar (github地址)</a></p>
<a id="more"></a></li>
<li><p><a href="http://pan.baidu.com/s/1gfBxrsJ" target="_blank" rel="noopener">或者使用我的百度云分享,均是最新版本</a></p>
</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>apktool<br>  作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看</li>
</ul>
<ul>
<li>dex2jar<br>   作用：将apk反编译成java源码（classes.dex转化成jar文件）</li>
</ul>
<h2 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h2><h3 id="apktool编译"><a href="#apktool编译" class="headerlink" title="apktool编译"></a>apktool编译</h3><p>在dos窗口进入apktool文件夹，或者在文件夹内点击shift右键在此处打开dos窗口，将qq.apk放入文件夹，dos输入此命令：<code>apktool.bat d -f  qq.apk</code><br>如果想让编译之后的文件重新打包成apk只用输入<code>apktool.bat   b    qq</code></p>
<h3 id="dex2jar反编译"><a href="#dex2jar反编译" class="headerlink" title="dex2jar反编译"></a>dex2jar反编译</h3><p>将qq.apk改为qq.zip解压之后得到classes.dex文件，将文件放入dex2jar文件内，dos输入<code>d2j-dex2jar.bat classes.dex</code>就会得到新的<code>classes_dex2jar.jar</code>jar包，有了jar包可以放入ecplise或者studio直接编译，或者下载<code>jd-gui</code>工具查看jar包源码</p>
]]></content>
  </entry>
  <entry>
    <title>常用DOS命令</title>
    <url>/2018/06/27/%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/7426378-68c9e1cf612ddbae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><ul>
<li><p>无参数： 查看当前所在目录的文件和文件夹</p>
</li>
<li><p><code>/s</code>： 查看当前目录以及其子目录的文件和文件夹</p>
</li>
<li><p><code>/a</code>： 查看包括银行文件的所有文件</p>
</li>
<li><p><code>/ah</code>： 只显示隐含文件</p>
</li>
<li><p><code>/w</code>： 以紧凑方式（一行显示5个文件）显示文件和文件夹</p>
</li>
<li><p><code>/p</code>： 以分页方式（显示一页之后会自动暂停）显示</p>
</li>
<li><p><code>|more</code>： 前面那个符号是<code>&quot;\&quot;</code>上面的那个，叫做重定向符号，就是一个命令的结果输出为灵位一个命令的参数，<code>more</code>也是一个命令，<code>dir/w|more</code>得到的结果和<code>dir/w/p</code>的结果是一样的</p>
</li>
<li><p>更多参数可以使用： <code>dir/？</code>查看</p>
</li>
</ul>
<a id="more"></a>


<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><ul>
<li><p><code>cd 目录名</code>： 进入特定的目录，如果看到有个目录显示为sdk就是：<code>cd sdk</code>回车就行</p>
</li>
<li><p><code>cd\</code> 回到根目录</p>
</li>
<li><p><code>cd..</code> 返回上一级</p>
</li>
</ul>
<h2 id="md-rd"><a href="#md-rd" class="headerlink" title="md   rd"></a>md   rd</h2><ul>
<li><p><code>md 目录名</code>： 建立特定的文件夹（dos下面叫目录，win下面叫文件夹）</p>
</li>
<li><p><code>rd 目录名</code>： 删除特定的文件夹</p>
</li>
</ul>
<h2 id="cls"><a href="#cls" class="headerlink" title="cls"></a>cls</h2><ul>
<li>清屏</li>
</ul>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><ul>
<li><code>copy 路径\文件名 路径\文件名</code> ：把一个文件拷贝到另一个地方</li>
</ul>
<h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><ul>
<li><code>move 路径\文件名 路径\文件名</code>：把一个文件移动（剪切+复制）到另一个地方</li>
</ul>
<h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><ul>
<li><p><code>del文件名</code>： 删除一个文件</p>
</li>
<li><p><code>del*.*</code>： 删除当前文件夹下所有文件</p>
</li>
<li><p><code>del</code>不能删除文件夹</p>
</li>
</ul>
<h2 id="deltree"><a href="#deltree" class="headerlink" title="deltree"></a>deltree</h2><ul>
<li>删除文件夹和它下面的所有子文件夹还有文件</li>
</ul>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><ul>
<li><code>format x:</code>： X代表盘符，格式化一个分区，在dos下是用fat文件系统格式化的</li>
</ul>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><ul>
<li><code>type文本文件名</code>： 显示楚文本文件的内容</li>
</ul>
<h2 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h2><ul>
<li>小程序，编辑文本使用</li>
</ul>
<h2 id="ren"><a href="#ren" class="headerlink" title="ren"></a>ren</h2><ul>
<li><code>ren旧文件名 新文件名</code>： 该文件名字</li>
</ul>
<h1 id="关于网络常用命令"><a href="#关于网络常用命令" class="headerlink" title="关于网络常用命令"></a>关于网络常用命令</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><ul>
<li><p><code>ping主机ip或名字</code>： 向目标主机发送4个icmp数据包，测试对方主机是否收到并响应，一半常用于做普通网络是否通畅的测试。当时ping不同不代表网络不通，有可能目标主机有防火墙并且阻止的icmp的响应。</p>
</li>
<li><p><code>ping-t</code>： 不停的发送数据包，当然都很小，不能称作攻击，有些人自己写了一些类似于ping命令的程序，不停的发送很大的数据包，以阻塞目标主机的网络连接。</p>
</li>
</ul>
<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><ul>
<li>建议使用<code>net/？</code>获取帮助信息。实在是有很多参数，参数下面还有参数，常用：<code>net view \\主机</code>来看共享，<code>net start/stop</code> 服务来启动和停止服务</li>
</ul>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><ul>
<li><code>netstat主机</code>： 查看主机当前<code>tcp/ip</code>连接状态，如端口的状态。</li>
</ul>
<h2 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h2><ul>
<li><code>nbtstat主机</code>： 查看主机使用的 NetBIOS name</li>
</ul>
<h2 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h2><ul>
<li><code>tracert主机</code>： 查看从你自己到目标主机道济经过了那些路径</li>
</ul>
<h2 id="pathping"><a href="#pathping" class="headerlink" title="pathping"></a>pathping</h2><ul>
<li><code>pathping主机</code>： 类似tracert，但可以显示一些tracert不能显示出来的信息</li>
</ul>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><ul>
<li>字符方式的远程登录程序，是网络人员及其爱用的远程登录程序</li>
</ul>
<h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>非常有用的网络配置、排错。。。命令。 不加参数显示当前机器的网络接口状态。 </p>
<ul>
<li><code>/all</code> 先是详细的信息。 </li>
<li><code>/release</code> 释放当前ip。 </li>
<li><code>/renew</code> 重新申请ip。 </li>
<li><code>/flushdns</code> 刷新dns缓存。 </li>
<li><code>/registerdns</code> 重新栽dns服务器上注册自己。  </li>
</ul>
<h2 id="arp-操作当前的arp缓存。"><a href="#arp-操作当前的arp缓存。" class="headerlink" title="arp 操作当前的arp缓存。"></a>arp 操作当前的arp缓存。</h2><ul>
<li><code>-a</code> 显示arp缓存。 </li>
<li><code>-d</code> 删除一条缓存纪录。 </li>
<li><code>-s</code> 田家一条缓存纪录。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Live Teplates 的使用</title>
    <url>/2018/06/23/Live%20Teplates%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Live-Teplates-的使用"><a href="#Live-Teplates-的使用" class="headerlink" title="Live Teplates 的使用"></a>Live Teplates 的使用</h4><p>Live Teplates可以实现对代码模块的快速定义，就像平时常用的fori，sout，foreach，fvd等都是常用的ide自带的已经定义好的模板，Live Teplates可以帮助我们快速开发，通过快捷键快速写出我们定义的代码，下面看一下怎么自定义Live Teplates。</p>
<a id="more"></a>

<h4 id="Live-Teplates-位置"><a href="#Live-Teplates-位置" class="headerlink" title="Live Teplates 位置"></a>Live Teplates 位置</h4><blockquote>
<p>setting-&gt;Editor-&gt;Live Templates</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-3fd88a816febb09f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h4 id="点击右上角-号创建新的Live-Teplates，建议先点击下面的Template-group你可以理解为先建一个包，不如我的包就是最上面的alguojian，之后选中包在建一个eLive-Teplates"><a href="#点击右上角-号创建新的Live-Teplates，建议先点击下面的Template-group你可以理解为先建一个包，不如我的包就是最上面的alguojian，之后选中包在建一个eLive-Teplates" class="headerlink" title="点击右上角+号创建新的Live Teplates，建议先点击下面的Template group你可以理解为先建一个包，不如我的包就是最上面的alguojian，之后选中包在建一个eLive Teplates"></a>点击右上角+号创建新的Live Teplates，建议先点击下面的Template group你可以理解为先建一个包，不如我的包就是最上面的alguojian，之后选中包在建一个eLive Teplates</h4><p><img src="http://upload-images.jianshu.io/upload_images/7426378-efecc9dd1a1176dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<blockquote>
<p>点击edit variables，我们可以看到</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/7426378-08faac4f6e2e1ef0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>Name：你定义的所有双$包括的变量</li>
<li>Expression:   为待输入变量</li>
<li>Default value:  赋值默认值</li>
<li>Skip if defined:  是否跳过编辑</li>
</ul>
<blockquote>
<p>上面className代表类名，我们可以看到当前Expression还有很多函数：具体的可以到官网</p>
<blockquote>
<p><a href="https://www.jetbrains.com/help/idea/2016.1/live-template-variables.html" target="_blank" rel="noopener">IntellIJ IDEA</a></p>
</blockquote>
</blockquote>
<h4 id="下面写了一个简单的例子："><a href="#下面写了一个简单的例子：" class="headerlink" title="下面写了一个简单的例子："></a>下面写了一个简单的例子：</h4><p><img src="http://upload-images.jianshu.io/upload_images/7426378-efd715937b29e93d.gif?imageMogr2/auto-orient/strip" alt></p>
]]></content>
  </entry>
</search>
